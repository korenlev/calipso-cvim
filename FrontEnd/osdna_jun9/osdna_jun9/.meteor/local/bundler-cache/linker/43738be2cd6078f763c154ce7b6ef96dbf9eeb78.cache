[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar meteorInstall = Package['modules-runtime'].meteorInstall;\n\n/* Package-scope variables */\nvar Buffer, process;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"modules\":{\"client.js\":[\"./install-packages.js\",\"./stubs.js\",\"./buffer.js\",\"./process.js\",\"./css\",function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/modules/client.js                                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nrequire(\"./install-packages.js\");                                                                                      // 1\nrequire(\"./stubs.js\");                                                                                                 // 2\nrequire(\"./buffer.js\");                                                                                                // 3\nrequire(\"./process.js\");                                                                                               // 4\n                                                                                                                       // 5\nexports.addStyles = require(\"./css\").addStyles;                                                                        // 6\n                                                                                                                       // 7\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"buffer.js\":[\"buffer\",function(require){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/modules/buffer.js                                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\ntry {                                                                                                                  // 1\n  Buffer = global.Buffer || require(\"buffer\").Buffer;                                                                  // 2\n} catch (noBuffer) {}                                                                                                  // 3\n                                                                                                                       // 4\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"css.js\":function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/modules/css.js                                                                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar doc = document;                                                                                                    // 1\nvar head = doc.getElementsByTagName(\"head\").item(0);                                                                   // 2\n                                                                                                                       // 3\nexports.addStyles = function (css) {                                                                                   // 4\n  var style = doc.createElement(\"style\");                                                                              // 5\n                                                                                                                       // 6\n  style.setAttribute(\"type\", \"text/css\");                                                                              // 7\n                                                                                                                       // 8\n  // https://msdn.microsoft.com/en-us/library/ms535871(v=vs.85).aspx                                                   // 9\n  var internetExplorerSheetObject =                                                                                    // 10\n    style.sheet || // Edge/IE11.                                                                                       // 11\n    style.styleSheet; // Older IEs.                                                                                    // 12\n                                                                                                                       // 13\n  if (internetExplorerSheetObject) {                                                                                   // 14\n    internetExplorerSheetObject.cssText = css;                                                                         // 15\n  } else {                                                                                                             // 16\n    style.appendChild(doc.createTextNode(css));                                                                        // 17\n  }                                                                                                                    // 18\n                                                                                                                       // 19\n  return head.appendChild(style);                                                                                      // 20\n};                                                                                                                     // 21\n                                                                                                                       // 22\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"install-packages.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/modules/install-packages.js                                                                                //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nfunction install(name) {                                                                                               // 1\n  var meteorDir = {};                                                                                                  // 2\n                                                                                                                       // 3\n  // Given a package name <name>, install a stub module in the                                                         // 4\n  // /node_modules/meteor directory called <name>.js, so that                                                          // 5\n  // require.resolve(\"meteor/<name>\") will always return                                                               // 6\n  // /node_modules/meteor/<name>.js instead of something like                                                          // 7\n  // /node_modules/meteor/<name>/index.js, in the rare but possible event                                              // 8\n  // that the package contains a file called index.js (#6590).                                                         // 9\n  meteorDir[name + \".js\"] = function (r, e, module) {                                                                  // 10\n    module.exports = Package[name];                                                                                    // 11\n  };                                                                                                                   // 12\n                                                                                                                       // 13\n  meteorInstall({                                                                                                      // 14\n    node_modules: {                                                                                                    // 15\n      meteor: meteorDir                                                                                                // 16\n    }                                                                                                                  // 17\n  });                                                                                                                  // 18\n}                                                                                                                      // 19\n                                                                                                                       // 20\n// This file will be modified during computeJsOutputFilesMap to include                                                // 21\n// install(<name>) calls for every Meteor package.                                                                     // 22\n                                                                                                                       // 23\ninstall(\"underscore\");                                                                                                 // 24\ninstall(\"meteor\");                                                                                                     // 25\ninstall(\"meteor-base\");                                                                                                // 26\ninstall(\"mobile-experience\");                                                                                          // 27\ninstall(\"babel-compiler\");                                                                                             // 28\ninstall(\"ecmascript\");                                                                                                 // 29\ninstall(\"base64\");                                                                                                     // 30\ninstall(\"ejson\");                                                                                                      // 31\ninstall(\"id-map\");                                                                                                     // 32\ninstall(\"ordered-dict\");                                                                                               // 33\ninstall(\"tracker\");                                                                                                    // 34\ninstall(\"modules-runtime\");                                                                                            // 35\ninstall(\"modules\");                                                                                                    // 36\ninstall(\"es5-shim\");                                                                                                   // 37\ninstall(\"promise\");                                                                                                    // 38\ninstall(\"ecmascript-runtime\");                                                                                         // 39\ninstall(\"babel-runtime\");                                                                                              // 40\ninstall(\"random\");                                                                                                     // 41\ninstall(\"mongo-id\");                                                                                                   // 42\ninstall(\"diff-sequence\");                                                                                              // 43\ninstall(\"geojson-utils\");                                                                                              // 44\ninstall(\"minimongo\");                                                                                                  // 45\ninstall(\"check\");                                                                                                      // 46\ninstall(\"retry\");                                                                                                      // 47\ninstall(\"ddp-common\");                                                                                                 // 48\ninstall(\"reload\");                                                                                                     // 49\ninstall(\"ddp-client\");                                                                                                 // 50\ninstall(\"ddp\");                                                                                                        // 51\ninstall(\"ddp-server\");                                                                                                 // 52\ninstall(\"allow-deny\");                                                                                                 // 53\ninstall(\"mongo\");                                                                                                      // 54\ninstall(\"blaze-html-templates\");                                                                                       // 55\ninstall(\"reactive-dict\");                                                                                              // 56\ninstall(\"session\");                                                                                                    // 57\ninstall(\"jquery\");                                                                                                     // 58\ninstall(\"url\");                                                                                                        // 59\ninstall(\"http\");                                                                                                       // 60\ninstall(\"deps\");                                                                                                       // 61\ninstall(\"htmljs\");                                                                                                     // 62\ninstall(\"observe-sequence\");                                                                                           // 63\ninstall(\"reactive-var\");                                                                                               // 64\ninstall(\"blaze\");                                                                                                      // 65\ninstall(\"ui\");                                                                                                         // 66\ninstall(\"spacebars\");                                                                                                  // 67\ninstall(\"templating\");                                                                                                 // 68\ninstall(\"iron:core\");                                                                                                  // 69\ninstall(\"iron:dynamic-template\");                                                                                      // 70\ninstall(\"iron:layout\");                                                                                                // 71\ninstall(\"iron:url\");                                                                                                   // 72\ninstall(\"iron:middleware-stack\");                                                                                      // 73\ninstall(\"iron:location\");                                                                                              // 74\ninstall(\"iron:controller\");                                                                                            // 75\ninstall(\"iron:router\");                                                                                                // 76\ninstall(\"twbs:bootstrap\");                                                                                             // 77\ninstall(\"d3js:d3\");                                                                                                    // 78\ninstall(\"standard-minifier-css\");                                                                                      // 79\ninstall(\"standard-minifier-js\");                                                                                       // 80\ninstall(\"limemakers:three\");                                                                                           // 81\ninstall(\"pcel:loading\");                                                                                               // 82\ninstall(\"spectrum:material-design-lite\");                                                                              // 83\ninstall(\"timmyg:wow\");                                                                                                 // 84\ninstall(\"ddp-rate-limiter\");                                                                                           // 85\ninstall(\"localstorage\");                                                                                               // 86\ninstall(\"callback-hook\");                                                                                              // 87\ninstall(\"accounts-base\");                                                                                              // 88\ninstall(\"service-configuration\");                                                                                      // 89\ninstall(\"npm-bcrypt\");                                                                                                 // 90\ninstall(\"sha\");                                                                                                        // 91\ninstall(\"srp\");                                                                                                        // 92\ninstall(\"accounts-password\");                                                                                          // 93\ninstall(\"less\");                                                                                                       // 94\ninstall(\"accounts-ui-unstyled\");                                                                                       // 95\ninstall(\"accounts-ui\");                                                                                                // 96\ninstall(\"coffeescript\");                                                                                               // 97\ninstall(\"zimme:active-route\");                                                                                         // 98\ninstall(\"gwendall:auth-client-callbacks\");                                                                             // 99\ninstall(\"fortawesome:fontawesome\");                                                                                    // 100\ninstall(\"chrismbeckett:toastr\");                                                                                       // 101\ninstall(\"stolinski:stylus-multi\");                                                                                     // 102\ninstall(\"webapp\");                                                                                                     // 103\ninstall(\"livedata\");                                                                                                   // 104\ninstall(\"hot-code-push\");                                                                                              // 105\ninstall(\"launch-screen\");                                                                                              // 106\ninstall(\"autoupdate\");                                                                                                 // 107\n                                                                                                                       // 108\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"process.js\":[\"process\",function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/modules/process.js                                                                                         //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\ntry {                                                                                                                  // 1\n  // The application can run `npm install process` to provide its own                                                  // 2\n  // process stub; otherwise this module will provide a partial stub.                                                  // 3\n  process = global.process || require(\"process\");                                                                      // 4\n} catch (noProcess) {                                                                                                  // 5\n  process = {};                                                                                                        // 6\n}                                                                                                                      // 7\n                                                                                                                       // 8\nif (Meteor.isServer) {                                                                                                 // 9\n  // Make require(\"process\") work on the server in all versions of Node.                                               // 10\n  meteorInstall({                                                                                                      // 11\n    node_modules: {                                                                                                    // 12\n      \"process.js\": function (r, e, module) {                                                                          // 13\n        module.exports = process;                                                                                      // 14\n      }                                                                                                                // 15\n    }                                                                                                                  // 16\n  });                                                                                                                  // 17\n} else {                                                                                                               // 18\n  process.platform = \"browser\";                                                                                        // 19\n  process.nextTick = process.nextTick || Meteor._setImmediate;                                                         // 20\n}                                                                                                                      // 21\n                                                                                                                       // 22\nif (typeof process.env !== \"object\") {                                                                                 // 23\n  process.env = {};                                                                                                    // 24\n}                                                                                                                      // 25\n                                                                                                                       // 26\n_.extend(process.env, meteorEnv);                                                                                      // 27\n                                                                                                                       // 28\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"stubs.js\":[\"meteor-node-stubs\",function(require){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/modules/stubs.js                                                                                           //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\ntry {                                                                                                                  // 1\n  // When meteor-node-stubs is installed in the application's root                                                     // 2\n  // node_modules directory, requiring it here installs aliases for stubs                                              // 3\n  // for all Node built-in modules, such as fs, util, and http.                                                        // 4\n  require(\"meteor-node-stubs\");                                                                                        // 5\n} catch (noStubs) {}                                                                                                   // 6\n                                                                                                                       // 7\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]}},\"webcola\":{\"package.json\":function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/webcola/package.json                                                                                   //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nexports.name = \"webcola\";                                                                                              // 1\nexports.version = \"3.1.3\";                                                                                             // 2\nexports.main = \"WebCola/index.js\";                                                                                     // 3\n                                                                                                                       // 4\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"WebCola\":{\"index.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/webcola/WebCola/index.js                                                                               //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar cola;                                                                                                              // 1\n(function (cola) {                                                                                                     // 2\n    var packingOptions = {                                                                                             // 3\n        PADDING: 10,                                                                                                   // 4\n        GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,                                                                        // 5\n        FLOAT_EPSILON: 0.0001,                                                                                         // 6\n        MAX_INERATIONS: 100                                                                                            // 7\n    };                                                                                                                 // 8\n    // assign x, y to nodes while using box packing algorithm for disconnected graphs                                  // 9\n    function applyPacking(graphs, w, h, node_size, desired_ratio) {                                                    // 10\n        if (desired_ratio === void 0) { desired_ratio = 1; }                                                           // 11\n        var init_x = 0, init_y = 0, svg_width = w, svg_height = h, desired_ratio = typeof desired_ratio !== 'undefined' ? desired_ratio : 1, node_size = typeof node_size !== 'undefined' ? node_size : 0, real_width = 0, real_height = 0, min_width = 0, global_bottom = 0, line = [];\n        if (graphs.length == 0)                                                                                        // 13\n            return;                                                                                                    // 14\n        /// that would take care of single nodes problem                                                               // 15\n        // graphs.forEach(function (g) {                                                                               // 16\n        //     if (g.array.length == 1) {                                                                              // 17\n        //         g.array[0].x = 0;                                                                                   // 18\n        //         g.array[0].y = 0;                                                                                   // 19\n        //     }                                                                                                       // 20\n        // });                                                                                                         // 21\n        calculate_bb(graphs);                                                                                          // 22\n        apply(graphs, desired_ratio);                                                                                  // 23\n        put_nodes_to_right_positions(graphs);                                                                          // 24\n        // get bounding boxes for all separate graphs                                                                  // 25\n        function calculate_bb(graphs) {                                                                                // 26\n            graphs.forEach(function (g) {                                                                              // 27\n                calculate_single_bb(g);                                                                                // 28\n            });                                                                                                        // 29\n            function calculate_single_bb(graph) {                                                                      // 30\n                var min_x = Number.MAX_VALUE, min_y = Number.MAX_VALUE, max_x = 0, max_y = 0;                          // 31\n                graph.array.forEach(function (v) {                                                                     // 32\n                    var w = typeof v.width !== 'undefined' ? v.width : node_size;                                      // 33\n                    var h = typeof v.height !== 'undefined' ? v.height : node_size;                                    // 34\n                    w /= 2;                                                                                            // 35\n                    h /= 2;                                                                                            // 36\n                    max_x = Math.max(v.x + w, max_x);                                                                  // 37\n                    min_x = Math.min(v.x - w, min_x);                                                                  // 38\n                    max_y = Math.max(v.y + h, max_y);                                                                  // 39\n                    min_y = Math.min(v.y - h, min_y);                                                                  // 40\n                });                                                                                                    // 41\n                graph.width = max_x - min_x;                                                                           // 42\n                graph.height = max_y - min_y;                                                                          // 43\n            }                                                                                                          // 44\n        }                                                                                                              // 45\n        //function plot(data, left, right, opt_x, opt_y) {                                                             // 46\n        //    // plot the cost function                                                                                // 47\n        //    var plot_svg = d3.select(\"body\").append(\"svg\")                                                           // 48\n        //        .attr(\"width\", function () { return 2 * (right - left); })                                           // 49\n        //        .attr(\"height\", 200);                                                                                // 50\n        //    var x = d3.time.scale().range([0, 2 * (right - left)]);                                                  // 51\n        //    var xAxis = d3.svg.axis().scale(x).orient(\"bottom\");                                                     // 52\n        //    plot_svg.append(\"g\").attr(\"class\", \"x axis\")                                                             // 53\n        //        .attr(\"transform\", \"translate(0, 199)\")                                                              // 54\n        //        .call(xAxis);                                                                                        // 55\n        //    var lastX = 0;                                                                                           // 56\n        //    var lastY = 0;                                                                                           // 57\n        //    var value = 0;                                                                                           // 58\n        //    for (var r = left; r < right; r += 1) {                                                                  // 59\n        //        value = step(data, r);                                                                               // 60\n        //        // value = 1;                                                                                        // 61\n        //        plot_svg.append(\"line\").attr(\"x1\", 2 * (lastX - left))                                               // 62\n        //            .attr(\"y1\", 200 - 30 * lastY)                                                                    // 63\n        //            .attr(\"x2\", 2 * r - 2 * left)                                                                    // 64\n        //            .attr(\"y2\", 200 - 30 * value)                                                                    // 65\n        //            .style(\"stroke\", \"rgb(6,120,155)\");                                                              // 66\n        //        lastX = r;                                                                                           // 67\n        //        lastY = value;                                                                                       // 68\n        //    }                                                                                                        // 69\n        //    plot_svg.append(\"circle\").attr(\"cx\", 2 * opt_x - 2 * left).attr(\"cy\", 200 - 30 * opt_y)                  // 70\n        //        .attr(\"r\", 5).style('fill', \"rgba(0,0,0,0.5)\");                                                      // 71\n        //}                                                                                                            // 72\n        // actual assigning of position to nodes                                                                       // 73\n        function put_nodes_to_right_positions(graphs) {                                                                // 74\n            graphs.forEach(function (g) {                                                                              // 75\n                // calculate current graph center:                                                                     // 76\n                var center = { x: 0, y: 0 };                                                                           // 77\n                g.array.forEach(function (node) {                                                                      // 78\n                    center.x += node.x;                                                                                // 79\n                    center.y += node.y;                                                                                // 80\n                });                                                                                                    // 81\n                center.x /= g.array.length;                                                                            // 82\n                center.y /= g.array.length;                                                                            // 83\n                // calculate current top left corner:                                                                  // 84\n                var corner = { x: center.x - g.width / 2, y: center.y - g.height / 2 };                                // 85\n                var offset = { x: g.x - corner.x + svg_width / 2 - real_width / 2, y: g.y - corner.y + svg_height / 2 - real_height / 2 };\n                // put nodes:                                                                                          // 87\n                g.array.forEach(function (node) {                                                                      // 88\n                    node.x += offset.x;                                                                                // 89\n                    node.y += offset.y;                                                                                // 90\n                });                                                                                                    // 91\n            });                                                                                                        // 92\n        }                                                                                                              // 93\n        // starts box packing algorithm                                                                                // 94\n        // desired ratio is 1 by default                                                                               // 95\n        function apply(data, desired_ratio) {                                                                          // 96\n            var curr_best_f = Number.POSITIVE_INFINITY;                                                                // 97\n            var curr_best = 0;                                                                                         // 98\n            data.sort(function (a, b) { return b.height - a.height; });                                                // 99\n            min_width = data.reduce(function (a, b) {                                                                  // 100\n                return a.width < b.width ? a.width : b.width;                                                          // 101\n            });                                                                                                        // 102\n            var left = x1 = min_width;                                                                                 // 103\n            var right = x2 = get_entire_width(data);                                                                   // 104\n            var iterationCounter = 0;                                                                                  // 105\n            var f_x1 = Number.MAX_VALUE;                                                                               // 106\n            var f_x2 = Number.MAX_VALUE;                                                                               // 107\n            var flag = -1; // determines which among f_x1 and f_x2 to recompute                                        // 108\n            var dx = Number.MAX_VALUE;                                                                                 // 109\n            var df = Number.MAX_VALUE;                                                                                 // 110\n            while ((dx > min_width) || df > packingOptions.FLOAT_EPSILON) {                                            // 111\n                if (flag != 1) {                                                                                       // 112\n                    var x1 = right - (right - left) / packingOptions.GOLDEN_SECTION;                                   // 113\n                    var f_x1 = step(data, x1);                                                                         // 114\n                }                                                                                                      // 115\n                if (flag != 0) {                                                                                       // 116\n                    var x2 = left + (right - left) / packingOptions.GOLDEN_SECTION;                                    // 117\n                    var f_x2 = step(data, x2);                                                                         // 118\n                }                                                                                                      // 119\n                dx = Math.abs(x1 - x2);                                                                                // 120\n                df = Math.abs(f_x1 - f_x2);                                                                            // 121\n                if (f_x1 < curr_best_f) {                                                                              // 122\n                    curr_best_f = f_x1;                                                                                // 123\n                    curr_best = x1;                                                                                    // 124\n                }                                                                                                      // 125\n                if (f_x2 < curr_best_f) {                                                                              // 126\n                    curr_best_f = f_x2;                                                                                // 127\n                    curr_best = x2;                                                                                    // 128\n                }                                                                                                      // 129\n                if (f_x1 > f_x2) {                                                                                     // 130\n                    left = x1;                                                                                         // 131\n                    x1 = x2;                                                                                           // 132\n                    f_x1 = f_x2;                                                                                       // 133\n                    flag = 1;                                                                                          // 134\n                }                                                                                                      // 135\n                else {                                                                                                 // 136\n                    right = x2;                                                                                        // 137\n                    x2 = x1;                                                                                           // 138\n                    f_x2 = f_x1;                                                                                       // 139\n                    flag = 0;                                                                                          // 140\n                }                                                                                                      // 141\n                if (iterationCounter++ > 100) {                                                                        // 142\n                    break;                                                                                             // 143\n                }                                                                                                      // 144\n            }                                                                                                          // 145\n            // plot(data, min_width, get_entire_width(data), curr_best, curr_best_f);                                  // 146\n            step(data, curr_best);                                                                                     // 147\n        }                                                                                                              // 148\n        // one iteration of the optimization method                                                                    // 149\n        // (gives a proper, but not necessarily optimal packing)                                                       // 150\n        function step(data, max_width) {                                                                               // 151\n            line = [];                                                                                                 // 152\n            real_width = 0;                                                                                            // 153\n            real_height = 0;                                                                                           // 154\n            global_bottom = init_y;                                                                                    // 155\n            for (var i = 0; i < data.length; i++) {                                                                    // 156\n                var o = data[i];                                                                                       // 157\n                put_rect(o, max_width);                                                                                // 158\n            }                                                                                                          // 159\n            return Math.abs(get_real_ratio() - desired_ratio);                                                         // 160\n        }                                                                                                              // 161\n        // looking for a position to one box                                                                           // 162\n        function put_rect(rect, max_width) {                                                                           // 163\n            var parent = undefined;                                                                                    // 164\n            for (var i = 0; i < line.length; i++) {                                                                    // 165\n                if ((line[i].space_left >= rect.height) && (line[i].x + line[i].width + rect.width + packingOptions.PADDING - max_width) <= packingOptions.FLOAT_EPSILON) {\n                    parent = line[i];                                                                                  // 167\n                    break;                                                                                             // 168\n                }                                                                                                      // 169\n            }                                                                                                          // 170\n            line.push(rect);                                                                                           // 171\n            if (parent !== undefined) {                                                                                // 172\n                rect.x = parent.x + parent.width + packingOptions.PADDING;                                             // 173\n                rect.y = parent.bottom;                                                                                // 174\n                rect.space_left = rect.height;                                                                         // 175\n                rect.bottom = rect.y;                                                                                  // 176\n                parent.space_left -= rect.height + packingOptions.PADDING;                                             // 177\n                parent.bottom += rect.height + packingOptions.PADDING;                                                 // 178\n            }                                                                                                          // 179\n            else {                                                                                                     // 180\n                rect.y = global_bottom;                                                                                // 181\n                global_bottom += rect.height + packingOptions.PADDING;                                                 // 182\n                rect.x = init_x;                                                                                       // 183\n                rect.bottom = rect.y;                                                                                  // 184\n                rect.space_left = rect.height;                                                                         // 185\n            }                                                                                                          // 186\n            if (rect.y + rect.height - real_height > -packingOptions.FLOAT_EPSILON)                                    // 187\n                real_height = rect.y + rect.height - init_y;                                                           // 188\n            if (rect.x + rect.width - real_width > -packingOptions.FLOAT_EPSILON)                                      // 189\n                real_width = rect.x + rect.width - init_x;                                                             // 190\n        }                                                                                                              // 191\n        ;                                                                                                              // 192\n        function get_entire_width(data) {                                                                              // 193\n            var width = 0;                                                                                             // 194\n            data.forEach(function (d) { return width += d.width + packingOptions.PADDING; });                          // 195\n            return width;                                                                                              // 196\n        }                                                                                                              // 197\n        function get_real_ratio() {                                                                                    // 198\n            return (real_width / real_height);                                                                         // 199\n        }                                                                                                              // 200\n    }                                                                                                                  // 201\n    cola.applyPacking = applyPacking;                                                                                  // 202\n    /**                                                                                                                // 203\n     * connected components of graph                                                                                   // 204\n     * returns an array of {}                                                                                          // 205\n     */                                                                                                                // 206\n    function separateGraphs(nodes, links) {                                                                            // 207\n        var marks = {};                                                                                                // 208\n        var ways = {};                                                                                                 // 209\n        var graphs = [];                                                                                               // 210\n        var clusters = 0;                                                                                              // 211\n        for (var i = 0; i < links.length; i++) {                                                                       // 212\n            var link = links[i];                                                                                       // 213\n            var n1 = link.source;                                                                                      // 214\n            var n2 = link.target;                                                                                      // 215\n            if (ways[n1.index])                                                                                        // 216\n                ways[n1.index].push(n2);                                                                               // 217\n            else                                                                                                       // 218\n                ways[n1.index] = [n2];                                                                                 // 219\n            if (ways[n2.index])                                                                                        // 220\n                ways[n2.index].push(n1);                                                                               // 221\n            else                                                                                                       // 222\n                ways[n2.index] = [n1];                                                                                 // 223\n        }                                                                                                              // 224\n        for (var i = 0; i < nodes.length; i++) {                                                                       // 225\n            var node = nodes[i];                                                                                       // 226\n            if (marks[node.index])                                                                                     // 227\n                continue;                                                                                              // 228\n            explore_node(node, true);                                                                                  // 229\n        }                                                                                                              // 230\n        function explore_node(n, is_new) {                                                                             // 231\n            if (marks[n.index] !== undefined)                                                                          // 232\n                return;                                                                                                // 233\n            if (is_new) {                                                                                              // 234\n                clusters++;                                                                                            // 235\n                graphs.push({ array: [] });                                                                            // 236\n            }                                                                                                          // 237\n            marks[n.index] = clusters;                                                                                 // 238\n            graphs[clusters - 1].array.push(n);                                                                        // 239\n            var adjacent = ways[n.index];                                                                              // 240\n            if (!adjacent)                                                                                             // 241\n                return;                                                                                                // 242\n            for (var j = 0; j < adjacent.length; j++) {                                                                // 243\n                explore_node(adjacent[j], false);                                                                      // 244\n            }                                                                                                          // 245\n        }                                                                                                              // 246\n        return graphs;                                                                                                 // 247\n    }                                                                                                                  // 248\n    cola.separateGraphs = separateGraphs;                                                                              // 249\n})(cola || (cola = {}));                                                                                               // 250\nvar cola;                                                                                                              // 251\n(function (cola) {                                                                                                     // 252\n    var vpsc;                                                                                                          // 253\n    (function (vpsc) {                                                                                                 // 254\n        var PositionStats = (function () {                                                                             // 255\n            function PositionStats(scale) {                                                                            // 256\n                this.scale = scale;                                                                                    // 257\n                this.AB = 0;                                                                                           // 258\n                this.AD = 0;                                                                                           // 259\n                this.A2 = 0;                                                                                           // 260\n            }                                                                                                          // 261\n            PositionStats.prototype.addVariable = function (v) {                                                       // 262\n                var ai = this.scale / v.scale;                                                                         // 263\n                var bi = v.offset / v.scale;                                                                           // 264\n                var wi = v.weight;                                                                                     // 265\n                this.AB += wi * ai * bi;                                                                               // 266\n                this.AD += wi * ai * v.desiredPosition;                                                                // 267\n                this.A2 += wi * ai * ai;                                                                               // 268\n            };                                                                                                         // 269\n            PositionStats.prototype.getPosn = function () {                                                            // 270\n                return (this.AD - this.AB) / this.A2;                                                                  // 271\n            };                                                                                                         // 272\n            return PositionStats;                                                                                      // 273\n        })();                                                                                                          // 274\n        vpsc.PositionStats = PositionStats;                                                                            // 275\n        var Constraint = (function () {                                                                                // 276\n            function Constraint(left, right, gap, equality) {                                                          // 277\n                if (equality === void 0) { equality = false; }                                                         // 278\n                this.left = left;                                                                                      // 279\n                this.right = right;                                                                                    // 280\n                this.gap = gap;                                                                                        // 281\n                this.equality = equality;                                                                              // 282\n                this.active = false;                                                                                   // 283\n                this.unsatisfiable = false;                                                                            // 284\n                this.left = left;                                                                                      // 285\n                this.right = right;                                                                                    // 286\n                this.gap = gap;                                                                                        // 287\n                this.equality = equality;                                                                              // 288\n            }                                                                                                          // 289\n            Constraint.prototype.slack = function () {                                                                 // 290\n                return this.unsatisfiable ? Number.MAX_VALUE                                                           // 291\n                    : this.right.scale * this.right.position() - this.gap                                              // 292\n                        - this.left.scale * this.left.position();                                                      // 293\n            };                                                                                                         // 294\n            return Constraint;                                                                                         // 295\n        })();                                                                                                          // 296\n        vpsc.Constraint = Constraint;                                                                                  // 297\n        var Variable = (function () {                                                                                  // 298\n            function Variable(desiredPosition, weight, scale) {                                                        // 299\n                if (weight === void 0) { weight = 1; }                                                                 // 300\n                if (scale === void 0) { scale = 1; }                                                                   // 301\n                this.desiredPosition = desiredPosition;                                                                // 302\n                this.weight = weight;                                                                                  // 303\n                this.scale = scale;                                                                                    // 304\n                this.offset = 0;                                                                                       // 305\n            }                                                                                                          // 306\n            Variable.prototype.dfdv = function () {                                                                    // 307\n                return 2.0 * this.weight * (this.position() - this.desiredPosition);                                   // 308\n            };                                                                                                         // 309\n            Variable.prototype.position = function () {                                                                // 310\n                return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;                             // 311\n            };                                                                                                         // 312\n            // visit neighbours by active constraints within the same block                                            // 313\n            Variable.prototype.visitNeighbours = function (prev, f) {                                                  // 314\n                var ff = function (c, next) { return c.active && prev !== next && f(c, next); };                       // 315\n                this.cOut.forEach(function (c) { return ff(c, c.right); });                                            // 316\n                this.cIn.forEach(function (c) { return ff(c, c.left); });                                              // 317\n            };                                                                                                         // 318\n            return Variable;                                                                                           // 319\n        })();                                                                                                          // 320\n        vpsc.Variable = Variable;                                                                                      // 321\n        var Block = (function () {                                                                                     // 322\n            function Block(v) {                                                                                        // 323\n                this.vars = [];                                                                                        // 324\n                v.offset = 0;                                                                                          // 325\n                this.ps = new PositionStats(v.scale);                                                                  // 326\n                this.addVariable(v);                                                                                   // 327\n            }                                                                                                          // 328\n            Block.prototype.addVariable = function (v) {                                                               // 329\n                v.block = this;                                                                                        // 330\n                this.vars.push(v);                                                                                     // 331\n                this.ps.addVariable(v);                                                                                // 332\n                this.posn = this.ps.getPosn();                                                                         // 333\n            };                                                                                                         // 334\n            // move the block where it needs to be to minimize cost                                                    // 335\n            Block.prototype.updateWeightedPosition = function () {                                                     // 336\n                this.ps.AB = this.ps.AD = this.ps.A2 = 0;                                                              // 337\n                for (var i = 0, n = this.vars.length; i < n; ++i)                                                      // 338\n                    this.ps.addVariable(this.vars[i]);                                                                 // 339\n                this.posn = this.ps.getPosn();                                                                         // 340\n            };                                                                                                         // 341\n            Block.prototype.compute_lm = function (v, u, postAction) {                                                 // 342\n                var _this = this;                                                                                      // 343\n                var dfdv = v.dfdv();                                                                                   // 344\n                v.visitNeighbours(u, function (c, next) {                                                              // 345\n                    var _dfdv = _this.compute_lm(next, v, postAction);                                                 // 346\n                    if (next === c.right) {                                                                            // 347\n                        dfdv += _dfdv * c.left.scale;                                                                  // 348\n                        c.lm = _dfdv;                                                                                  // 349\n                    }                                                                                                  // 350\n                    else {                                                                                             // 351\n                        dfdv += _dfdv * c.right.scale;                                                                 // 352\n                        c.lm = -_dfdv;                                                                                 // 353\n                    }                                                                                                  // 354\n                    postAction(c);                                                                                     // 355\n                });                                                                                                    // 356\n                return dfdv / v.scale;                                                                                 // 357\n            };                                                                                                         // 358\n            Block.prototype.populateSplitBlock = function (v, prev) {                                                  // 359\n                var _this = this;                                                                                      // 360\n                v.visitNeighbours(prev, function (c, next) {                                                           // 361\n                    next.offset = v.offset + (next === c.right ? c.gap : -c.gap);                                      // 362\n                    _this.addVariable(next);                                                                           // 363\n                    _this.populateSplitBlock(next, v);                                                                 // 364\n                });                                                                                                    // 365\n            };                                                                                                         // 366\n            // traverse the active constraint tree applying visit to each active constraint                            // 367\n            Block.prototype.traverse = function (visit, acc, v, prev) {                                                // 368\n                var _this = this;                                                                                      // 369\n                if (v === void 0) { v = this.vars[0]; }                                                                // 370\n                if (prev === void 0) { prev = null; }                                                                  // 371\n                v.visitNeighbours(prev, function (c, next) {                                                           // 372\n                    acc.push(visit(c));                                                                                // 373\n                    _this.traverse(visit, acc, next, v);                                                               // 374\n                });                                                                                                    // 375\n            };                                                                                                         // 376\n            // calculate lagrangian multipliers on constraints and                                                     // 377\n            // find the active constraint in this block with the smallest lagrangian.                                  // 378\n            // if the lagrangian is negative, then the constraint is a split candidate.                                // 379\n            Block.prototype.findMinLM = function () {                                                                  // 380\n                var m = null;                                                                                          // 381\n                this.compute_lm(this.vars[0], null, function (c) {                                                     // 382\n                    if (!c.equality && (m === null || c.lm < m.lm))                                                    // 383\n                        m = c;                                                                                         // 384\n                });                                                                                                    // 385\n                return m;                                                                                              // 386\n            };                                                                                                         // 387\n            Block.prototype.findMinLMBetween = function (lv, rv) {                                                     // 388\n                this.compute_lm(lv, null, function () { });                                                            // 389\n                var m = null;                                                                                          // 390\n                this.findPath(lv, null, rv, function (c, next) {                                                       // 391\n                    if (!c.equality && c.right === next && (m === null || c.lm < m.lm))                                // 392\n                        m = c;                                                                                         // 393\n                });                                                                                                    // 394\n                return m;                                                                                              // 395\n            };                                                                                                         // 396\n            Block.prototype.findPath = function (v, prev, to, visit) {                                                 // 397\n                var _this = this;                                                                                      // 398\n                var endFound = false;                                                                                  // 399\n                v.visitNeighbours(prev, function (c, next) {                                                           // 400\n                    if (!endFound && (next === to || _this.findPath(next, v, to, visit))) {                            // 401\n                        endFound = true;                                                                               // 402\n                        visit(c, next);                                                                                // 403\n                    }                                                                                                  // 404\n                });                                                                                                    // 405\n                return endFound;                                                                                       // 406\n            };                                                                                                         // 407\n            // Search active constraint tree from u to see if there is a directed path to v.                           // 408\n            // Returns true if path is found.                                                                          // 409\n            Block.prototype.isActiveDirectedPathBetween = function (u, v) {                                            // 410\n                if (u === v)                                                                                           // 411\n                    return true;                                                                                       // 412\n                var i = u.cOut.length;                                                                                 // 413\n                while (i--) {                                                                                          // 414\n                    var c = u.cOut[i];                                                                                 // 415\n                    if (c.active && this.isActiveDirectedPathBetween(c.right, v))                                      // 416\n                        return true;                                                                                   // 417\n                }                                                                                                      // 418\n                return false;                                                                                          // 419\n            };                                                                                                         // 420\n            // split the block into two by deactivating the specified constraint                                       // 421\n            Block.split = function (c) {                                                                               // 422\n                /* DEBUG                                                                                               // 423\n                            console.log(\"split on \" + c);                                                              // 424\n                            console.assert(c.active, \"attempt to split on inactive constraint\");                       // 425\n                DEBUG */                                                                                               // 426\n                c.active = false;                                                                                      // 427\n                return [Block.createSplitBlock(c.left), Block.createSplitBlock(c.right)];                              // 428\n            };                                                                                                         // 429\n            Block.createSplitBlock = function (startVar) {                                                             // 430\n                var b = new Block(startVar);                                                                           // 431\n                b.populateSplitBlock(startVar, null);                                                                  // 432\n                return b;                                                                                              // 433\n            };                                                                                                         // 434\n            // find a split point somewhere between the specified variables                                            // 435\n            Block.prototype.splitBetween = function (vl, vr) {                                                         // 436\n                /* DEBUG                                                                                               // 437\n                            console.assert(vl.block === this);                                                         // 438\n                            console.assert(vr.block === this);                                                         // 439\n                DEBUG */                                                                                               // 440\n                var c = this.findMinLMBetween(vl, vr);                                                                 // 441\n                if (c !== null) {                                                                                      // 442\n                    var bs = Block.split(c);                                                                           // 443\n                    return { constraint: c, lb: bs[0], rb: bs[1] };                                                    // 444\n                }                                                                                                      // 445\n                // couldn't find a split point - for example the active path is all equality constraints               // 446\n                return null;                                                                                           // 447\n            };                                                                                                         // 448\n            Block.prototype.mergeAcross = function (b, c, dist) {                                                      // 449\n                c.active = true;                                                                                       // 450\n                for (var i = 0, n = b.vars.length; i < n; ++i) {                                                       // 451\n                    var v = b.vars[i];                                                                                 // 452\n                    v.offset += dist;                                                                                  // 453\n                    this.addVariable(v);                                                                               // 454\n                }                                                                                                      // 455\n                this.posn = this.ps.getPosn();                                                                         // 456\n            };                                                                                                         // 457\n            Block.prototype.cost = function () {                                                                       // 458\n                var sum = 0, i = this.vars.length;                                                                     // 459\n                while (i--) {                                                                                          // 460\n                    var v = this.vars[i], d = v.position() - v.desiredPosition;                                        // 461\n                    sum += d * d * v.weight;                                                                           // 462\n                }                                                                                                      // 463\n                return sum;                                                                                            // 464\n            };                                                                                                         // 465\n            return Block;                                                                                              // 466\n        })();                                                                                                          // 467\n        vpsc.Block = Block;                                                                                            // 468\n        var Blocks = (function () {                                                                                    // 469\n            function Blocks(vs) {                                                                                      // 470\n                this.vs = vs;                                                                                          // 471\n                var n = vs.length;                                                                                     // 472\n                this.list = new Array(n);                                                                              // 473\n                while (n--) {                                                                                          // 474\n                    var b = new Block(vs[n]);                                                                          // 475\n                    this.list[n] = b;                                                                                  // 476\n                    b.blockInd = n;                                                                                    // 477\n                }                                                                                                      // 478\n            }                                                                                                          // 479\n            Blocks.prototype.cost = function () {                                                                      // 480\n                var sum = 0, i = this.list.length;                                                                     // 481\n                while (i--)                                                                                            // 482\n                    sum += this.list[i].cost();                                                                        // 483\n                return sum;                                                                                            // 484\n            };                                                                                                         // 485\n            Blocks.prototype.insert = function (b) {                                                                   // 486\n                /* DEBUG                                                                                               // 487\n                            console.assert(!this.contains(b), \"blocks error: tried to reinsert block \" + b.blockInd)   // 488\n                DEBUG */                                                                                               // 489\n                b.blockInd = this.list.length;                                                                         // 490\n                this.list.push(b);                                                                                     // 491\n                /* DEBUG                                                                                               // 492\n                            console.log(\"insert block: \" + b.blockInd);                                                // 493\n                            this.contains(b);                                                                          // 494\n                DEBUG */                                                                                               // 495\n            };                                                                                                         // 496\n            Blocks.prototype.remove = function (b) {                                                                   // 497\n                /* DEBUG                                                                                               // 498\n                            console.log(\"remove block: \" + b.blockInd);                                                // 499\n                            console.assert(this.contains(b));                                                          // 500\n                DEBUG */                                                                                               // 501\n                var last = this.list.length - 1;                                                                       // 502\n                var swapBlock = this.list[last];                                                                       // 503\n                this.list.length = last;                                                                               // 504\n                if (b !== swapBlock) {                                                                                 // 505\n                    this.list[b.blockInd] = swapBlock;                                                                 // 506\n                    swapBlock.blockInd = b.blockInd;                                                                   // 507\n                }                                                                                                      // 508\n            };                                                                                                         // 509\n            // merge the blocks on either side of the specified constraint, by copying the smaller block into the larger\n            // and deleting the smaller.                                                                               // 511\n            Blocks.prototype.merge = function (c) {                                                                    // 512\n                var l = c.left.block, r = c.right.block;                                                               // 513\n                /* DEBUG                                                                                               // 514\n                            console.assert(l!==r, \"attempt to merge within the same block\");                           // 515\n                DEBUG */                                                                                               // 516\n                var dist = c.right.offset - c.left.offset - c.gap;                                                     // 517\n                if (l.vars.length < r.vars.length) {                                                                   // 518\n                    r.mergeAcross(l, c, dist);                                                                         // 519\n                    this.remove(l);                                                                                    // 520\n                }                                                                                                      // 521\n                else {                                                                                                 // 522\n                    l.mergeAcross(r, c, -dist);                                                                        // 523\n                    this.remove(r);                                                                                    // 524\n                }                                                                                                      // 525\n                /* DEBUG                                                                                               // 526\n                            console.assert(Math.abs(c.slack()) < 1e-6, \"Error: Constraint should be at equality after merge!\");\n                            console.log(\"merged on \" + c);                                                             // 528\n                DEBUG */                                                                                               // 529\n            };                                                                                                         // 530\n            Blocks.prototype.forEach = function (f) {                                                                  // 531\n                this.list.forEach(f);                                                                                  // 532\n            };                                                                                                         // 533\n            // useful, for example, after variable desired positions change.                                           // 534\n            Blocks.prototype.updateBlockPositions = function () {                                                      // 535\n                this.list.forEach(function (b) { return b.updateWeightedPosition(); });                                // 536\n            };                                                                                                         // 537\n            // split each block across its constraint with the minimum lagrangian                                      // 538\n            Blocks.prototype.split = function (inactive) {                                                             // 539\n                var _this = this;                                                                                      // 540\n                this.updateBlockPositions();                                                                           // 541\n                this.list.forEach(function (b) {                                                                       // 542\n                    var v = b.findMinLM();                                                                             // 543\n                    if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {                                            // 544\n                        b = v.left.block;                                                                              // 545\n                        Block.split(v).forEach(function (nb) { return _this.insert(nb); });                            // 546\n                        _this.remove(b);                                                                               // 547\n                        inactive.push(v);                                                                              // 548\n                    }                                                                                                  // 549\n                });                                                                                                    // 550\n            };                                                                                                         // 551\n            return Blocks;                                                                                             // 552\n        })();                                                                                                          // 553\n        vpsc.Blocks = Blocks;                                                                                          // 554\n        var Solver = (function () {                                                                                    // 555\n            function Solver(vs, cs) {                                                                                  // 556\n                this.vs = vs;                                                                                          // 557\n                this.cs = cs;                                                                                          // 558\n                this.vs = vs;                                                                                          // 559\n                vs.forEach(function (v) {                                                                              // 560\n                    v.cIn = [], v.cOut = [];                                                                           // 561\n                    /* DEBUG                                                                                           // 562\n                                    v.toString = () => \"v\" + vs.indexOf(v);                                            // 563\n                    DEBUG */                                                                                           // 564\n                });                                                                                                    // 565\n                this.cs = cs;                                                                                          // 566\n                cs.forEach(function (c) {                                                                              // 567\n                    c.left.cOut.push(c);                                                                               // 568\n                    c.right.cIn.push(c);                                                                               // 569\n                    /* DEBUG                                                                                           // 570\n                                    c.toString = () => c.left + \"+\" + c.gap + \"<=\" + c.right + \" slack=\" + c.slack() + \" active=\" + c.active;\n                    DEBUG */                                                                                           // 572\n                });                                                                                                    // 573\n                this.inactive = cs.map(function (c) { c.active = false; return c; });                                  // 574\n                this.bs = null;                                                                                        // 575\n            }                                                                                                          // 576\n            Solver.prototype.cost = function () {                                                                      // 577\n                return this.bs.cost();                                                                                 // 578\n            };                                                                                                         // 579\n            // set starting positions without changing desired positions.                                              // 580\n            // Note: it throws away any previous block structure.                                                      // 581\n            Solver.prototype.setStartingPositions = function (ps) {                                                    // 582\n                this.inactive = this.cs.map(function (c) { c.active = false; return c; });                             // 583\n                this.bs = new Blocks(this.vs);                                                                         // 584\n                this.bs.forEach(function (b, i) { return b.posn = ps[i]; });                                           // 585\n            };                                                                                                         // 586\n            Solver.prototype.setDesiredPositions = function (ps) {                                                     // 587\n                this.vs.forEach(function (v, i) { return v.desiredPosition = ps[i]; });                                // 588\n            };                                                                                                         // 589\n            /* DEBUG                                                                                                   // 590\n                    private getId(v: Variable): number {                                                               // 591\n                        return this.vs.indexOf(v);                                                                     // 592\n                    }                                                                                                  // 593\n                                                                                                                       // 594\n                    // sanity check of the index integrity of the inactive list                                        // 595\n                    checkInactive(): void {                                                                            // 596\n                        var inactiveCount = 0;                                                                         // 597\n                        this.cs.forEach(c=> {                                                                          // 598\n                            var i = this.inactive.indexOf(c);                                                          // 599\n                            console.assert(!c.active && i >= 0 || c.active && i < 0, \"constraint should be in the inactive list if it is not active: \" + c);\n                            if (i >= 0) {                                                                              // 601\n                                inactiveCount++;                                                                       // 602\n                            } else {                                                                                   // 603\n                                console.assert(c.active, \"inactive constraint not found in inactive list: \" + c);      // 604\n                            }                                                                                          // 605\n                        });                                                                                            // 606\n                        console.assert(inactiveCount === this.inactive.length, inactiveCount + \" inactive constraints found, \" + this.inactive.length + \"in inactive list\");\n                    }                                                                                                  // 608\n                    // after every call to satisfy the following should check should pass                              // 609\n                    checkSatisfied(): void {                                                                           // 610\n                        this.cs.forEach(c=>console.assert(c.slack() >= vpsc.Solver.ZERO_UPPERBOUND, \"Error: Unsatisfied constraint! \"+c));\n                    }                                                                                                  // 612\n            DEBUG */                                                                                                   // 613\n            Solver.prototype.mostViolated = function () {                                                              // 614\n                var minSlack = Number.MAX_VALUE, v = null, l = this.inactive, n = l.length, deletePoint = n;           // 615\n                for (var i = 0; i < n; ++i) {                                                                          // 616\n                    var c = l[i];                                                                                      // 617\n                    if (c.unsatisfiable)                                                                               // 618\n                        continue;                                                                                      // 619\n                    var slack = c.slack();                                                                             // 620\n                    if (c.equality || slack < minSlack) {                                                              // 621\n                        minSlack = slack;                                                                              // 622\n                        v = c;                                                                                         // 623\n                        deletePoint = i;                                                                               // 624\n                        if (c.equality)                                                                                // 625\n                            break;                                                                                     // 626\n                    }                                                                                                  // 627\n                }                                                                                                      // 628\n                if (deletePoint !== n &&                                                                               // 629\n                    (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality)) {                                  // 630\n                    l[deletePoint] = l[n - 1];                                                                         // 631\n                    l.length = n - 1;                                                                                  // 632\n                }                                                                                                      // 633\n                return v;                                                                                              // 634\n            };                                                                                                         // 635\n            // satisfy constraints by building block structure over violated constraints                               // 636\n            // and moving the blocks to their desired positions                                                        // 637\n            Solver.prototype.satisfy = function () {                                                                   // 638\n                if (this.bs == null) {                                                                                 // 639\n                    this.bs = new Blocks(this.vs);                                                                     // 640\n                }                                                                                                      // 641\n                /* DEBUG                                                                                               // 642\n                            console.log(\"satisfy: \" + this.bs);                                                        // 643\n                DEBUG */                                                                                               // 644\n                this.bs.split(this.inactive);                                                                          // 645\n                var v = null;                                                                                          // 646\n                while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {\n                    var lb = v.left.block, rb = v.right.block;                                                         // 648\n                    /* DEBUG                                                                                           // 649\n                                    console.log(\"most violated is: \" + v);                                             // 650\n                                    this.bs.contains(lb);                                                              // 651\n                                    this.bs.contains(rb);                                                              // 652\n                    DEBUG */                                                                                           // 653\n                    if (lb !== rb) {                                                                                   // 654\n                        this.bs.merge(v);                                                                              // 655\n                    }                                                                                                  // 656\n                    else {                                                                                             // 657\n                        if (lb.isActiveDirectedPathBetween(v.right, v.left)) {                                         // 658\n                            // cycle found!                                                                            // 659\n                            v.unsatisfiable = true;                                                                    // 660\n                            continue;                                                                                  // 661\n                        }                                                                                              // 662\n                        // constraint is within block, need to split first                                             // 663\n                        var split = lb.splitBetween(v.left, v.right);                                                  // 664\n                        if (split !== null) {                                                                          // 665\n                            this.bs.insert(split.lb);                                                                  // 666\n                            this.bs.insert(split.rb);                                                                  // 667\n                            this.bs.remove(lb);                                                                        // 668\n                            this.inactive.push(split.constraint);                                                      // 669\n                        }                                                                                              // 670\n                        else {                                                                                         // 671\n                            /* DEBUG                                                                                   // 672\n                                                    console.log(\"unsatisfiable constraint found\");                     // 673\n                            DEBUG */                                                                                   // 674\n                            v.unsatisfiable = true;                                                                    // 675\n                            continue;                                                                                  // 676\n                        }                                                                                              // 677\n                        if (v.slack() >= 0) {                                                                          // 678\n                            /* DEBUG                                                                                   // 679\n                                                    console.log(\"violated constraint indirectly satisfied: \" + v);     // 680\n                            DEBUG */                                                                                   // 681\n                            // v was satisfied by the above split!                                                     // 682\n                            this.inactive.push(v);                                                                     // 683\n                        }                                                                                              // 684\n                        else {                                                                                         // 685\n                            /* DEBUG                                                                                   // 686\n                                                    console.log(\"merge after split:\");                                 // 687\n                            DEBUG */                                                                                   // 688\n                            this.bs.merge(v);                                                                          // 689\n                        }                                                                                              // 690\n                    }                                                                                                  // 691\n                }                                                                                                      // 692\n                /* DEBUG                                                                                               // 693\n                            this.checkSatisfied();                                                                     // 694\n                DEBUG */                                                                                               // 695\n            };                                                                                                         // 696\n            // repeatedly build and split block structure until we converge to an optimal solution                     // 697\n            Solver.prototype.solve = function () {                                                                     // 698\n                this.satisfy();                                                                                        // 699\n                var lastcost = Number.MAX_VALUE, cost = this.bs.cost();                                                // 700\n                while (Math.abs(lastcost - cost) > 0.0001) {                                                           // 701\n                    this.satisfy();                                                                                    // 702\n                    lastcost = cost;                                                                                   // 703\n                    cost = this.bs.cost();                                                                             // 704\n                }                                                                                                      // 705\n                return cost;                                                                                           // 706\n            };                                                                                                         // 707\n            Solver.LAGRANGIAN_TOLERANCE = -1e-4;                                                                       // 708\n            Solver.ZERO_UPPERBOUND = -1e-10;                                                                           // 709\n            return Solver;                                                                                             // 710\n        })();                                                                                                          // 711\n        vpsc.Solver = Solver;                                                                                          // 712\n    })(vpsc = cola.vpsc || (cola.vpsc = {}));                                                                          // 713\n})(cola || (cola = {}));                                                                                               // 714\nvar __extends = (this && this.__extends) || function (d, b) {                                                          // 715\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];                                                             // 716\n    function __() { this.constructor = d; }                                                                            // 717\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());                              // 718\n};                                                                                                                     // 719\nvar cola;                                                                                                              // 720\n(function (cola) {                                                                                                     // 721\n    var vpsc;                                                                                                          // 722\n    (function (vpsc) {                                                                                                 // 723\n        //Based on js_es:                                                                                              // 724\n        //                                                                                                             // 725\n        //https://github.com/vadimg/js_bintrees                                                                        // 726\n        //                                                                                                             // 727\n        //Copyright (C) 2011 by Vadim Graboys                                                                          // 728\n        //                                                                                                             // 729\n        //Permission is hereby granted, free of charge, to any person obtaining a copy                                 // 730\n        //of this software and associated documentation files (the \"Software\"), to deal                                // 731\n        //in the Software without restriction, including without limitation the rights                                 // 732\n        //to use, copy, modify, merge, publish, distribute, sublicense, and/or sell                                    // 733\n        //copies of the Software, and to permit persons to whom the Software is                                        // 734\n        //furnished to do so, subject to the following conditions:                                                     // 735\n        //                                                                                                             // 736\n        //The above copyright notice and this permission notice shall be included in                                   // 737\n        //all copies or substantial portions of the Software.                                                          // 738\n        //                                                                                                             // 739\n        //THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                                   // 740\n        //IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                                     // 741\n        //FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                                  // 742\n        //AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                                       // 743\n        //LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                                // 744\n        //OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN                                    // 745\n        //THE SOFTWARE.                                                                                                // 746\n        var TreeBase = (function () {                                                                                  // 747\n            function TreeBase() {                                                                                      // 748\n                // returns iterator to node if found, null otherwise                                                   // 749\n                this.findIter = function (data) {                                                                      // 750\n                    var res = this._root;                                                                              // 751\n                    var iter = this.iterator();                                                                        // 752\n                    while (res !== null) {                                                                             // 753\n                        var c = this._comparator(data, res.data);                                                      // 754\n                        if (c === 0) {                                                                                 // 755\n                            iter._cursor = res;                                                                        // 756\n                            return iter;                                                                               // 757\n                        }                                                                                              // 758\n                        else {                                                                                         // 759\n                            iter._ancestors.push(res);                                                                 // 760\n                            res = res.get_child(c > 0);                                                                // 761\n                        }                                                                                              // 762\n                    }                                                                                                  // 763\n                    return null;                                                                                       // 764\n                };                                                                                                     // 765\n            }                                                                                                          // 766\n            // removes all nodes from the tree                                                                         // 767\n            TreeBase.prototype.clear = function () {                                                                   // 768\n                this._root = null;                                                                                     // 769\n                this.size = 0;                                                                                         // 770\n            };                                                                                                         // 771\n            ;                                                                                                          // 772\n            // returns node data if found, null otherwise                                                              // 773\n            TreeBase.prototype.find = function (data) {                                                                // 774\n                var res = this._root;                                                                                  // 775\n                while (res !== null) {                                                                                 // 776\n                    var c = this._comparator(data, res.data);                                                          // 777\n                    if (c === 0) {                                                                                     // 778\n                        return res.data;                                                                               // 779\n                    }                                                                                                  // 780\n                    else {                                                                                             // 781\n                        res = res.get_child(c > 0);                                                                    // 782\n                    }                                                                                                  // 783\n                }                                                                                                      // 784\n                return null;                                                                                           // 785\n            };                                                                                                         // 786\n            ;                                                                                                          // 787\n            // Returns an interator to the tree node immediately before (or at) the element                            // 788\n            TreeBase.prototype.lowerBound = function (data) {                                                          // 789\n                return this._bound(data, this._comparator);                                                            // 790\n            };                                                                                                         // 791\n            ;                                                                                                          // 792\n            // Returns an interator to the tree node immediately after (or at) the element                             // 793\n            TreeBase.prototype.upperBound = function (data) {                                                          // 794\n                var cmp = this._comparator;                                                                            // 795\n                function reverse_cmp(a, b) {                                                                           // 796\n                    return cmp(b, a);                                                                                  // 797\n                }                                                                                                      // 798\n                return this._bound(data, reverse_cmp);                                                                 // 799\n            };                                                                                                         // 800\n            ;                                                                                                          // 801\n            // returns null if tree is empty                                                                           // 802\n            TreeBase.prototype.min = function () {                                                                     // 803\n                var res = this._root;                                                                                  // 804\n                if (res === null) {                                                                                    // 805\n                    return null;                                                                                       // 806\n                }                                                                                                      // 807\n                while (res.left !== null) {                                                                            // 808\n                    res = res.left;                                                                                    // 809\n                }                                                                                                      // 810\n                return res.data;                                                                                       // 811\n            };                                                                                                         // 812\n            ;                                                                                                          // 813\n            // returns null if tree is empty                                                                           // 814\n            TreeBase.prototype.max = function () {                                                                     // 815\n                var res = this._root;                                                                                  // 816\n                if (res === null) {                                                                                    // 817\n                    return null;                                                                                       // 818\n                }                                                                                                      // 819\n                while (res.right !== null) {                                                                           // 820\n                    res = res.right;                                                                                   // 821\n                }                                                                                                      // 822\n                return res.data;                                                                                       // 823\n            };                                                                                                         // 824\n            ;                                                                                                          // 825\n            // returns a null iterator                                                                                 // 826\n            // call next() or prev() to point to an element                                                            // 827\n            TreeBase.prototype.iterator = function () {                                                                // 828\n                return new Iterator(this);                                                                             // 829\n            };                                                                                                         // 830\n            ;                                                                                                          // 831\n            // calls cb on each node's data, in order                                                                  // 832\n            TreeBase.prototype.each = function (cb) {                                                                  // 833\n                var it = this.iterator(), data;                                                                        // 834\n                while ((data = it.next()) !== null) {                                                                  // 835\n                    cb(data);                                                                                          // 836\n                }                                                                                                      // 837\n            };                                                                                                         // 838\n            ;                                                                                                          // 839\n            // calls cb on each node's data, in reverse order                                                          // 840\n            TreeBase.prototype.reach = function (cb) {                                                                 // 841\n                var it = this.iterator(), data;                                                                        // 842\n                while ((data = it.prev()) !== null) {                                                                  // 843\n                    cb(data);                                                                                          // 844\n                }                                                                                                      // 845\n            };                                                                                                         // 846\n            ;                                                                                                          // 847\n            // used for lowerBound and upperBound                                                                      // 848\n            TreeBase.prototype._bound = function (data, cmp) {                                                         // 849\n                var cur = this._root;                                                                                  // 850\n                var iter = this.iterator();                                                                            // 851\n                while (cur !== null) {                                                                                 // 852\n                    var c = this._comparator(data, cur.data);                                                          // 853\n                    if (c === 0) {                                                                                     // 854\n                        iter._cursor = cur;                                                                            // 855\n                        return iter;                                                                                   // 856\n                    }                                                                                                  // 857\n                    iter._ancestors.push(cur);                                                                         // 858\n                    cur = cur.get_child(c > 0);                                                                        // 859\n                }                                                                                                      // 860\n                for (var i = iter._ancestors.length - 1; i >= 0; --i) {                                                // 861\n                    cur = iter._ancestors[i];                                                                          // 862\n                    if (cmp(data, cur.data) > 0) {                                                                     // 863\n                        iter._cursor = cur;                                                                            // 864\n                        iter._ancestors.length = i;                                                                    // 865\n                        return iter;                                                                                   // 866\n                    }                                                                                                  // 867\n                }                                                                                                      // 868\n                iter._ancestors.length = 0;                                                                            // 869\n                return iter;                                                                                           // 870\n            };                                                                                                         // 871\n            ;                                                                                                          // 872\n            return TreeBase;                                                                                           // 873\n        })();                                                                                                          // 874\n        vpsc.TreeBase = TreeBase;                                                                                      // 875\n        var Iterator = (function () {                                                                                  // 876\n            function Iterator(tree) {                                                                                  // 877\n                this._tree = tree;                                                                                     // 878\n                this._ancestors = [];                                                                                  // 879\n                this._cursor = null;                                                                                   // 880\n            }                                                                                                          // 881\n            Iterator.prototype.data = function () {                                                                    // 882\n                return this._cursor !== null ? this._cursor.data : null;                                               // 883\n            };                                                                                                         // 884\n            ;                                                                                                          // 885\n            // if null-iterator, returns first node                                                                    // 886\n            // otherwise, returns next node                                                                            // 887\n            Iterator.prototype.next = function () {                                                                    // 888\n                if (this._cursor === null) {                                                                           // 889\n                    var root = this._tree._root;                                                                       // 890\n                    if (root !== null) {                                                                               // 891\n                        this._minNode(root);                                                                           // 892\n                    }                                                                                                  // 893\n                }                                                                                                      // 894\n                else {                                                                                                 // 895\n                    if (this._cursor.right === null) {                                                                 // 896\n                        // no greater node in subtree, go up to parent                                                 // 897\n                        // if coming from a right child, continue up the stack                                         // 898\n                        var save;                                                                                      // 899\n                        do {                                                                                           // 900\n                            save = this._cursor;                                                                       // 901\n                            if (this._ancestors.length) {                                                              // 902\n                                this._cursor = this._ancestors.pop();                                                  // 903\n                            }                                                                                          // 904\n                            else {                                                                                     // 905\n                                this._cursor = null;                                                                   // 906\n                                break;                                                                                 // 907\n                            }                                                                                          // 908\n                        } while (this._cursor.right === save);                                                         // 909\n                    }                                                                                                  // 910\n                    else {                                                                                             // 911\n                        // get the next node from the subtree                                                          // 912\n                        this._ancestors.push(this._cursor);                                                            // 913\n                        this._minNode(this._cursor.right);                                                             // 914\n                    }                                                                                                  // 915\n                }                                                                                                      // 916\n                return this._cursor !== null ? this._cursor.data : null;                                               // 917\n            };                                                                                                         // 918\n            ;                                                                                                          // 919\n            // if null-iterator, returns last node                                                                     // 920\n            // otherwise, returns previous node                                                                        // 921\n            Iterator.prototype.prev = function () {                                                                    // 922\n                if (this._cursor === null) {                                                                           // 923\n                    var root = this._tree._root;                                                                       // 924\n                    if (root !== null) {                                                                               // 925\n                        this._maxNode(root);                                                                           // 926\n                    }                                                                                                  // 927\n                }                                                                                                      // 928\n                else {                                                                                                 // 929\n                    if (this._cursor.left === null) {                                                                  // 930\n                        var save;                                                                                      // 931\n                        do {                                                                                           // 932\n                            save = this._cursor;                                                                       // 933\n                            if (this._ancestors.length) {                                                              // 934\n                                this._cursor = this._ancestors.pop();                                                  // 935\n                            }                                                                                          // 936\n                            else {                                                                                     // 937\n                                this._cursor = null;                                                                   // 938\n                                break;                                                                                 // 939\n                            }                                                                                          // 940\n                        } while (this._cursor.left === save);                                                          // 941\n                    }                                                                                                  // 942\n                    else {                                                                                             // 943\n                        this._ancestors.push(this._cursor);                                                            // 944\n                        this._maxNode(this._cursor.left);                                                              // 945\n                    }                                                                                                  // 946\n                }                                                                                                      // 947\n                return this._cursor !== null ? this._cursor.data : null;                                               // 948\n            };                                                                                                         // 949\n            ;                                                                                                          // 950\n            Iterator.prototype._minNode = function (start) {                                                           // 951\n                while (start.left !== null) {                                                                          // 952\n                    this._ancestors.push(start);                                                                       // 953\n                    start = start.left;                                                                                // 954\n                }                                                                                                      // 955\n                this._cursor = start;                                                                                  // 956\n            };                                                                                                         // 957\n            ;                                                                                                          // 958\n            Iterator.prototype._maxNode = function (start) {                                                           // 959\n                while (start.right !== null) {                                                                         // 960\n                    this._ancestors.push(start);                                                                       // 961\n                    start = start.right;                                                                               // 962\n                }                                                                                                      // 963\n                this._cursor = start;                                                                                  // 964\n            };                                                                                                         // 965\n            ;                                                                                                          // 966\n            return Iterator;                                                                                           // 967\n        })();                                                                                                          // 968\n        vpsc.Iterator = Iterator;                                                                                      // 969\n        var Node = (function () {                                                                                      // 970\n            function Node(data) {                                                                                      // 971\n                this.data = data;                                                                                      // 972\n                this.left = null;                                                                                      // 973\n                this.right = null;                                                                                     // 974\n                this.red = true;                                                                                       // 975\n            }                                                                                                          // 976\n            Node.prototype.get_child = function (dir) {                                                                // 977\n                return dir ? this.right : this.left;                                                                   // 978\n            };                                                                                                         // 979\n            ;                                                                                                          // 980\n            Node.prototype.set_child = function (dir, val) {                                                           // 981\n                if (dir) {                                                                                             // 982\n                    this.right = val;                                                                                  // 983\n                }                                                                                                      // 984\n                else {                                                                                                 // 985\n                    this.left = val;                                                                                   // 986\n                }                                                                                                      // 987\n            };                                                                                                         // 988\n            ;                                                                                                          // 989\n            return Node;                                                                                               // 990\n        })();                                                                                                          // 991\n        var RBTree = (function (_super) {                                                                              // 992\n            __extends(RBTree, _super);                                                                                 // 993\n            function RBTree(comparator) {                                                                              // 994\n                _super.call(this);                                                                                     // 995\n                this._root = null;                                                                                     // 996\n                this._comparator = comparator;                                                                         // 997\n                this.size = 0;                                                                                         // 998\n            }                                                                                                          // 999\n            // returns true if inserted, false if duplicate                                                            // 1000\n            RBTree.prototype.insert = function (data) {                                                                // 1001\n                var ret = false;                                                                                       // 1002\n                if (this._root === null) {                                                                             // 1003\n                    // empty tree                                                                                      // 1004\n                    this._root = new Node(data);                                                                       // 1005\n                    ret = true;                                                                                        // 1006\n                    this.size++;                                                                                       // 1007\n                }                                                                                                      // 1008\n                else {                                                                                                 // 1009\n                    var head = new Node(undefined); // fake tree root                                                  // 1010\n                    var dir = false;                                                                                   // 1011\n                    var last = false;                                                                                  // 1012\n                    // setup                                                                                           // 1013\n                    var gp = null; // grandparent                                                                      // 1014\n                    var ggp = head; // grand-grand-parent                                                              // 1015\n                    var p = null; // parent                                                                            // 1016\n                    var node = this._root;                                                                             // 1017\n                    ggp.right = this._root;                                                                            // 1018\n                    // search down                                                                                     // 1019\n                    while (true) {                                                                                     // 1020\n                        if (node === null) {                                                                           // 1021\n                            // insert new node at the bottom                                                           // 1022\n                            node = new Node(data);                                                                     // 1023\n                            p.set_child(dir, node);                                                                    // 1024\n                            ret = true;                                                                                // 1025\n                            this.size++;                                                                               // 1026\n                        }                                                                                              // 1027\n                        else if (RBTree.is_red(node.left) && RBTree.is_red(node.right)) {                              // 1028\n                            // color flip                                                                              // 1029\n                            node.red = true;                                                                           // 1030\n                            node.left.red = false;                                                                     // 1031\n                            node.right.red = false;                                                                    // 1032\n                        }                                                                                              // 1033\n                        // fix red violation                                                                           // 1034\n                        if (RBTree.is_red(node) && RBTree.is_red(p)) {                                                 // 1035\n                            var dir2 = ggp.right === gp;                                                               // 1036\n                            if (node === p.get_child(last)) {                                                          // 1037\n                                ggp.set_child(dir2, RBTree.single_rotate(gp, !last));                                  // 1038\n                            }                                                                                          // 1039\n                            else {                                                                                     // 1040\n                                ggp.set_child(dir2, RBTree.double_rotate(gp, !last));                                  // 1041\n                            }                                                                                          // 1042\n                        }                                                                                              // 1043\n                        var cmp = this._comparator(node.data, data);                                                   // 1044\n                        // stop if found                                                                               // 1045\n                        if (cmp === 0) {                                                                               // 1046\n                            break;                                                                                     // 1047\n                        }                                                                                              // 1048\n                        last = dir;                                                                                    // 1049\n                        dir = cmp < 0;                                                                                 // 1050\n                        // update helpers                                                                              // 1051\n                        if (gp !== null) {                                                                             // 1052\n                            ggp = gp;                                                                                  // 1053\n                        }                                                                                              // 1054\n                        gp = p;                                                                                        // 1055\n                        p = node;                                                                                      // 1056\n                        node = node.get_child(dir);                                                                    // 1057\n                    }                                                                                                  // 1058\n                    // update root                                                                                     // 1059\n                    this._root = head.right;                                                                           // 1060\n                }                                                                                                      // 1061\n                // make root black                                                                                     // 1062\n                this._root.red = false;                                                                                // 1063\n                return ret;                                                                                            // 1064\n            };                                                                                                         // 1065\n            ;                                                                                                          // 1066\n            // returns true if removed, false if not found                                                             // 1067\n            RBTree.prototype.remove = function (data) {                                                                // 1068\n                if (this._root === null) {                                                                             // 1069\n                    return false;                                                                                      // 1070\n                }                                                                                                      // 1071\n                var head = new Node(undefined); // fake tree root                                                      // 1072\n                var node = head;                                                                                       // 1073\n                node.right = this._root;                                                                               // 1074\n                var p = null; // parent                                                                                // 1075\n                var gp = null; // grand parent                                                                         // 1076\n                var found = null; // found item                                                                        // 1077\n                var dir = true;                                                                                        // 1078\n                while (node.get_child(dir) !== null) {                                                                 // 1079\n                    var last = dir;                                                                                    // 1080\n                    // update helpers                                                                                  // 1081\n                    gp = p;                                                                                            // 1082\n                    p = node;                                                                                          // 1083\n                    node = node.get_child(dir);                                                                        // 1084\n                    var cmp = this._comparator(data, node.data);                                                       // 1085\n                    dir = cmp > 0;                                                                                     // 1086\n                    // save found node                                                                                 // 1087\n                    if (cmp === 0) {                                                                                   // 1088\n                        found = node;                                                                                  // 1089\n                    }                                                                                                  // 1090\n                    // push the red node down                                                                          // 1091\n                    if (!RBTree.is_red(node) && !RBTree.is_red(node.get_child(dir))) {                                 // 1092\n                        if (RBTree.is_red(node.get_child(!dir))) {                                                     // 1093\n                            var sr = RBTree.single_rotate(node, dir);                                                  // 1094\n                            p.set_child(last, sr);                                                                     // 1095\n                            p = sr;                                                                                    // 1096\n                        }                                                                                              // 1097\n                        else if (!RBTree.is_red(node.get_child(!dir))) {                                               // 1098\n                            var sibling = p.get_child(!last);                                                          // 1099\n                            if (sibling !== null) {                                                                    // 1100\n                                if (!RBTree.is_red(sibling.get_child(!last)) && !RBTree.is_red(sibling.get_child(last))) {\n                                    // color flip                                                                      // 1102\n                                    p.red = false;                                                                     // 1103\n                                    sibling.red = true;                                                                // 1104\n                                    node.red = true;                                                                   // 1105\n                                }                                                                                      // 1106\n                                else {                                                                                 // 1107\n                                    var dir2 = gp.right === p;                                                         // 1108\n                                    if (RBTree.is_red(sibling.get_child(last))) {                                      // 1109\n                                        gp.set_child(dir2, RBTree.double_rotate(p, last));                             // 1110\n                                    }                                                                                  // 1111\n                                    else if (RBTree.is_red(sibling.get_child(!last))) {                                // 1112\n                                        gp.set_child(dir2, RBTree.single_rotate(p, last));                             // 1113\n                                    }                                                                                  // 1114\n                                    // ensure correct coloring                                                         // 1115\n                                    var gpc = gp.get_child(dir2);                                                      // 1116\n                                    gpc.red = true;                                                                    // 1117\n                                    node.red = true;                                                                   // 1118\n                                    gpc.left.red = false;                                                              // 1119\n                                    gpc.right.red = false;                                                             // 1120\n                                }                                                                                      // 1121\n                            }                                                                                          // 1122\n                        }                                                                                              // 1123\n                    }                                                                                                  // 1124\n                }                                                                                                      // 1125\n                // replace and remove if found                                                                         // 1126\n                if (found !== null) {                                                                                  // 1127\n                    found.data = node.data;                                                                            // 1128\n                    p.set_child(p.right === node, node.get_child(node.left === null));                                 // 1129\n                    this.size--;                                                                                       // 1130\n                }                                                                                                      // 1131\n                // update root and make it black                                                                       // 1132\n                this._root = head.right;                                                                               // 1133\n                if (this._root !== null) {                                                                             // 1134\n                    this._root.red = false;                                                                            // 1135\n                }                                                                                                      // 1136\n                return found !== null;                                                                                 // 1137\n            };                                                                                                         // 1138\n            ;                                                                                                          // 1139\n            RBTree.is_red = function (node) {                                                                          // 1140\n                return node !== null && node.red;                                                                      // 1141\n            };                                                                                                         // 1142\n            RBTree.single_rotate = function (root, dir) {                                                              // 1143\n                var save = root.get_child(!dir);                                                                       // 1144\n                root.set_child(!dir, save.get_child(dir));                                                             // 1145\n                save.set_child(dir, root);                                                                             // 1146\n                root.red = true;                                                                                       // 1147\n                save.red = false;                                                                                      // 1148\n                return save;                                                                                           // 1149\n            };                                                                                                         // 1150\n            RBTree.double_rotate = function (root, dir) {                                                              // 1151\n                root.set_child(!dir, RBTree.single_rotate(root.get_child(!dir), !dir));                                // 1152\n                return RBTree.single_rotate(root, dir);                                                                // 1153\n            };                                                                                                         // 1154\n            return RBTree;                                                                                             // 1155\n        })(TreeBase);                                                                                                  // 1156\n        vpsc.RBTree = RBTree;                                                                                          // 1157\n    })(vpsc = cola.vpsc || (cola.vpsc = {}));                                                                          // 1158\n})(cola || (cola = {}));                                                                                               // 1159\n///<reference path=\"vpsc.ts\"/>                                                                                         // 1160\n///<reference path=\"rbtree.ts\"/>                                                                                       // 1161\nvar cola;                                                                                                              // 1162\n(function (cola) {                                                                                                     // 1163\n    var vpsc;                                                                                                          // 1164\n    (function (vpsc) {                                                                                                 // 1165\n        function computeGroupBounds(g) {                                                                               // 1166\n            g.bounds = typeof g.leaves !== \"undefined\" ?                                                               // 1167\n                g.leaves.reduce(function (r, c) { return c.bounds.union(r); }, Rectangle.empty()) :                    // 1168\n                Rectangle.empty();                                                                                     // 1169\n            if (typeof g.groups !== \"undefined\")                                                                       // 1170\n                g.bounds = g.groups.reduce(function (r, c) { return computeGroupBounds(c).union(r); }, g.bounds);      // 1171\n            g.bounds = g.bounds.inflate(g.padding);                                                                    // 1172\n            return g.bounds;                                                                                           // 1173\n        }                                                                                                              // 1174\n        vpsc.computeGroupBounds = computeGroupBounds;                                                                  // 1175\n        var Rectangle = (function () {                                                                                 // 1176\n            function Rectangle(x, X, y, Y) {                                                                           // 1177\n                this.x = x;                                                                                            // 1178\n                this.X = X;                                                                                            // 1179\n                this.y = y;                                                                                            // 1180\n                this.Y = Y;                                                                                            // 1181\n            }                                                                                                          // 1182\n            Rectangle.empty = function () { return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY); };\n            Rectangle.prototype.cx = function () { return (this.x + this.X) / 2; };                                    // 1184\n            Rectangle.prototype.cy = function () { return (this.y + this.Y) / 2; };                                    // 1185\n            Rectangle.prototype.overlapX = function (r) {                                                              // 1186\n                var ux = this.cx(), vx = r.cx();                                                                       // 1187\n                if (ux <= vx && r.x < this.X)                                                                          // 1188\n                    return this.X - r.x;                                                                               // 1189\n                if (vx <= ux && this.x < r.X)                                                                          // 1190\n                    return r.X - this.x;                                                                               // 1191\n                return 0;                                                                                              // 1192\n            };                                                                                                         // 1193\n            Rectangle.prototype.overlapY = function (r) {                                                              // 1194\n                var uy = this.cy(), vy = r.cy();                                                                       // 1195\n                if (uy <= vy && r.y < this.Y)                                                                          // 1196\n                    return this.Y - r.y;                                                                               // 1197\n                if (vy <= uy && this.y < r.Y)                                                                          // 1198\n                    return r.Y - this.y;                                                                               // 1199\n                return 0;                                                                                              // 1200\n            };                                                                                                         // 1201\n            Rectangle.prototype.setXCentre = function (cx) {                                                           // 1202\n                var dx = cx - this.cx();                                                                               // 1203\n                this.x += dx;                                                                                          // 1204\n                this.X += dx;                                                                                          // 1205\n            };                                                                                                         // 1206\n            Rectangle.prototype.setYCentre = function (cy) {                                                           // 1207\n                var dy = cy - this.cy();                                                                               // 1208\n                this.y += dy;                                                                                          // 1209\n                this.Y += dy;                                                                                          // 1210\n            };                                                                                                         // 1211\n            Rectangle.prototype.width = function () {                                                                  // 1212\n                return this.X - this.x;                                                                                // 1213\n            };                                                                                                         // 1214\n            Rectangle.prototype.height = function () {                                                                 // 1215\n                return this.Y - this.y;                                                                                // 1216\n            };                                                                                                         // 1217\n            Rectangle.prototype.union = function (r) {                                                                 // 1218\n                return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));\n            };                                                                                                         // 1220\n            /**                                                                                                        // 1221\n             * return any intersection points between the given line and the sides of this rectangle                   // 1222\n             * @method lineIntersection                                                                                // 1223\n             * @param x1 number first x coord of line                                                                  // 1224\n             * @param y1 number first y coord of line                                                                  // 1225\n             * @param x2 number second x coord of line                                                                 // 1226\n             * @param y2 number second y coord of line                                                                 // 1227\n             * @return any intersection points found                                                                   // 1228\n             */                                                                                                        // 1229\n            Rectangle.prototype.lineIntersections = function (x1, y1, x2, y2) {                                        // 1230\n                var sides = [[this.x, this.y, this.X, this.y],                                                         // 1231\n                    [this.X, this.y, this.X, this.Y],                                                                  // 1232\n                    [this.X, this.Y, this.x, this.Y],                                                                  // 1233\n                    [this.x, this.Y, this.x, this.y]];                                                                 // 1234\n                var intersections = [];                                                                                // 1235\n                for (var i = 0; i < 4; ++i) {                                                                          // 1236\n                    var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);\n                    if (r !== null)                                                                                    // 1238\n                        intersections.push({ x: r.x, y: r.y });                                                        // 1239\n                }                                                                                                      // 1240\n                return intersections;                                                                                  // 1241\n            };                                                                                                         // 1242\n            /**                                                                                                        // 1243\n             * return any intersection points between a line extending from the centre of this rectangle to the given point,\n             *  and the sides of this rectangle                                                                        // 1245\n             * @method lineIntersection                                                                                // 1246\n             * @param x2 number second x coord of line                                                                 // 1247\n             * @param y2 number second y coord of line                                                                 // 1248\n             * @return any intersection points found                                                                   // 1249\n             */                                                                                                        // 1250\n            Rectangle.prototype.rayIntersection = function (x2, y2) {                                                  // 1251\n                var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);                                       // 1252\n                return ints.length > 0 ? ints[0] : null;                                                               // 1253\n            };                                                                                                         // 1254\n            Rectangle.prototype.vertices = function () {                                                               // 1255\n                return [                                                                                               // 1256\n                    { x: this.x, y: this.y },                                                                          // 1257\n                    { x: this.X, y: this.y },                                                                          // 1258\n                    { x: this.X, y: this.Y },                                                                          // 1259\n                    { x: this.x, y: this.Y },                                                                          // 1260\n                    { x: this.x, y: this.y }];                                                                         // 1261\n            };                                                                                                         // 1262\n            Rectangle.lineIntersection = function (x1, y1, x2, y2, x3, y3, x4, y4) {                                   // 1263\n                var dx12 = x2 - x1, dx34 = x4 - x3, dy12 = y2 - y1, dy34 = y4 - y3, denominator = dy34 * dx12 - dx34 * dy12;\n                if (denominator == 0)                                                                                  // 1265\n                    return null;                                                                                       // 1266\n                var dx31 = x1 - x3, dy31 = y1 - y3, numa = dx34 * dy31 - dy34 * dx31, a = numa / denominator, numb = dx12 * dy31 - dy12 * dx31, b = numb / denominator;\n                if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {                                                            // 1268\n                    return {                                                                                           // 1269\n                        x: x1 + a * dx12,                                                                              // 1270\n                        y: y1 + a * dy12                                                                               // 1271\n                    };                                                                                                 // 1272\n                }                                                                                                      // 1273\n                return null;                                                                                           // 1274\n            };                                                                                                         // 1275\n            Rectangle.prototype.inflate = function (pad) {                                                             // 1276\n                return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);                          // 1277\n            };                                                                                                         // 1278\n            return Rectangle;                                                                                          // 1279\n        })();                                                                                                          // 1280\n        vpsc.Rectangle = Rectangle;                                                                                    // 1281\n        function makeEdgeBetween(source, target, ah) {                                                                 // 1282\n            var si = source.rayIntersection(target.cx(), target.cy()) || { x: source.cx(), y: source.cy() }, ti = target.rayIntersection(source.cx(), source.cy()) || { x: target.cx(), y: target.cy() }, dx = ti.x - si.x, dy = ti.y - si.y, l = Math.sqrt(dx * dx + dy * dy), al = l - ah;\n            return {                                                                                                   // 1284\n                sourceIntersection: si,                                                                                // 1285\n                targetIntersection: ti,                                                                                // 1286\n                arrowStart: { x: si.x + al * dx / l, y: si.y + al * dy / l }                                           // 1287\n            };                                                                                                         // 1288\n        }                                                                                                              // 1289\n        vpsc.makeEdgeBetween = makeEdgeBetween;                                                                        // 1290\n        function makeEdgeTo(s, target, ah) {                                                                           // 1291\n            var ti = target.rayIntersection(s.x, s.y);                                                                 // 1292\n            if (!ti)                                                                                                   // 1293\n                ti = { x: target.cx(), y: target.cy() };                                                               // 1294\n            var dx = ti.x - s.x, dy = ti.y - s.y, l = Math.sqrt(dx * dx + dy * dy);                                    // 1295\n            return { x: ti.x - ah * dx / l, y: ti.y - ah * dy / l };                                                   // 1296\n        }                                                                                                              // 1297\n        vpsc.makeEdgeTo = makeEdgeTo;                                                                                  // 1298\n        var Node = (function () {                                                                                      // 1299\n            function Node(v, r, pos) {                                                                                 // 1300\n                this.v = v;                                                                                            // 1301\n                this.r = r;                                                                                            // 1302\n                this.pos = pos;                                                                                        // 1303\n                this.prev = makeRBTree();                                                                              // 1304\n                this.next = makeRBTree();                                                                              // 1305\n            }                                                                                                          // 1306\n            return Node;                                                                                               // 1307\n        })();                                                                                                          // 1308\n        var Event = (function () {                                                                                     // 1309\n            function Event(isOpen, v, pos) {                                                                           // 1310\n                this.isOpen = isOpen;                                                                                  // 1311\n                this.v = v;                                                                                            // 1312\n                this.pos = pos;                                                                                        // 1313\n            }                                                                                                          // 1314\n            return Event;                                                                                              // 1315\n        })();                                                                                                          // 1316\n        function compareEvents(a, b) {                                                                                 // 1317\n            if (a.pos > b.pos) {                                                                                       // 1318\n                return 1;                                                                                              // 1319\n            }                                                                                                          // 1320\n            if (a.pos < b.pos) {                                                                                       // 1321\n                return -1;                                                                                             // 1322\n            }                                                                                                          // 1323\n            if (a.isOpen) {                                                                                            // 1324\n                // open must come before close                                                                         // 1325\n                return -1;                                                                                             // 1326\n            }                                                                                                          // 1327\n            if (b.isOpen) {                                                                                            // 1328\n                // open must come before close                                                                         // 1329\n                return 1;                                                                                              // 1330\n            }                                                                                                          // 1331\n            return 0;                                                                                                  // 1332\n        }                                                                                                              // 1333\n        function makeRBTree() {                                                                                        // 1334\n            return new vpsc.RBTree(function (a, b) { return a.pos - b.pos; });                                         // 1335\n        }                                                                                                              // 1336\n        var xRect = {                                                                                                  // 1337\n            getCentre: function (r) { return r.cx(); },                                                                // 1338\n            getOpen: function (r) { return r.y; },                                                                     // 1339\n            getClose: function (r) { return r.Y; },                                                                    // 1340\n            getSize: function (r) { return r.width(); },                                                               // 1341\n            makeRect: function (open, close, center, size) { return new Rectangle(center - size / 2, center + size / 2, open, close); },\n            findNeighbours: findXNeighbours                                                                            // 1343\n        };                                                                                                             // 1344\n        var yRect = {                                                                                                  // 1345\n            getCentre: function (r) { return r.cy(); },                                                                // 1346\n            getOpen: function (r) { return r.x; },                                                                     // 1347\n            getClose: function (r) { return r.X; },                                                                    // 1348\n            getSize: function (r) { return r.height(); },                                                              // 1349\n            makeRect: function (open, close, center, size) { return new Rectangle(open, close, center - size / 2, center + size / 2); },\n            findNeighbours: findYNeighbours                                                                            // 1351\n        };                                                                                                             // 1352\n        function generateGroupConstraints(root, f, minSep, isContained) {                                              // 1353\n            if (isContained === void 0) { isContained = false; }                                                       // 1354\n            var padding = root.padding, gn = typeof root.groups !== 'undefined' ? root.groups.length : 0, ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0, childConstraints = !gn ? []\n                : root.groups.reduce(function (ccs, g) { return ccs.concat(generateGroupConstraints(g, f, minSep, true)); }, []), n = (isContained ? 2 : 0) + ln + gn, vs = new Array(n), rs = new Array(n), i = 0, add = function (r, v) { rs[i] = r; vs[i++] = v; };\n            if (isContained) {                                                                                         // 1357\n                // if this group is contained by another, then we add two dummy vars and rectangles for the borders    // 1358\n                var b = root.bounds, c = f.getCentre(b), s = f.getSize(b) / 2, open = f.getOpen(b), close = f.getClose(b), min = c - s + padding / 2, max = c + s - padding / 2;\n                root.minVar.desiredPosition = min;                                                                     // 1360\n                add(f.makeRect(open, close, min, padding), root.minVar);                                               // 1361\n                root.maxVar.desiredPosition = max;                                                                     // 1362\n                add(f.makeRect(open, close, max, padding), root.maxVar);                                               // 1363\n            }                                                                                                          // 1364\n            if (ln)                                                                                                    // 1365\n                root.leaves.forEach(function (l) { return add(l.bounds, l.variable); });                               // 1366\n            if (gn)                                                                                                    // 1367\n                root.groups.forEach(function (g) {                                                                     // 1368\n                    var b = g.bounds;                                                                                  // 1369\n                    add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);              // 1370\n                });                                                                                                    // 1371\n            var cs = generateConstraints(rs, vs, f, minSep);                                                           // 1372\n            if (gn) {                                                                                                  // 1373\n                vs.forEach(function (v) { v.cOut = [], v.cIn = []; });                                                 // 1374\n                cs.forEach(function (c) { c.left.cOut.push(c), c.right.cIn.push(c); });                                // 1375\n                root.groups.forEach(function (g) {                                                                     // 1376\n                    var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;                                         // 1377\n                    g.minVar.cIn.forEach(function (c) { return c.gap += gapAdjustment; });                             // 1378\n                    g.minVar.cOut.forEach(function (c) { c.left = g.maxVar; c.gap += gapAdjustment; });                // 1379\n                });                                                                                                    // 1380\n            }                                                                                                          // 1381\n            return childConstraints.concat(cs);                                                                        // 1382\n        }                                                                                                              // 1383\n        function generateConstraints(rs, vars, rect, minSep) {                                                         // 1384\n            var i, n = rs.length;                                                                                      // 1385\n            var N = 2 * n;                                                                                             // 1386\n            console.assert(vars.length >= n);                                                                          // 1387\n            var events = new Array(N);                                                                                 // 1388\n            for (i = 0; i < n; ++i) {                                                                                  // 1389\n                var r = rs[i];                                                                                         // 1390\n                var v = new Node(vars[i], r, rect.getCentre(r));                                                       // 1391\n                events[i] = new Event(true, v, rect.getOpen(r));                                                       // 1392\n                events[i + n] = new Event(false, v, rect.getClose(r));                                                 // 1393\n            }                                                                                                          // 1394\n            events.sort(compareEvents);                                                                                // 1395\n            var cs = new Array();                                                                                      // 1396\n            var scanline = makeRBTree();                                                                               // 1397\n            for (i = 0; i < N; ++i) {                                                                                  // 1398\n                var e = events[i];                                                                                     // 1399\n                var v = e.v;                                                                                           // 1400\n                if (e.isOpen) {                                                                                        // 1401\n                    scanline.insert(v);                                                                                // 1402\n                    rect.findNeighbours(v, scanline);                                                                  // 1403\n                }                                                                                                      // 1404\n                else {                                                                                                 // 1405\n                    // close event                                                                                     // 1406\n                    scanline.remove(v);                                                                                // 1407\n                    var makeConstraint = function (l, r) {                                                             // 1408\n                        var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;                                // 1409\n                        cs.push(new vpsc.Constraint(l.v, r.v, sep));                                                   // 1410\n                    };                                                                                                 // 1411\n                    var visitNeighbours = function (forward, reverse, mkcon) {                                         // 1412\n                        var u, it = v[forward].iterator();                                                             // 1413\n                        while ((u = it[forward]()) !== null) {                                                         // 1414\n                            mkcon(u, v);                                                                               // 1415\n                            u[reverse].remove(v);                                                                      // 1416\n                        }                                                                                              // 1417\n                    };                                                                                                 // 1418\n                    visitNeighbours(\"prev\", \"next\", function (u, v) { return makeConstraint(u, v); });                 // 1419\n                    visitNeighbours(\"next\", \"prev\", function (u, v) { return makeConstraint(v, u); });                 // 1420\n                }                                                                                                      // 1421\n            }                                                                                                          // 1422\n            console.assert(scanline.size === 0);                                                                       // 1423\n            return cs;                                                                                                 // 1424\n        }                                                                                                              // 1425\n        function findXNeighbours(v, scanline) {                                                                        // 1426\n            var f = function (forward, reverse) {                                                                      // 1427\n                var it = scanline.findIter(v);                                                                         // 1428\n                var u;                                                                                                 // 1429\n                while ((u = it[forward]()) !== null) {                                                                 // 1430\n                    var uovervX = u.r.overlapX(v.r);                                                                   // 1431\n                    if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {                                                // 1432\n                        v[forward].insert(u);                                                                          // 1433\n                        u[reverse].insert(v);                                                                          // 1434\n                    }                                                                                                  // 1435\n                    if (uovervX <= 0) {                                                                                // 1436\n                        break;                                                                                         // 1437\n                    }                                                                                                  // 1438\n                }                                                                                                      // 1439\n            };                                                                                                         // 1440\n            f(\"next\", \"prev\");                                                                                         // 1441\n            f(\"prev\", \"next\");                                                                                         // 1442\n        }                                                                                                              // 1443\n        function findYNeighbours(v, scanline) {                                                                        // 1444\n            var f = function (forward, reverse) {                                                                      // 1445\n                var u = scanline.findIter(v)[forward]();                                                               // 1446\n                if (u !== null && u.r.overlapX(v.r) > 0) {                                                             // 1447\n                    v[forward].insert(u);                                                                              // 1448\n                    u[reverse].insert(v);                                                                              // 1449\n                }                                                                                                      // 1450\n            };                                                                                                         // 1451\n            f(\"next\", \"prev\");                                                                                         // 1452\n            f(\"prev\", \"next\");                                                                                         // 1453\n        }                                                                                                              // 1454\n        function generateXConstraints(rs, vars) {                                                                      // 1455\n            return generateConstraints(rs, vars, xRect, 1e-6);                                                         // 1456\n        }                                                                                                              // 1457\n        vpsc.generateXConstraints = generateXConstraints;                                                              // 1458\n        function generateYConstraints(rs, vars) {                                                                      // 1459\n            return generateConstraints(rs, vars, yRect, 1e-6);                                                         // 1460\n        }                                                                                                              // 1461\n        vpsc.generateYConstraints = generateYConstraints;                                                              // 1462\n        function generateXGroupConstraints(root) {                                                                     // 1463\n            return generateGroupConstraints(root, xRect, 1e-6);                                                        // 1464\n        }                                                                                                              // 1465\n        vpsc.generateXGroupConstraints = generateXGroupConstraints;                                                    // 1466\n        function generateYGroupConstraints(root) {                                                                     // 1467\n            return generateGroupConstraints(root, yRect, 1e-6);                                                        // 1468\n        }                                                                                                              // 1469\n        vpsc.generateYGroupConstraints = generateYGroupConstraints;                                                    // 1470\n        function removeOverlaps(rs) {                                                                                  // 1471\n            var vs = rs.map(function (r) { return new vpsc.Variable(r.cx()); });                                       // 1472\n            var cs = vpsc.generateXConstraints(rs, vs);                                                                // 1473\n            var solver = new vpsc.Solver(vs, cs);                                                                      // 1474\n            solver.solve();                                                                                            // 1475\n            vs.forEach(function (v, i) { return rs[i].setXCentre(v.position()); });                                    // 1476\n            vs = rs.map(function (r) { return new vpsc.Variable(r.cy()); });                                           // 1477\n            cs = vpsc.generateYConstraints(rs, vs);                                                                    // 1478\n            solver = new vpsc.Solver(vs, cs);                                                                          // 1479\n            solver.solve();                                                                                            // 1480\n            vs.forEach(function (v, i) { return rs[i].setYCentre(v.position()); });                                    // 1481\n        }                                                                                                              // 1482\n        vpsc.removeOverlaps = removeOverlaps;                                                                          // 1483\n        var IndexedVariable = (function (_super) {                                                                     // 1484\n            __extends(IndexedVariable, _super);                                                                        // 1485\n            function IndexedVariable(index, w) {                                                                       // 1486\n                _super.call(this, 0, w);                                                                               // 1487\n                this.index = index;                                                                                    // 1488\n            }                                                                                                          // 1489\n            return IndexedVariable;                                                                                    // 1490\n        })(vpsc.Variable);                                                                                             // 1491\n        vpsc.IndexedVariable = IndexedVariable;                                                                        // 1492\n        var Projection = (function () {                                                                                // 1493\n            function Projection(nodes, groups, rootGroup, constraints, avoidOverlaps) {                                // 1494\n                var _this = this;                                                                                      // 1495\n                if (rootGroup === void 0) { rootGroup = null; }                                                        // 1496\n                if (constraints === void 0) { constraints = null; }                                                    // 1497\n                if (avoidOverlaps === void 0) { avoidOverlaps = false; }                                               // 1498\n                this.nodes = nodes;                                                                                    // 1499\n                this.groups = groups;                                                                                  // 1500\n                this.rootGroup = rootGroup;                                                                            // 1501\n                this.avoidOverlaps = avoidOverlaps;                                                                    // 1502\n                this.variables = nodes.map(function (v, i) {                                                           // 1503\n                    return v.variable = new IndexedVariable(i, 1);                                                     // 1504\n                });                                                                                                    // 1505\n                if (constraints)                                                                                       // 1506\n                    this.createConstraints(constraints);                                                               // 1507\n                if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {                           // 1508\n                    nodes.forEach(function (v) {                                                                       // 1509\n                        if (!v.width || !v.height) {                                                                   // 1510\n                            //If undefined, default to nothing                                                         // 1511\n                            v.bounds = new vpsc.Rectangle(v.x, v.x, v.y, v.y);                                         // 1512\n                            return;                                                                                    // 1513\n                        }                                                                                              // 1514\n                        var w2 = v.width / 2, h2 = v.height / 2;                                                       // 1515\n                        v.bounds = new vpsc.Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);                         // 1516\n                    });                                                                                                // 1517\n                    computeGroupBounds(rootGroup);                                                                     // 1518\n                    var i = nodes.length;                                                                              // 1519\n                    groups.forEach(function (g) {                                                                      // 1520\n                        _this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\n                        _this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\n                    });                                                                                                // 1523\n                }                                                                                                      // 1524\n            }                                                                                                          // 1525\n            Projection.prototype.createSeparation = function (c) {                                                     // 1526\n                return new vpsc.Constraint(this.nodes[c.left].variable, this.nodes[c.right].variable, c.gap, typeof c.equality !== \"undefined\" ? c.equality : false);\n            };                                                                                                         // 1528\n            Projection.prototype.makeFeasible = function (c) {                                                         // 1529\n                var _this = this;                                                                                      // 1530\n                if (!this.avoidOverlaps)                                                                               // 1531\n                    return;                                                                                            // 1532\n                var axis = 'x', dim = 'width';                                                                         // 1533\n                if (c.axis === 'x')                                                                                    // 1534\n                    axis = 'y', dim = 'height';                                                                        // 1535\n                var vs = c.offsets.map(function (o) { return _this.nodes[o.node]; }).sort(function (a, b) { return a[axis] - b[axis]; });\n                var p = null;                                                                                          // 1537\n                vs.forEach(function (v) {                                                                              // 1538\n                    if (p)                                                                                             // 1539\n                        v[axis] = p[axis] + p[dim] + 1;                                                                // 1540\n                    p = v;                                                                                             // 1541\n                });                                                                                                    // 1542\n            };                                                                                                         // 1543\n            Projection.prototype.createAlignment = function (c) {                                                      // 1544\n                var _this = this;                                                                                      // 1545\n                var u = this.nodes[c.offsets[0].node].variable;                                                        // 1546\n                this.makeFeasible(c);                                                                                  // 1547\n                var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;                                       // 1548\n                c.offsets.slice(1).forEach(function (o) {                                                              // 1549\n                    var v = _this.nodes[o.node].variable;                                                              // 1550\n                    cs.push(new vpsc.Constraint(u, v, o.offset, true));                                                // 1551\n                });                                                                                                    // 1552\n            };                                                                                                         // 1553\n            Projection.prototype.createConstraints = function (constraints) {                                          // 1554\n                var _this = this;                                                                                      // 1555\n                var isSep = function (c) { return typeof c.type === 'undefined' || c.type === 'separation'; };         // 1556\n                this.xConstraints = constraints                                                                        // 1557\n                    .filter(function (c) { return c.axis === \"x\" && isSep(c); })                                       // 1558\n                    .map(function (c) { return _this.createSeparation(c); });                                          // 1559\n                this.yConstraints = constraints                                                                        // 1560\n                    .filter(function (c) { return c.axis === \"y\" && isSep(c); })                                       // 1561\n                    .map(function (c) { return _this.createSeparation(c); });                                          // 1562\n                constraints                                                                                            // 1563\n                    .filter(function (c) { return c.type === 'alignment'; })                                           // 1564\n                    .forEach(function (c) { return _this.createAlignment(c); });                                       // 1565\n            };                                                                                                         // 1566\n            Projection.prototype.setupVariablesAndBounds = function (x0, y0, desired, getDesired) {                    // 1567\n                this.nodes.forEach(function (v, i) {                                                                   // 1568\n                    if (v.fixed) {                                                                                     // 1569\n                        v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;                                      // 1570\n                        desired[i] = getDesired(v);                                                                    // 1571\n                    }                                                                                                  // 1572\n                    else {                                                                                             // 1573\n                        v.variable.weight = 1;                                                                         // 1574\n                    }                                                                                                  // 1575\n                    var w = (v.width || 0) / 2, h = (v.height || 0) / 2;                                               // 1576\n                    var ix = x0[i], iy = y0[i];                                                                        // 1577\n                    v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);                                          // 1578\n                });                                                                                                    // 1579\n            };                                                                                                         // 1580\n            Projection.prototype.xProject = function (x0, y0, x) {                                                     // 1581\n                if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints))                                     // 1582\n                    return;                                                                                            // 1583\n                this.project(x0, y0, x0, x, function (v) { return v.px; }, this.xConstraints, generateXGroupConstraints, function (v) { return v.bounds.setXCentre(x[v.variable.index] = v.variable.position()); }, function (g) {\n                    var xmin = x[g.minVar.index] = g.minVar.position();                                                // 1585\n                    var xmax = x[g.maxVar.index] = g.maxVar.position();                                                // 1586\n                    var p2 = g.padding / 2;                                                                            // 1587\n                    g.bounds.x = xmin - p2;                                                                            // 1588\n                    g.bounds.X = xmax + p2;                                                                            // 1589\n                });                                                                                                    // 1590\n            };                                                                                                         // 1591\n            Projection.prototype.yProject = function (x0, y0, y) {                                                     // 1592\n                if (!this.rootGroup && !this.yConstraints)                                                             // 1593\n                    return;                                                                                            // 1594\n                this.project(x0, y0, y0, y, function (v) { return v.py; }, this.yConstraints, generateYGroupConstraints, function (v) { return v.bounds.setYCentre(y[v.variable.index] = v.variable.position()); }, function (g) {\n                    var ymin = y[g.minVar.index] = g.minVar.position();                                                // 1596\n                    var ymax = y[g.maxVar.index] = g.maxVar.position();                                                // 1597\n                    var p2 = g.padding / 2;                                                                            // 1598\n                    g.bounds.y = ymin - p2;                                                                            // 1599\n                    ;                                                                                                  // 1600\n                    g.bounds.Y = ymax + p2;                                                                            // 1601\n                });                                                                                                    // 1602\n            };                                                                                                         // 1603\n            Projection.prototype.projectFunctions = function () {                                                      // 1604\n                var _this = this;                                                                                      // 1605\n                return [                                                                                               // 1606\n                    function (x0, y0, x) { return _this.xProject(x0, y0, x); },                                        // 1607\n                    function (x0, y0, y) { return _this.yProject(x0, y0, y); }                                         // 1608\n                ];                                                                                                     // 1609\n            };                                                                                                         // 1610\n            Projection.prototype.project = function (x0, y0, start, desired, getDesired, cs, generateConstraints, updateNodeBounds, updateGroupBounds) {\n                this.setupVariablesAndBounds(x0, y0, desired, getDesired);                                             // 1612\n                if (this.rootGroup && this.avoidOverlaps) {                                                            // 1613\n                    computeGroupBounds(this.rootGroup);                                                                // 1614\n                    cs = cs.concat(generateConstraints(this.rootGroup));                                               // 1615\n                }                                                                                                      // 1616\n                this.solve(this.variables, cs, start, desired);                                                        // 1617\n                this.nodes.forEach(updateNodeBounds);                                                                  // 1618\n                if (this.rootGroup && this.avoidOverlaps) {                                                            // 1619\n                    this.groups.forEach(updateGroupBounds);                                                            // 1620\n                    computeGroupBounds(this.rootGroup);                                                                // 1621\n                }                                                                                                      // 1622\n            };                                                                                                         // 1623\n            Projection.prototype.solve = function (vs, cs, starting, desired) {                                        // 1624\n                var solver = new vpsc.Solver(vs, cs);                                                                  // 1625\n                solver.setStartingPositions(starting);                                                                 // 1626\n                solver.setDesiredPositions(desired);                                                                   // 1627\n                solver.solve();                                                                                        // 1628\n            };                                                                                                         // 1629\n            return Projection;                                                                                         // 1630\n        })();                                                                                                          // 1631\n        vpsc.Projection = Projection;                                                                                  // 1632\n    })(vpsc = cola.vpsc || (cola.vpsc = {}));                                                                          // 1633\n})(cola || (cola = {}));                                                                                               // 1634\n///<reference path=\"vpsc.ts\"/>                                                                                         // 1635\n///<reference path=\"rectangle.ts\"/>                                                                                    // 1636\nvar cola;                                                                                                              // 1637\n(function (cola) {                                                                                                     // 1638\n    var geom;                                                                                                          // 1639\n    (function (geom) {                                                                                                 // 1640\n        var Point = (function () {                                                                                     // 1641\n            function Point() {                                                                                         // 1642\n            }                                                                                                          // 1643\n            return Point;                                                                                              // 1644\n        })();                                                                                                          // 1645\n        geom.Point = Point;                                                                                            // 1646\n        var LineSegment = (function () {                                                                               // 1647\n            function LineSegment(x1, y1, x2, y2) {                                                                     // 1648\n                this.x1 = x1;                                                                                          // 1649\n                this.y1 = y1;                                                                                          // 1650\n                this.x2 = x2;                                                                                          // 1651\n                this.y2 = y2;                                                                                          // 1652\n            }                                                                                                          // 1653\n            return LineSegment;                                                                                        // 1654\n        })();                                                                                                          // 1655\n        geom.LineSegment = LineSegment;                                                                                // 1656\n        var PolyPoint = (function (_super) {                                                                           // 1657\n            __extends(PolyPoint, _super);                                                                              // 1658\n            function PolyPoint() {                                                                                     // 1659\n                _super.apply(this, arguments);                                                                         // 1660\n            }                                                                                                          // 1661\n            return PolyPoint;                                                                                          // 1662\n        })(Point);                                                                                                     // 1663\n        geom.PolyPoint = PolyPoint;                                                                                    // 1664\n        /** tests if a point is Left|On|Right of an infinite line.                                                     // 1665\n         * @param points P0, P1, and P2                                                                                // 1666\n         * @return >0 for P2 left of the line through P0 and P1                                                        // 1667\n         *            =0 for P2 on the line                                                                            // 1668\n         *            <0 for P2 right of the line                                                                      // 1669\n         */                                                                                                            // 1670\n        function isLeft(P0, P1, P2) {                                                                                  // 1671\n            return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);                                      // 1672\n        }                                                                                                              // 1673\n        geom.isLeft = isLeft;                                                                                          // 1674\n        function above(p, vi, vj) {                                                                                    // 1675\n            return isLeft(p, vi, vj) > 0;                                                                              // 1676\n        }                                                                                                              // 1677\n        function below(p, vi, vj) {                                                                                    // 1678\n            return isLeft(p, vi, vj) < 0;                                                                              // 1679\n        }                                                                                                              // 1680\n        /**                                                                                                            // 1681\n         * returns the convex hull of a set of points using Andrew's monotone chain algorithm                          // 1682\n         * see: http://geomalgorithms.com/a10-_hull-1.html#Monotone%20Chain                                            // 1683\n         * @param S array of points                                                                                    // 1684\n         * @return the convex hull as an array of points                                                               // 1685\n         */                                                                                                            // 1686\n        function ConvexHull(S) {                                                                                       // 1687\n            var P = S.slice(0).sort(function (a, b) { return a.x !== b.x ? b.x - a.x : b.y - a.y; });                  // 1688\n            var n = S.length, i;                                                                                       // 1689\n            var minmin = 0;                                                                                            // 1690\n            var xmin = P[0].x;                                                                                         // 1691\n            for (i = 1; i < n; ++i) {                                                                                  // 1692\n                if (P[i].x !== xmin)                                                                                   // 1693\n                    break;                                                                                             // 1694\n            }                                                                                                          // 1695\n            var minmax = i - 1;                                                                                        // 1696\n            var H = [];                                                                                                // 1697\n            H.push(P[minmin]); // push minmin point onto stack                                                         // 1698\n            if (minmax === n - 1) {                                                                                    // 1699\n                if (P[minmax].y !== P[minmin].y)                                                                       // 1700\n                    H.push(P[minmax]);                                                                                 // 1701\n            }                                                                                                          // 1702\n            else {                                                                                                     // 1703\n                // Get the indices of points with max x-coord and min|max y-coord                                      // 1704\n                var maxmin, maxmax = n - 1;                                                                            // 1705\n                var xmax = P[n - 1].x;                                                                                 // 1706\n                for (i = n - 2; i >= 0; i--)                                                                           // 1707\n                    if (P[i].x !== xmax)                                                                               // 1708\n                        break;                                                                                         // 1709\n                maxmin = i + 1;                                                                                        // 1710\n                // Compute the lower hull on the stack H                                                               // 1711\n                i = minmax;                                                                                            // 1712\n                while (++i <= maxmin) {                                                                                // 1713\n                    // the lower line joins P[minmin]  with P[maxmin]                                                  // 1714\n                    if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin)                                         // 1715\n                        continue; // ignore P[i] above or on the lower line                                            // 1716\n                    while (H.length > 1) {                                                                             // 1717\n                        // test if  P[i] is left of the line at the stack top                                          // 1718\n                        if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)                                        // 1719\n                            break; // P[i] is a new hull  vertex                                                       // 1720\n                        else                                                                                           // 1721\n                            H.length -= 1; // pop top point off  stack                                                 // 1722\n                    }                                                                                                  // 1723\n                    if (i != minmin)                                                                                   // 1724\n                        H.push(P[i]);                                                                                  // 1725\n                }                                                                                                      // 1726\n                // Next, compute the upper hull on the stack H above the bottom hull                                   // 1727\n                if (maxmax != maxmin)                                                                                  // 1728\n                    H.push(P[maxmax]); // push maxmax point onto stack                                                 // 1729\n                var bot = H.length; // the bottom point of the upper hull stack                                        // 1730\n                i = maxmin;                                                                                            // 1731\n                while (--i >= minmax) {                                                                                // 1732\n                    // the upper line joins P[maxmax]  with P[minmax]                                                  // 1733\n                    if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax)                                         // 1734\n                        continue; // ignore P[i] below or on the upper line                                            // 1735\n                    while (H.length > bot) {                                                                           // 1736\n                        // test if  P[i] is left of the line at the stack top                                          // 1737\n                        if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)                                        // 1738\n                            break; // P[i] is a new hull  vertex                                                       // 1739\n                        else                                                                                           // 1740\n                            H.length -= 1; // pop top point off  stack                                                 // 1741\n                    }                                                                                                  // 1742\n                    if (i != minmin)                                                                                   // 1743\n                        H.push(P[i]); // push P[i] onto stack                                                          // 1744\n                }                                                                                                      // 1745\n            }                                                                                                          // 1746\n            return H;                                                                                                  // 1747\n        }                                                                                                              // 1748\n        geom.ConvexHull = ConvexHull;                                                                                  // 1749\n        // apply f to the points in P in clockwise order around the point p                                            // 1750\n        function clockwiseRadialSweep(p, P, f) {                                                                       // 1751\n            P.slice(0).sort(function (a, b) { return Math.atan2(a.y - p.y, a.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x); }).forEach(f);\n        }                                                                                                              // 1753\n        geom.clockwiseRadialSweep = clockwiseRadialSweep;                                                              // 1754\n        function nextPolyPoint(p, ps) {                                                                                // 1755\n            if (p.polyIndex === ps.length - 1)                                                                         // 1756\n                return ps[0];                                                                                          // 1757\n            return ps[p.polyIndex + 1];                                                                                // 1758\n        }                                                                                                              // 1759\n        function prevPolyPoint(p, ps) {                                                                                // 1760\n            if (p.polyIndex === 0)                                                                                     // 1761\n                return ps[ps.length - 1];                                                                              // 1762\n            return ps[p.polyIndex - 1];                                                                                // 1763\n        }                                                                                                              // 1764\n        // tangent_PointPolyC(): fast binary search for tangents to a convex polygon                                   // 1765\n        //    Input:  P = a 2D point (exterior to the polygon)                                                         // 1766\n        //            n = number of polygon vertices                                                                   // 1767\n        //            V = array of vertices for a 2D convex polygon with V[n] = V[0]                                   // 1768\n        //    Output: rtan = index of rightmost tangent point V[rtan]                                                  // 1769\n        //            ltan = index of leftmost tangent point V[ltan]                                                   // 1770\n        function tangent_PointPolyC(P, V) {                                                                            // 1771\n            return { rtan: Rtangent_PointPolyC(P, V), ltan: Ltangent_PointPolyC(P, V) };                               // 1772\n        }                                                                                                              // 1773\n        // Rtangent_PointPolyC(): binary search for convex polygon right tangent                                       // 1774\n        //    Input:  P = a 2D point (exterior to the polygon)                                                         // 1775\n        //            n = number of polygon vertices                                                                   // 1776\n        //            V = array of vertices for a 2D convex polygon with V[n] = V[0]                                   // 1777\n        //    Return: index \"i\" of rightmost tangent point V[i]                                                        // 1778\n        function Rtangent_PointPolyC(P, V) {                                                                           // 1779\n            var n = V.length - 1;                                                                                      // 1780\n            // use binary search for large convex polygons                                                             // 1781\n            var a, b, c; // indices for edge chain endpoints                                                           // 1782\n            var upA, dnC; // test for up direction of edges a and c                                                    // 1783\n            // rightmost tangent = maximum for the isLeft() ordering                                                   // 1784\n            // test if V[0] is a local maximum                                                                         // 1785\n            if (below(P, V[1], V[0]) && !above(P, V[n - 1], V[0]))                                                     // 1786\n                return 0; // V[0] is the maximum tangent point                                                         // 1787\n            for (a = 0, b = n;;) {                                                                                     // 1788\n                if (b - a === 1)                                                                                       // 1789\n                    if (above(P, V[a], V[b]))                                                                          // 1790\n                        return a;                                                                                      // 1791\n                    else                                                                                               // 1792\n                        return b;                                                                                      // 1793\n                c = Math.floor((a + b) / 2); // midpoint of [a,b], and 0<c<n                                           // 1794\n                dnC = below(P, V[c + 1], V[c]);                                                                        // 1795\n                if (dnC && !above(P, V[c - 1], V[c]))                                                                  // 1796\n                    return c; // V[c] is the maximum tangent point                                                     // 1797\n                // no max yet, so continue with the binary search                                                      // 1798\n                // pick one of the two subchains [a,c] or [c,b]                                                        // 1799\n                upA = above(P, V[a + 1], V[a]);                                                                        // 1800\n                if (upA) {                                                                                             // 1801\n                    if (dnC)                                                                                           // 1802\n                        b = c; // select [a,c]                                                                         // 1803\n                    else {                                                                                             // 1804\n                        if (above(P, V[a], V[c]))                                                                      // 1805\n                            b = c; // select [a,c]                                                                     // 1806\n                        else                                                                                           // 1807\n                            a = c; // select [c,b]                                                                     // 1808\n                    }                                                                                                  // 1809\n                }                                                                                                      // 1810\n                else {                                                                                                 // 1811\n                    if (!dnC)                                                                                          // 1812\n                        a = c; // select [c,b]                                                                         // 1813\n                    else {                                                                                             // 1814\n                        if (below(P, V[a], V[c]))                                                                      // 1815\n                            b = c; // select [a,c]                                                                     // 1816\n                        else                                                                                           // 1817\n                            a = c; // select [c,b]                                                                     // 1818\n                    }                                                                                                  // 1819\n                }                                                                                                      // 1820\n            }                                                                                                          // 1821\n        }                                                                                                              // 1822\n        // Ltangent_PointPolyC(): binary search for convex polygon left tangent                                        // 1823\n        //    Input:  P = a 2D point (exterior to the polygon)                                                         // 1824\n        //            n = number of polygon vertices                                                                   // 1825\n        //            V = array of vertices for a 2D convex polygon with V[n]=V[0]                                     // 1826\n        //    Return: index \"i\" of leftmost tangent point V[i]                                                         // 1827\n        function Ltangent_PointPolyC(P, V) {                                                                           // 1828\n            var n = V.length - 1;                                                                                      // 1829\n            // use binary search for large convex polygons                                                             // 1830\n            var a, b, c; // indices for edge chain endpoints                                                           // 1831\n            var dnA, dnC; // test for down direction of edges a and c                                                  // 1832\n            // leftmost tangent = minimum for the isLeft() ordering                                                    // 1833\n            // test if V[0] is a local minimum                                                                         // 1834\n            if (above(P, V[n - 1], V[0]) && !below(P, V[1], V[0]))                                                     // 1835\n                return 0; // V[0] is the minimum tangent point                                                         // 1836\n            for (a = 0, b = n;;) {                                                                                     // 1837\n                if (b - a === 1)                                                                                       // 1838\n                    if (below(P, V[a], V[b]))                                                                          // 1839\n                        return a;                                                                                      // 1840\n                    else                                                                                               // 1841\n                        return b;                                                                                      // 1842\n                c = Math.floor((a + b) / 2); // midpoint of [a,b], and 0<c<n                                           // 1843\n                dnC = below(P, V[c + 1], V[c]);                                                                        // 1844\n                if (above(P, V[c - 1], V[c]) && !dnC)                                                                  // 1845\n                    return c; // V[c] is the minimum tangent point                                                     // 1846\n                // no min yet, so continue with the binary search                                                      // 1847\n                // pick one of the two subchains [a,c] or [c,b]                                                        // 1848\n                dnA = below(P, V[a + 1], V[a]);                                                                        // 1849\n                if (dnA) {                                                                                             // 1850\n                    if (!dnC)                                                                                          // 1851\n                        b = c; // select [a,c]                                                                         // 1852\n                    else {                                                                                             // 1853\n                        if (below(P, V[a], V[c]))                                                                      // 1854\n                            b = c; // select [a,c]                                                                     // 1855\n                        else                                                                                           // 1856\n                            a = c; // select [c,b]                                                                     // 1857\n                    }                                                                                                  // 1858\n                }                                                                                                      // 1859\n                else {                                                                                                 // 1860\n                    if (dnC)                                                                                           // 1861\n                        a = c; // select [c,b]                                                                         // 1862\n                    else {                                                                                             // 1863\n                        if (above(P, V[a], V[c]))                                                                      // 1864\n                            b = c; // select [a,c]                                                                     // 1865\n                        else                                                                                           // 1866\n                            a = c; // select [c,b]                                                                     // 1867\n                    }                                                                                                  // 1868\n                }                                                                                                      // 1869\n            }                                                                                                          // 1870\n        }                                                                                                              // 1871\n        // RLtangent_PolyPolyC(): get the RL tangent between two convex polygons                                       // 1872\n        //    Input:  m = number of vertices in polygon 1                                                              // 1873\n        //            V = array of vertices for convex polygon 1 with V[m]=V[0]                                        // 1874\n        //            n = number of vertices in polygon 2                                                              // 1875\n        //            W = array of vertices for convex polygon 2 with W[n]=W[0]                                        // 1876\n        //    Output: *t1 = index of tangent point V[t1] for polygon 1                                                 // 1877\n        //            *t2 = index of tangent point W[t2] for polygon 2                                                 // 1878\n        function tangent_PolyPolyC(V, W, t1, t2, cmp1, cmp2) {                                                         // 1879\n            var ix1, ix2; // search indices for polygons 1 and 2                                                       // 1880\n            // first get the initial vertex on each polygon                                                            // 1881\n            ix1 = t1(W[0], V); // right tangent from W[0] to V                                                         // 1882\n            ix2 = t2(V[ix1], W); // left tangent from V[ix1] to W                                                      // 1883\n            // ping-pong linear search until it stabilizes                                                             // 1884\n            var done = false; // flag when done                                                                        // 1885\n            while (!done) {                                                                                            // 1886\n                done = true; // assume done until...                                                                   // 1887\n                while (true) {                                                                                         // 1888\n                    if (ix1 === V.length - 1)                                                                          // 1889\n                        ix1 = 0;                                                                                       // 1890\n                    if (cmp1(W[ix2], V[ix1], V[ix1 + 1]))                                                              // 1891\n                        break;                                                                                         // 1892\n                    ++ix1; // get Rtangent from W[ix2] to V                                                            // 1893\n                }                                                                                                      // 1894\n                while (true) {                                                                                         // 1895\n                    if (ix2 === 0)                                                                                     // 1896\n                        ix2 = W.length - 1;                                                                            // 1897\n                    if (cmp2(V[ix1], W[ix2], W[ix2 - 1]))                                                              // 1898\n                        break;                                                                                         // 1899\n                    --ix2; // get Ltangent from V[ix1] to W                                                            // 1900\n                    done = false; // not done if had to adjust this                                                    // 1901\n                }                                                                                                      // 1902\n            }                                                                                                          // 1903\n            return { t1: ix1, t2: ix2 };                                                                               // 1904\n        }                                                                                                              // 1905\n        geom.tangent_PolyPolyC = tangent_PolyPolyC;                                                                    // 1906\n        function LRtangent_PolyPolyC(V, W) {                                                                           // 1907\n            var rl = RLtangent_PolyPolyC(W, V);                                                                        // 1908\n            return { t1: rl.t2, t2: rl.t1 };                                                                           // 1909\n        }                                                                                                              // 1910\n        geom.LRtangent_PolyPolyC = LRtangent_PolyPolyC;                                                                // 1911\n        function RLtangent_PolyPolyC(V, W) {                                                                           // 1912\n            return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above, below);                    // 1913\n        }                                                                                                              // 1914\n        geom.RLtangent_PolyPolyC = RLtangent_PolyPolyC;                                                                // 1915\n        function LLtangent_PolyPolyC(V, W) {                                                                           // 1916\n            return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);                    // 1917\n        }                                                                                                              // 1918\n        geom.LLtangent_PolyPolyC = LLtangent_PolyPolyC;                                                                // 1919\n        function RRtangent_PolyPolyC(V, W) {                                                                           // 1920\n            return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above, above);                    // 1921\n        }                                                                                                              // 1922\n        geom.RRtangent_PolyPolyC = RRtangent_PolyPolyC;                                                                // 1923\n        var BiTangent = (function () {                                                                                 // 1924\n            function BiTangent(t1, t2) {                                                                               // 1925\n                this.t1 = t1;                                                                                          // 1926\n                this.t2 = t2;                                                                                          // 1927\n            }                                                                                                          // 1928\n            return BiTangent;                                                                                          // 1929\n        })();                                                                                                          // 1930\n        geom.BiTangent = BiTangent;                                                                                    // 1931\n        var BiTangents = (function () {                                                                                // 1932\n            function BiTangents() {                                                                                    // 1933\n            }                                                                                                          // 1934\n            return BiTangents;                                                                                         // 1935\n        })();                                                                                                          // 1936\n        geom.BiTangents = BiTangents;                                                                                  // 1937\n        var TVGPoint = (function (_super) {                                                                            // 1938\n            __extends(TVGPoint, _super);                                                                               // 1939\n            function TVGPoint() {                                                                                      // 1940\n                _super.apply(this, arguments);                                                                         // 1941\n            }                                                                                                          // 1942\n            return TVGPoint;                                                                                           // 1943\n        })(Point);                                                                                                     // 1944\n        geom.TVGPoint = TVGPoint;                                                                                      // 1945\n        var VisibilityVertex = (function () {                                                                          // 1946\n            function VisibilityVertex(id, polyid, polyvertid, p) {                                                     // 1947\n                this.id = id;                                                                                          // 1948\n                this.polyid = polyid;                                                                                  // 1949\n                this.polyvertid = polyvertid;                                                                          // 1950\n                this.p = p;                                                                                            // 1951\n                p.vv = this;                                                                                           // 1952\n            }                                                                                                          // 1953\n            return VisibilityVertex;                                                                                   // 1954\n        })();                                                                                                          // 1955\n        geom.VisibilityVertex = VisibilityVertex;                                                                      // 1956\n        var VisibilityEdge = (function () {                                                                            // 1957\n            function VisibilityEdge(source, target) {                                                                  // 1958\n                this.source = source;                                                                                  // 1959\n                this.target = target;                                                                                  // 1960\n            }                                                                                                          // 1961\n            VisibilityEdge.prototype.length = function () {                                                            // 1962\n                var dx = this.source.p.x - this.target.p.x;                                                            // 1963\n                var dy = this.source.p.y - this.target.p.y;                                                            // 1964\n                return Math.sqrt(dx * dx + dy * dy);                                                                   // 1965\n            };                                                                                                         // 1966\n            return VisibilityEdge;                                                                                     // 1967\n        })();                                                                                                          // 1968\n        geom.VisibilityEdge = VisibilityEdge;                                                                          // 1969\n        var TangentVisibilityGraph = (function () {                                                                    // 1970\n            function TangentVisibilityGraph(P, g0) {                                                                   // 1971\n                this.P = P;                                                                                            // 1972\n                this.V = [];                                                                                           // 1973\n                this.E = [];                                                                                           // 1974\n                if (!g0) {                                                                                             // 1975\n                    var n = P.length;                                                                                  // 1976\n                    for (var i = 0; i < n; i++) {                                                                      // 1977\n                        var p = P[i];                                                                                  // 1978\n                        for (var j = 0; j < p.length; ++j) {                                                           // 1979\n                            var pj = p[j], vv = new VisibilityVertex(this.V.length, i, j, pj);                         // 1980\n                            this.V.push(vv);                                                                           // 1981\n                            if (j > 0)                                                                                 // 1982\n                                this.E.push(new VisibilityEdge(p[j - 1].vv, vv));                                      // 1983\n                        }                                                                                              // 1984\n                    }                                                                                                  // 1985\n                    for (var i = 0; i < n - 1; i++) {                                                                  // 1986\n                        var Pi = P[i];                                                                                 // 1987\n                        for (var j = i + 1; j < n; j++) {                                                              // 1988\n                            var Pj = P[j], t = geom.tangents(Pi, Pj);                                                  // 1989\n                            for (var q in t) {                                                                         // 1990\n                                var c = t[q], source = Pi[c.t1], target = Pj[c.t2];                                    // 1991\n                                this.addEdgeIfVisible(source, target, i, j);                                           // 1992\n                            }                                                                                          // 1993\n                        }                                                                                              // 1994\n                    }                                                                                                  // 1995\n                }                                                                                                      // 1996\n                else {                                                                                                 // 1997\n                    this.V = g0.V.slice(0);                                                                            // 1998\n                    this.E = g0.E.slice(0);                                                                            // 1999\n                }                                                                                                      // 2000\n            }                                                                                                          // 2001\n            TangentVisibilityGraph.prototype.addEdgeIfVisible = function (u, v, i1, i2) {                              // 2002\n                if (!this.intersectsPolys(new LineSegment(u.x, u.y, v.x, v.y), i1, i2)) {                              // 2003\n                    this.E.push(new VisibilityEdge(u.vv, v.vv));                                                       // 2004\n                }                                                                                                      // 2005\n            };                                                                                                         // 2006\n            TangentVisibilityGraph.prototype.addPoint = function (p, i1) {                                             // 2007\n                var n = this.P.length;                                                                                 // 2008\n                this.V.push(new VisibilityVertex(this.V.length, n, 0, p));                                             // 2009\n                for (var i = 0; i < n; ++i) {                                                                          // 2010\n                    if (i === i1)                                                                                      // 2011\n                        continue;                                                                                      // 2012\n                    var poly = this.P[i], t = tangent_PointPolyC(p, poly);                                             // 2013\n                    this.addEdgeIfVisible(p, poly[t.ltan], i1, i);                                                     // 2014\n                    this.addEdgeIfVisible(p, poly[t.rtan], i1, i);                                                     // 2015\n                }                                                                                                      // 2016\n                return p.vv;                                                                                           // 2017\n            };                                                                                                         // 2018\n            TangentVisibilityGraph.prototype.intersectsPolys = function (l, i1, i2) {                                  // 2019\n                for (var i = 0, n = this.P.length; i < n; ++i) {                                                       // 2020\n                    if (i != i1 && i != i2 && intersects(l, this.P[i]).length > 0) {                                   // 2021\n                        return true;                                                                                   // 2022\n                    }                                                                                                  // 2023\n                }                                                                                                      // 2024\n                return false;                                                                                          // 2025\n            };                                                                                                         // 2026\n            return TangentVisibilityGraph;                                                                             // 2027\n        })();                                                                                                          // 2028\n        geom.TangentVisibilityGraph = TangentVisibilityGraph;                                                          // 2029\n        function intersects(l, P) {                                                                                    // 2030\n            var ints = [];                                                                                             // 2031\n            for (var i = 1, n = P.length; i < n; ++i) {                                                                // 2032\n                var int = cola.vpsc.Rectangle.lineIntersection(l.x1, l.y1, l.x2, l.y2, P[i - 1].x, P[i - 1].y, P[i].x, P[i].y);\n                if (int)                                                                                               // 2034\n                    ints.push(int);                                                                                    // 2035\n            }                                                                                                          // 2036\n            return ints;                                                                                               // 2037\n        }                                                                                                              // 2038\n        function tangents(V, W) {                                                                                      // 2039\n            var m = V.length - 1, n = W.length - 1;                                                                    // 2040\n            var bt = new BiTangents();                                                                                 // 2041\n            for (var i = 0; i < m; ++i) {                                                                              // 2042\n                for (var j = 0; j < n; ++j) {                                                                          // 2043\n                    var v1 = V[i == 0 ? m - 1 : i - 1];                                                                // 2044\n                    var v2 = V[i];                                                                                     // 2045\n                    var v3 = V[i + 1];                                                                                 // 2046\n                    var w1 = W[j == 0 ? n - 1 : j - 1];                                                                // 2047\n                    var w2 = W[j];                                                                                     // 2048\n                    var w3 = W[j + 1];                                                                                 // 2049\n                    var v1v2w2 = isLeft(v1, v2, w2);                                                                   // 2050\n                    var v2w1w2 = isLeft(v2, w1, w2);                                                                   // 2051\n                    var v2w2w3 = isLeft(v2, w2, w3);                                                                   // 2052\n                    var w1w2v2 = isLeft(w1, w2, v2);                                                                   // 2053\n                    var w2v1v2 = isLeft(w2, v1, v2);                                                                   // 2054\n                    var w2v2v3 = isLeft(w2, v2, v3);                                                                   // 2055\n                    if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0                                                       // 2056\n                        && w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {                                                 // 2057\n                        bt.ll = new BiTangent(i, j);                                                                   // 2058\n                    }                                                                                                  // 2059\n                    else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0                                                  // 2060\n                        && w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {                                                 // 2061\n                        bt.rr = new BiTangent(i, j);                                                                   // 2062\n                    }                                                                                                  // 2063\n                    else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0                                                  // 2064\n                        && w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {                                                 // 2065\n                        bt.rl = new BiTangent(i, j);                                                                   // 2066\n                    }                                                                                                  // 2067\n                    else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0                                                  // 2068\n                        && w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {                                                 // 2069\n                        bt.lr = new BiTangent(i, j);                                                                   // 2070\n                    }                                                                                                  // 2071\n                }                                                                                                      // 2072\n            }                                                                                                          // 2073\n            return bt;                                                                                                 // 2074\n        }                                                                                                              // 2075\n        geom.tangents = tangents;                                                                                      // 2076\n        function isPointInsidePoly(p, poly) {                                                                          // 2077\n            for (var i = 1, n = poly.length; i < n; ++i)                                                               // 2078\n                if (below(poly[i - 1], poly[i], p))                                                                    // 2079\n                    return false;                                                                                      // 2080\n            return true;                                                                                               // 2081\n        }                                                                                                              // 2082\n        function isAnyPInQ(p, q) {                                                                                     // 2083\n            return !p.every(function (v) { return !isPointInsidePoly(v, q); });                                        // 2084\n        }                                                                                                              // 2085\n        function polysOverlap(p, q) {                                                                                  // 2086\n            if (isAnyPInQ(p, q))                                                                                       // 2087\n                return true;                                                                                           // 2088\n            if (isAnyPInQ(q, p))                                                                                       // 2089\n                return true;                                                                                           // 2090\n            for (var i = 1, n = p.length; i < n; ++i) {                                                                // 2091\n                var v = p[i], u = p[i - 1];                                                                            // 2092\n                if (intersects(new LineSegment(u.x, u.y, v.x, v.y), q).length > 0)                                     // 2093\n                    return true;                                                                                       // 2094\n            }                                                                                                          // 2095\n            return false;                                                                                              // 2096\n        }                                                                                                              // 2097\n        geom.polysOverlap = polysOverlap;                                                                              // 2098\n    })(geom = cola.geom || (cola.geom = {}));                                                                          // 2099\n})(cola || (cola = {}));                                                                                               // 2100\n/**                                                                                                                    // 2101\n * @module cola                                                                                                        // 2102\n */                                                                                                                    // 2103\nvar cola;                                                                                                              // 2104\n(function (cola) {                                                                                                     // 2105\n    /**                                                                                                                // 2106\n     * Descent respects a collection of locks over nodes that should not move                                          // 2107\n     * @class Locks                                                                                                    // 2108\n     */                                                                                                                // 2109\n    var Locks = (function () {                                                                                         // 2110\n        function Locks() {                                                                                             // 2111\n            this.locks = {};                                                                                           // 2112\n        }                                                                                                              // 2113\n        /**                                                                                                            // 2114\n         * add a lock on the node at index id                                                                          // 2115\n         * @method add                                                                                                 // 2116\n         * @param id index of node to be locked                                                                        // 2117\n         * @param x required position for node                                                                         // 2118\n         */                                                                                                            // 2119\n        Locks.prototype.add = function (id, x) {                                                                       // 2120\n            /* DEBUG                                                                                                   // 2121\n                        if (isNaN(x[0]) || isNaN(x[1])) debugger;                                                      // 2122\n            DEBUG */                                                                                                   // 2123\n            this.locks[id] = x;                                                                                        // 2124\n        };                                                                                                             // 2125\n        /**                                                                                                            // 2126\n         * @method clear clear all locks                                                                               // 2127\n         */                                                                                                            // 2128\n        Locks.prototype.clear = function () {                                                                          // 2129\n            this.locks = {};                                                                                           // 2130\n        };                                                                                                             // 2131\n        /**                                                                                                            // 2132\n         * @isEmpty                                                                                                    // 2133\n         * @returns false if no locks exist                                                                            // 2134\n         */                                                                                                            // 2135\n        Locks.prototype.isEmpty = function () {                                                                        // 2136\n            for (var l in this.locks)                                                                                  // 2137\n                return false;                                                                                          // 2138\n            return true;                                                                                               // 2139\n        };                                                                                                             // 2140\n        /**                                                                                                            // 2141\n         * perform an operation on each lock                                                                           // 2142\n         * @apply                                                                                                      // 2143\n         */                                                                                                            // 2144\n        Locks.prototype.apply = function (f) {                                                                         // 2145\n            for (var l in this.locks) {                                                                                // 2146\n                f(l, this.locks[l]);                                                                                   // 2147\n            }                                                                                                          // 2148\n        };                                                                                                             // 2149\n        return Locks;                                                                                                  // 2150\n    })();                                                                                                              // 2151\n    cola.Locks = Locks;                                                                                                // 2152\n    /**                                                                                                                // 2153\n     * Uses a gradient descent approach to reduce a stress or p-stress goal function over a graph with specified ideal edge lengths or a square matrix of dissimilarities.\n     * The standard stress function over a graph nodes with position vectors x,y,z is (mathematica input):             // 2155\n     *   stress[x_,y_,z_,D_,w_]:=Sum[w[[i,j]] (length[x[[i]],y[[i]],z[[i]],x[[j]],y[[j]],z[[j]]]-d[[i,j]])^2,{i,Length[x]-1},{j,i+1,Length[x]}]\n     * where: D is a square matrix of ideal separations between nodes, w is matrix of weights for those separations    // 2157\n     *        length[x1_, y1_, z1_, x2_, y2_, z2_] = Sqrt[(x1 - x2)^2 + (y1 - y2)^2 + (z1 - z2)^2]                     // 2158\n     * below, we use wij = 1/(Dij^2)                                                                                   // 2159\n     *                                                                                                                 // 2160\n     * @class Descent                                                                                                  // 2161\n     */                                                                                                                // 2162\n    var Descent = (function () {                                                                                       // 2163\n        /**                                                                                                            // 2164\n         * @method constructor                                                                                         // 2165\n         * @param x {number[][]} initial coordinates for nodes                                                         // 2166\n         * @param D {number[][]} matrix of desired distances between pairs of nodes                                    // 2167\n         * @param G {number[][]} [default=null] if specified, G is a matrix of weights for goal terms between pairs of nodes.\n         * If G[i][j] > 1 and the separation between nodes i and j is greater than their ideal distance, then there is no contribution for this pair to the goal\n         * If G[i][j] <= 1 then it is used as a weighting on the contribution of the variance between ideal and actual separation between i and j to the goal function\n         */                                                                                                            // 2171\n        function Descent(x, D, G) {                                                                                    // 2172\n            if (G === void 0) { G = null; }                                                                            // 2173\n            this.D = D;                                                                                                // 2174\n            this.G = G;                                                                                                // 2175\n            this.threshold = 0.0001;                                                                                   // 2176\n            // Parameters for grid snap stress.                                                                        // 2177\n            // TODO: Make a pluggable \"StressTerm\" class instead of this                                               // 2178\n            // mess.                                                                                                   // 2179\n            this.numGridSnapNodes = 0;                                                                                 // 2180\n            this.snapGridSize = 100;                                                                                   // 2181\n            this.snapStrength = 1000;                                                                                  // 2182\n            this.scaleSnapByMaxH = false;                                                                              // 2183\n            this.random = new PseudoRandom();                                                                          // 2184\n            this.project = null;                                                                                       // 2185\n            this.x = x;                                                                                                // 2186\n            this.k = x.length; // dimensionality                                                                       // 2187\n            var n = this.n = x[0].length; // number of nodes                                                           // 2188\n            this.H = new Array(this.k);                                                                                // 2189\n            this.g = new Array(this.k);                                                                                // 2190\n            this.Hd = new Array(this.k);                                                                               // 2191\n            this.a = new Array(this.k);                                                                                // 2192\n            this.b = new Array(this.k);                                                                                // 2193\n            this.c = new Array(this.k);                                                                                // 2194\n            this.d = new Array(this.k);                                                                                // 2195\n            this.e = new Array(this.k);                                                                                // 2196\n            this.ia = new Array(this.k);                                                                               // 2197\n            this.ib = new Array(this.k);                                                                               // 2198\n            this.xtmp = new Array(this.k);                                                                             // 2199\n            this.locks = new Locks();                                                                                  // 2200\n            this.minD = Number.MAX_VALUE;                                                                              // 2201\n            var i = n, j;                                                                                              // 2202\n            while (i--) {                                                                                              // 2203\n                j = n;                                                                                                 // 2204\n                while (--j > i) {                                                                                      // 2205\n                    var d = D[i][j];                                                                                   // 2206\n                    if (d > 0 && d < this.minD) {                                                                      // 2207\n                        this.minD = d;                                                                                 // 2208\n                    }                                                                                                  // 2209\n                }                                                                                                      // 2210\n            }                                                                                                          // 2211\n            if (this.minD === Number.MAX_VALUE)                                                                        // 2212\n                this.minD = 1;                                                                                         // 2213\n            i = this.k;                                                                                                // 2214\n            while (i--) {                                                                                              // 2215\n                this.g[i] = new Array(n);                                                                              // 2216\n                this.H[i] = new Array(n);                                                                              // 2217\n                j = n;                                                                                                 // 2218\n                while (j--) {                                                                                          // 2219\n                    this.H[i][j] = new Array(n);                                                                       // 2220\n                }                                                                                                      // 2221\n                this.Hd[i] = new Array(n);                                                                             // 2222\n                this.a[i] = new Array(n);                                                                              // 2223\n                this.b[i] = new Array(n);                                                                              // 2224\n                this.c[i] = new Array(n);                                                                              // 2225\n                this.d[i] = new Array(n);                                                                              // 2226\n                this.e[i] = new Array(n);                                                                              // 2227\n                this.ia[i] = new Array(n);                                                                             // 2228\n                this.ib[i] = new Array(n);                                                                             // 2229\n                this.xtmp[i] = new Array(n);                                                                           // 2230\n            }                                                                                                          // 2231\n        }                                                                                                              // 2232\n        Descent.createSquareMatrix = function (n, f) {                                                                 // 2233\n            var M = new Array(n);                                                                                      // 2234\n            for (var i = 0; i < n; ++i) {                                                                              // 2235\n                M[i] = new Array(n);                                                                                   // 2236\n                for (var j = 0; j < n; ++j) {                                                                          // 2237\n                    M[i][j] = f(i, j);                                                                                 // 2238\n                }                                                                                                      // 2239\n            }                                                                                                          // 2240\n            return M;                                                                                                  // 2241\n        };                                                                                                             // 2242\n        Descent.prototype.offsetDir = function () {                                                                    // 2243\n            var _this = this;                                                                                          // 2244\n            var u = new Array(this.k);                                                                                 // 2245\n            var l = 0;                                                                                                 // 2246\n            for (var i = 0; i < this.k; ++i) {                                                                         // 2247\n                var x = u[i] = this.random.getNextBetween(0.01, 1) - 0.5;                                              // 2248\n                l += x * x;                                                                                            // 2249\n            }                                                                                                          // 2250\n            l = Math.sqrt(l);                                                                                          // 2251\n            return u.map(function (x) { return x *= _this.minD / l; });                                                // 2252\n        };                                                                                                             // 2253\n        // compute first and second derivative information storing results in this.g and this.H                        // 2254\n        Descent.prototype.computeDerivatives = function (x) {                                                          // 2255\n            var _this = this;                                                                                          // 2256\n            var n = this.n;                                                                                            // 2257\n            if (n < 1)                                                                                                 // 2258\n                return;                                                                                                // 2259\n            var i;                                                                                                     // 2260\n            /* DEBUG                                                                                                   // 2261\n                        for (var u: number = 0; u < n; ++u)                                                            // 2262\n                            for (i = 0; i < this.k; ++i)                                                               // 2263\n                                if (isNaN(x[i][u])) debugger;                                                          // 2264\n            DEBUG */                                                                                                   // 2265\n            var d = new Array(this.k);                                                                                 // 2266\n            var d2 = new Array(this.k);                                                                                // 2267\n            var Huu = new Array(this.k);                                                                               // 2268\n            var maxH = 0;                                                                                              // 2269\n            for (var u = 0; u < n; ++u) {                                                                              // 2270\n                for (i = 0; i < this.k; ++i)                                                                           // 2271\n                    Huu[i] = this.g[i][u] = 0;                                                                         // 2272\n                for (var v = 0; v < n; ++v) {                                                                          // 2273\n                    if (u === v)                                                                                       // 2274\n                        continue;                                                                                      // 2275\n                    // The following loop randomly displaces nodes that are at identical positions                     // 2276\n                    var maxDisplaces = n; // avoid infinite loop in the case of numerical issues, such as huge values  // 2277\n                    while (maxDisplaces--) {                                                                           // 2278\n                        var sd2 = 0;                                                                                   // 2279\n                        for (i = 0; i < this.k; ++i) {                                                                 // 2280\n                            var dx = d[i] = x[i][u] - x[i][v];                                                         // 2281\n                            sd2 += d2[i] = dx * dx;                                                                    // 2282\n                        }                                                                                              // 2283\n                        if (sd2 > 1e-9)                                                                                // 2284\n                            break;                                                                                     // 2285\n                        var rd = this.offsetDir();                                                                     // 2286\n                        for (i = 0; i < this.k; ++i)                                                                   // 2287\n                            x[i][v] += rd[i];                                                                          // 2288\n                    }                                                                                                  // 2289\n                    var l = Math.sqrt(sd2);                                                                            // 2290\n                    var D = this.D[u][v];                                                                              // 2291\n                    var weight = this.G != null ? this.G[u][v] : 1;                                                    // 2292\n                    if (weight > 1 && l > D || !isFinite(D)) {                                                         // 2293\n                        for (i = 0; i < this.k; ++i)                                                                   // 2294\n                            this.H[i][u][v] = 0;                                                                       // 2295\n                        continue;                                                                                      // 2296\n                    }                                                                                                  // 2297\n                    if (weight > 1) {                                                                                  // 2298\n                        weight = 1;                                                                                    // 2299\n                    }                                                                                                  // 2300\n                    var D2 = D * D;                                                                                    // 2301\n                    var gs = 2 * weight * (l - D) / (D2 * l);                                                          // 2302\n                    var l3 = l * l * l;                                                                                // 2303\n                    var hs = 2 * -weight / (D2 * l3);                                                                  // 2304\n                    if (!isFinite(gs))                                                                                 // 2305\n                        console.log(gs);                                                                               // 2306\n                    for (i = 0; i < this.k; ++i) {                                                                     // 2307\n                        this.g[i][u] += d[i] * gs;                                                                     // 2308\n                        Huu[i] -= this.H[i][u][v] = hs * (l3 + D * (d2[i] - sd2) + l * sd2);                           // 2309\n                    }                                                                                                  // 2310\n                }                                                                                                      // 2311\n                for (i = 0; i < this.k; ++i)                                                                           // 2312\n                    maxH = Math.max(maxH, this.H[i][u][u] = Huu[i]);                                                   // 2313\n            }                                                                                                          // 2314\n            // Grid snap forces                                                                                        // 2315\n            var r = this.snapGridSize / 2;                                                                             // 2316\n            var g = this.snapGridSize;                                                                                 // 2317\n            var w = this.snapStrength;                                                                                 // 2318\n            var k = w / (r * r);                                                                                       // 2319\n            var numNodes = this.numGridSnapNodes;                                                                      // 2320\n            //var numNodes = n;                                                                                        // 2321\n            for (var u = 0; u < numNodes; ++u) {                                                                       // 2322\n                for (i = 0; i < this.k; ++i) {                                                                         // 2323\n                    var xiu = this.x[i][u];                                                                            // 2324\n                    var m = xiu / g;                                                                                   // 2325\n                    var f = m % 1;                                                                                     // 2326\n                    var q = m - f;                                                                                     // 2327\n                    var a = Math.abs(f);                                                                               // 2328\n                    var dx = (a <= 0.5) ? xiu - q * g :                                                                // 2329\n                        (xiu > 0) ? xiu - (q + 1) * g : xiu - (q - 1) * g;                                             // 2330\n                    if (-r < dx && dx <= r) {                                                                          // 2331\n                        if (this.scaleSnapByMaxH) {                                                                    // 2332\n                            this.g[i][u] += maxH * k * dx;                                                             // 2333\n                            this.H[i][u][u] += maxH * k;                                                               // 2334\n                        }                                                                                              // 2335\n                        else {                                                                                         // 2336\n                            this.g[i][u] += k * dx;                                                                    // 2337\n                            this.H[i][u][u] += k;                                                                      // 2338\n                        }                                                                                              // 2339\n                    }                                                                                                  // 2340\n                }                                                                                                      // 2341\n            }                                                                                                          // 2342\n            if (!this.locks.isEmpty()) {                                                                               // 2343\n                this.locks.apply(function (u, p) {                                                                     // 2344\n                    for (i = 0; i < _this.k; ++i) {                                                                    // 2345\n                        _this.H[i][u][u] += maxH;                                                                      // 2346\n                        _this.g[i][u] -= maxH * (p[i] - x[i][u]);                                                      // 2347\n                    }                                                                                                  // 2348\n                });                                                                                                    // 2349\n            }                                                                                                          // 2350\n            /* DEBUG                                                                                                   // 2351\n                        for (var u: number = 0; u < n; ++u)                                                            // 2352\n                            for (i = 0; i < this.k; ++i) {                                                             // 2353\n                                if (isNaN(this.g[i][u])) debugger;                                                     // 2354\n                                for (var v: number = 0; v < n; ++v)                                                    // 2355\n                                    if (isNaN(this.H[i][u][v])) debugger;                                              // 2356\n                            }                                                                                          // 2357\n            DEBUG */                                                                                                   // 2358\n        };                                                                                                             // 2359\n        Descent.dotProd = function (a, b) {                                                                            // 2360\n            var x = 0, i = a.length;                                                                                   // 2361\n            while (i--)                                                                                                // 2362\n                x += a[i] * b[i];                                                                                      // 2363\n            return x;                                                                                                  // 2364\n        };                                                                                                             // 2365\n        // result r = matrix m * vector v                                                                              // 2366\n        Descent.rightMultiply = function (m, v, r) {                                                                   // 2367\n            var i = m.length;                                                                                          // 2368\n            while (i--)                                                                                                // 2369\n                r[i] = Descent.dotProd(m[i], v);                                                                       // 2370\n        };                                                                                                             // 2371\n        // computes the optimal step size to take in direction d using the                                             // 2372\n        // derivative information in this.g and this.H                                                                 // 2373\n        // returns the scalar multiplier to apply to d to get the optimal step                                         // 2374\n        Descent.prototype.computeStepSize = function (d) {                                                             // 2375\n            var numerator = 0, denominator = 0;                                                                        // 2376\n            for (var i = 0; i < this.k; ++i) {                                                                         // 2377\n                numerator += Descent.dotProd(this.g[i], d[i]);                                                         // 2378\n                Descent.rightMultiply(this.H[i], d[i], this.Hd[i]);                                                    // 2379\n                denominator += Descent.dotProd(d[i], this.Hd[i]);                                                      // 2380\n            }                                                                                                          // 2381\n            if (denominator === 0 || !isFinite(denominator))                                                           // 2382\n                return 0;                                                                                              // 2383\n            return 1 * numerator / denominator;                                                                        // 2384\n        };                                                                                                             // 2385\n        Descent.prototype.reduceStress = function () {                                                                 // 2386\n            this.computeDerivatives(this.x);                                                                           // 2387\n            var alpha = this.computeStepSize(this.g);                                                                  // 2388\n            for (var i = 0; i < this.k; ++i) {                                                                         // 2389\n                this.takeDescentStep(this.x[i], this.g[i], alpha);                                                     // 2390\n            }                                                                                                          // 2391\n            return this.computeStress();                                                                               // 2392\n        };                                                                                                             // 2393\n        Descent.copy = function (a, b) {                                                                               // 2394\n            var m = a.length, n = b[0].length;                                                                         // 2395\n            for (var i = 0; i < m; ++i) {                                                                              // 2396\n                for (var j = 0; j < n; ++j) {                                                                          // 2397\n                    b[i][j] = a[i][j];                                                                                 // 2398\n                }                                                                                                      // 2399\n            }                                                                                                          // 2400\n        };                                                                                                             // 2401\n        // takes a step of stepSize * d from x0, and then project against any constraints.                             // 2402\n        // result is returned in r.                                                                                    // 2403\n        // x0: starting positions                                                                                      // 2404\n        // r: result positions will be returned here                                                                   // 2405\n        // d: unconstrained descent vector                                                                             // 2406\n        // stepSize: amount to step along d                                                                            // 2407\n        Descent.prototype.stepAndProject = function (x0, r, d, stepSize) {                                             // 2408\n            Descent.copy(x0, r);                                                                                       // 2409\n            this.takeDescentStep(r[0], d[0], stepSize);                                                                // 2410\n            if (this.project)                                                                                          // 2411\n                this.project[0](x0[0], x0[1], r[0]);                                                                   // 2412\n            this.takeDescentStep(r[1], d[1], stepSize);                                                                // 2413\n            if (this.project)                                                                                          // 2414\n                this.project[1](r[0], x0[1], r[1]);                                                                    // 2415\n            // todo: allow projection against constraints in higher dimensions                                         // 2416\n            for (var i = 2; i < this.k; i++)                                                                           // 2417\n                this.takeDescentStep(r[i], d[i], stepSize);                                                            // 2418\n            // the following makes locks extra sticky... but hides the result of the projection from the consumer      // 2419\n            //if (!this.locks.isEmpty()) {                                                                             // 2420\n            //    this.locks.apply((u, p) => {                                                                         // 2421\n            //        for (var i = 0; i < this.k; i++) {                                                               // 2422\n            //            r[i][u] = p[i];                                                                              // 2423\n            //        }                                                                                                // 2424\n            //    });                                                                                                  // 2425\n            //}                                                                                                        // 2426\n        };                                                                                                             // 2427\n        Descent.mApply = function (m, n, f) {                                                                          // 2428\n            var i = m;                                                                                                 // 2429\n            while (i-- > 0) {                                                                                          // 2430\n                var j = n;                                                                                             // 2431\n                while (j-- > 0)                                                                                        // 2432\n                    f(i, j);                                                                                           // 2433\n            }                                                                                                          // 2434\n        };                                                                                                             // 2435\n        Descent.prototype.matrixApply = function (f) {                                                                 // 2436\n            Descent.mApply(this.k, this.n, f);                                                                         // 2437\n        };                                                                                                             // 2438\n        Descent.prototype.computeNextPosition = function (x0, r) {                                                     // 2439\n            var _this = this;                                                                                          // 2440\n            this.computeDerivatives(x0);                                                                               // 2441\n            var alpha = this.computeStepSize(this.g);                                                                  // 2442\n            this.stepAndProject(x0, r, this.g, alpha);                                                                 // 2443\n            /* DEBUG                                                                                                   // 2444\n                        for (var u: number = 0; u < this.n; ++u)                                                       // 2445\n                            for (var i = 0; i < this.k; ++i)                                                           // 2446\n                                if (isNaN(r[i][u])) debugger;                                                          // 2447\n            DEBUG */                                                                                                   // 2448\n            if (this.project) {                                                                                        // 2449\n                this.matrixApply(function (i, j) { return _this.e[i][j] = x0[i][j] - r[i][j]; });                      // 2450\n                var beta = this.computeStepSize(this.e);                                                               // 2451\n                beta = Math.max(0.2, Math.min(beta, 1));                                                               // 2452\n                this.stepAndProject(x0, r, this.e, beta);                                                              // 2453\n            }                                                                                                          // 2454\n        };                                                                                                             // 2455\n        Descent.prototype.run = function (iterations) {                                                                // 2456\n            var stress = Number.MAX_VALUE, converged = false;                                                          // 2457\n            while (!converged && iterations-- > 0) {                                                                   // 2458\n                var s = this.rungeKutta();                                                                             // 2459\n                converged = Math.abs(stress / s - 1) < this.threshold;                                                 // 2460\n                stress = s;                                                                                            // 2461\n            }                                                                                                          // 2462\n            return stress;                                                                                             // 2463\n        };                                                                                                             // 2464\n        Descent.prototype.rungeKutta = function () {                                                                   // 2465\n            var _this = this;                                                                                          // 2466\n            this.computeNextPosition(this.x, this.a);                                                                  // 2467\n            Descent.mid(this.x, this.a, this.ia);                                                                      // 2468\n            this.computeNextPosition(this.ia, this.b);                                                                 // 2469\n            Descent.mid(this.x, this.b, this.ib);                                                                      // 2470\n            this.computeNextPosition(this.ib, this.c);                                                                 // 2471\n            this.computeNextPosition(this.c, this.d);                                                                  // 2472\n            var disp = 0;                                                                                              // 2473\n            this.matrixApply(function (i, j) {                                                                         // 2474\n                var x = (_this.a[i][j] + 2.0 * _this.b[i][j] + 2.0 * _this.c[i][j] + _this.d[i][j]) / 6.0, d = _this.x[i][j] - x;\n                disp += d * d;                                                                                         // 2476\n                _this.x[i][j] = x;                                                                                     // 2477\n            });                                                                                                        // 2478\n            return disp;                                                                                               // 2479\n        };                                                                                                             // 2480\n        Descent.mid = function (a, b, m) {                                                                             // 2481\n            Descent.mApply(a.length, a[0].length, function (i, j) {                                                    // 2482\n                return m[i][j] = a[i][j] + (b[i][j] - a[i][j]) / 2.0;                                                  // 2483\n            });                                                                                                        // 2484\n        };                                                                                                             // 2485\n        Descent.prototype.takeDescentStep = function (x, d, stepSize) {                                                // 2486\n            for (var i = 0; i < this.n; ++i) {                                                                         // 2487\n                x[i] = x[i] - stepSize * d[i];                                                                         // 2488\n            }                                                                                                          // 2489\n        };                                                                                                             // 2490\n        Descent.prototype.computeStress = function () {                                                                // 2491\n            var stress = 0;                                                                                            // 2492\n            for (var u = 0, nMinus1 = this.n - 1; u < nMinus1; ++u) {                                                  // 2493\n                for (var v = u + 1, n = this.n; v < n; ++v) {                                                          // 2494\n                    var l = 0;                                                                                         // 2495\n                    for (var i = 0; i < this.k; ++i) {                                                                 // 2496\n                        var dx = this.x[i][u] - this.x[i][v];                                                          // 2497\n                        l += dx * dx;                                                                                  // 2498\n                    }                                                                                                  // 2499\n                    l = Math.sqrt(l);                                                                                  // 2500\n                    var d = this.D[u][v];                                                                              // 2501\n                    if (!isFinite(d))                                                                                  // 2502\n                        continue;                                                                                      // 2503\n                    var rl = d - l;                                                                                    // 2504\n                    var d2 = d * d;                                                                                    // 2505\n                    stress += rl * rl / d2;                                                                            // 2506\n                }                                                                                                      // 2507\n            }                                                                                                          // 2508\n            return stress;                                                                                             // 2509\n        };                                                                                                             // 2510\n        Descent.zeroDistance = 1e-10;                                                                                  // 2511\n        return Descent;                                                                                                // 2512\n    })();                                                                                                              // 2513\n    cola.Descent = Descent;                                                                                            // 2514\n    // Linear congruential pseudo random number generator                                                              // 2515\n    var PseudoRandom = (function () {                                                                                  // 2516\n        function PseudoRandom(seed) {                                                                                  // 2517\n            if (seed === void 0) { seed = 1; }                                                                         // 2518\n            this.seed = seed;                                                                                          // 2519\n            this.a = 214013;                                                                                           // 2520\n            this.c = 2531011;                                                                                          // 2521\n            this.m = 2147483648;                                                                                       // 2522\n            this.range = 32767;                                                                                        // 2523\n        }                                                                                                              // 2524\n        // random real between 0 and 1                                                                                 // 2525\n        PseudoRandom.prototype.getNext = function () {                                                                 // 2526\n            this.seed = (this.seed * this.a + this.c) % this.m;                                                        // 2527\n            return (this.seed >> 16) / this.range;                                                                     // 2528\n        };                                                                                                             // 2529\n        // random real between min and max                                                                             // 2530\n        PseudoRandom.prototype.getNextBetween = function (min, max) {                                                  // 2531\n            return min + this.getNext() * (max - min);                                                                 // 2532\n        };                                                                                                             // 2533\n        return PseudoRandom;                                                                                           // 2534\n    })();                                                                                                              // 2535\n    cola.PseudoRandom = PseudoRandom;                                                                                  // 2536\n})(cola || (cola = {}));                                                                                               // 2537\nvar cola;                                                                                                              // 2538\n(function (cola) {                                                                                                     // 2539\n    var powergraph;                                                                                                    // 2540\n    (function (powergraph) {                                                                                           // 2541\n        var PowerEdge = (function () {                                                                                 // 2542\n            function PowerEdge(source, target, type) {                                                                 // 2543\n                this.source = source;                                                                                  // 2544\n                this.target = target;                                                                                  // 2545\n                this.type = type;                                                                                      // 2546\n            }                                                                                                          // 2547\n            return PowerEdge;                                                                                          // 2548\n        })();                                                                                                          // 2549\n        powergraph.PowerEdge = PowerEdge;                                                                              // 2550\n        var Configuration = (function () {                                                                             // 2551\n            function Configuration(n, edges, linkAccessor, rootGroup) {                                                // 2552\n                var _this = this;                                                                                      // 2553\n                this.linkAccessor = linkAccessor;                                                                      // 2554\n                this.modules = new Array(n);                                                                           // 2555\n                this.roots = [];                                                                                       // 2556\n                if (rootGroup) {                                                                                       // 2557\n                    this.initModulesFromGroup(rootGroup);                                                              // 2558\n                }                                                                                                      // 2559\n                else {                                                                                                 // 2560\n                    this.roots.push(new ModuleSet());                                                                  // 2561\n                    for (var i = 0; i < n; ++i)                                                                        // 2562\n                        this.roots[0].add(this.modules[i] = new Module(i));                                            // 2563\n                }                                                                                                      // 2564\n                this.R = edges.length;                                                                                 // 2565\n                edges.forEach(function (e) {                                                                           // 2566\n                    var s = _this.modules[linkAccessor.getSourceIndex(e)], t = _this.modules[linkAccessor.getTargetIndex(e)], type = linkAccessor.getType(e);\n                    s.outgoing.add(type, t);                                                                           // 2568\n                    t.incoming.add(type, s);                                                                           // 2569\n                });                                                                                                    // 2570\n            }                                                                                                          // 2571\n            Configuration.prototype.initModulesFromGroup = function (group) {                                          // 2572\n                var moduleSet = new ModuleSet();                                                                       // 2573\n                this.roots.push(moduleSet);                                                                            // 2574\n                for (var i = 0; i < group.leaves.length; ++i) {                                                        // 2575\n                    var node = group.leaves[i];                                                                        // 2576\n                    var module = new Module(node.id);                                                                  // 2577\n                    this.modules[node.id] = module;                                                                    // 2578\n                    moduleSet.add(module);                                                                             // 2579\n                }                                                                                                      // 2580\n                if (group.groups) {                                                                                    // 2581\n                    for (var j = 0; j < group.groups.length; ++j) {                                                    // 2582\n                        var child = group.groups[j];                                                                   // 2583\n                        // Propagate group properties (like padding, stiffness, ...) as module definition so that the generated power graph group will inherit it\n                        var definition = {};                                                                           // 2585\n                        for (var prop in child)                                                                        // 2586\n                            if (prop !== \"leaves\" && prop !== \"groups\" && child.hasOwnProperty(prop))                  // 2587\n                                definition[prop] = child[prop];                                                        // 2588\n                        // Use negative module id to avoid clashes between predefined and generated modules            // 2589\n                        moduleSet.add(new Module(-1 - j, new LinkSets(), new LinkSets(), this.initModulesFromGroup(child), definition));\n                    }                                                                                                  // 2591\n                }                                                                                                      // 2592\n                return moduleSet;                                                                                      // 2593\n            };                                                                                                         // 2594\n            // merge modules a and b keeping track of their power edges and removing the from roots                    // 2595\n            Configuration.prototype.merge = function (a, b, k) {                                                       // 2596\n                if (k === void 0) { k = 0; }                                                                           // 2597\n                var inInt = a.incoming.intersection(b.incoming), outInt = a.outgoing.intersection(b.outgoing);         // 2598\n                var children = new ModuleSet();                                                                        // 2599\n                children.add(a);                                                                                       // 2600\n                children.add(b);                                                                                       // 2601\n                var m = new Module(this.modules.length, outInt, inInt, children);                                      // 2602\n                this.modules.push(m);                                                                                  // 2603\n                var update = function (s, i, o) {                                                                      // 2604\n                    s.forAll(function (ms, linktype) {                                                                 // 2605\n                        ms.forAll(function (n) {                                                                       // 2606\n                            var nls = n[i];                                                                            // 2607\n                            nls.add(linktype, m);                                                                      // 2608\n                            nls.remove(linktype, a);                                                                   // 2609\n                            nls.remove(linktype, b);                                                                   // 2610\n                            a[o].remove(linktype, n);                                                                  // 2611\n                            b[o].remove(linktype, n);                                                                  // 2612\n                        });                                                                                            // 2613\n                    });                                                                                                // 2614\n                };                                                                                                     // 2615\n                update(outInt, \"incoming\", \"outgoing\");                                                                // 2616\n                update(inInt, \"outgoing\", \"incoming\");                                                                 // 2617\n                this.R -= inInt.count() + outInt.count();                                                              // 2618\n                this.roots[k].remove(a);                                                                               // 2619\n                this.roots[k].remove(b);                                                                               // 2620\n                this.roots[k].add(m);                                                                                  // 2621\n                return m;                                                                                              // 2622\n            };                                                                                                         // 2623\n            Configuration.prototype.rootMerges = function (k) {                                                        // 2624\n                if (k === void 0) { k = 0; }                                                                           // 2625\n                var rs = this.roots[k].modules();                                                                      // 2626\n                var n = rs.length;                                                                                     // 2627\n                var merges = new Array(n * (n - 1));                                                                   // 2628\n                var ctr = 0;                                                                                           // 2629\n                for (var i = 0, i_ = n - 1; i < i_; ++i) {                                                             // 2630\n                    for (var j = i + 1; j < n; ++j) {                                                                  // 2631\n                        var a = rs[i], b = rs[j];                                                                      // 2632\n                        merges[ctr] = { id: ctr, nEdges: this.nEdges(a, b), a: a, b: b };                              // 2633\n                        ctr++;                                                                                         // 2634\n                    }                                                                                                  // 2635\n                }                                                                                                      // 2636\n                return merges;                                                                                         // 2637\n            };                                                                                                         // 2638\n            Configuration.prototype.greedyMerge = function () {                                                        // 2639\n                for (var i = 0; i < this.roots.length; ++i) {                                                          // 2640\n                    // Handle single nested module case                                                                // 2641\n                    if (this.roots[i].modules().length < 2)                                                            // 2642\n                        continue;                                                                                      // 2643\n                    // find the merge that allows for the most edges to be removed.  secondary ordering based on arbitrary id (for predictability)\n                    var ms = this.rootMerges(i).sort(function (a, b) { return a.nEdges == b.nEdges ? a.id - b.id : a.nEdges - b.nEdges; });\n                    var m = ms[0];                                                                                     // 2646\n                    if (m.nEdges >= this.R)                                                                            // 2647\n                        continue;                                                                                      // 2648\n                    this.merge(m.a, m.b, i);                                                                           // 2649\n                    return true;                                                                                       // 2650\n                }                                                                                                      // 2651\n            };                                                                                                         // 2652\n            Configuration.prototype.nEdges = function (a, b) {                                                         // 2653\n                var inInt = a.incoming.intersection(b.incoming), outInt = a.outgoing.intersection(b.outgoing);         // 2654\n                return this.R - inInt.count() - outInt.count();                                                        // 2655\n            };                                                                                                         // 2656\n            Configuration.prototype.getGroupHierarchy = function (retargetedEdges) {                                   // 2657\n                var _this = this;                                                                                      // 2658\n                var groups = [];                                                                                       // 2659\n                var root = {};                                                                                         // 2660\n                toGroups(this.roots[0], root, groups);                                                                 // 2661\n                var es = this.allEdges();                                                                              // 2662\n                es.forEach(function (e) {                                                                              // 2663\n                    var a = _this.modules[e.source];                                                                   // 2664\n                    var b = _this.modules[e.target];                                                                   // 2665\n                    retargetedEdges.push(new PowerEdge(typeof a.gid === \"undefined\" ? e.source : groups[a.gid], typeof b.gid === \"undefined\" ? e.target : groups[b.gid], e.type));\n                });                                                                                                    // 2667\n                return groups;                                                                                         // 2668\n            };                                                                                                         // 2669\n            Configuration.prototype.allEdges = function () {                                                           // 2670\n                var es = [];                                                                                           // 2671\n                Configuration.getEdges(this.roots[0], es);                                                             // 2672\n                return es;                                                                                             // 2673\n            };                                                                                                         // 2674\n            Configuration.getEdges = function (modules, es) {                                                          // 2675\n                modules.forAll(function (m) {                                                                          // 2676\n                    m.getEdges(es);                                                                                    // 2677\n                    Configuration.getEdges(m.children, es);                                                            // 2678\n                });                                                                                                    // 2679\n            };                                                                                                         // 2680\n            return Configuration;                                                                                      // 2681\n        })();                                                                                                          // 2682\n        powergraph.Configuration = Configuration;                                                                      // 2683\n        function toGroups(modules, group, groups) {                                                                    // 2684\n            modules.forAll(function (m) {                                                                              // 2685\n                if (m.isLeaf()) {                                                                                      // 2686\n                    if (!group.leaves)                                                                                 // 2687\n                        group.leaves = [];                                                                             // 2688\n                    group.leaves.push(m.id);                                                                           // 2689\n                }                                                                                                      // 2690\n                else {                                                                                                 // 2691\n                    var g = group;                                                                                     // 2692\n                    m.gid = groups.length;                                                                             // 2693\n                    if (!m.isIsland() || m.isPredefined()) {                                                           // 2694\n                        g = { id: m.gid };                                                                             // 2695\n                        if (m.isPredefined())                                                                          // 2696\n                            // Apply original group properties                                                         // 2697\n                            for (var prop in m.definition)                                                             // 2698\n                                g[prop] = m.definition[prop];                                                          // 2699\n                        if (!group.groups)                                                                             // 2700\n                            group.groups = [];                                                                         // 2701\n                        group.groups.push(m.gid);                                                                      // 2702\n                        groups.push(g);                                                                                // 2703\n                    }                                                                                                  // 2704\n                    toGroups(m.children, g, groups);                                                                   // 2705\n                }                                                                                                      // 2706\n            });                                                                                                        // 2707\n        }                                                                                                              // 2708\n        var Module = (function () {                                                                                    // 2709\n            function Module(id, outgoing, incoming, children, definition) {                                            // 2710\n                if (outgoing === void 0) { outgoing = new LinkSets(); }                                                // 2711\n                if (incoming === void 0) { incoming = new LinkSets(); }                                                // 2712\n                if (children === void 0) { children = new ModuleSet(); }                                               // 2713\n                this.id = id;                                                                                          // 2714\n                this.outgoing = outgoing;                                                                              // 2715\n                this.incoming = incoming;                                                                              // 2716\n                this.children = children;                                                                              // 2717\n                this.definition = definition;                                                                          // 2718\n            }                                                                                                          // 2719\n            Module.prototype.getEdges = function (es) {                                                                // 2720\n                var _this = this;                                                                                      // 2721\n                this.outgoing.forAll(function (ms, edgetype) {                                                         // 2722\n                    ms.forAll(function (target) {                                                                      // 2723\n                        es.push(new PowerEdge(_this.id, target.id, edgetype));                                         // 2724\n                    });                                                                                                // 2725\n                });                                                                                                    // 2726\n            };                                                                                                         // 2727\n            Module.prototype.isLeaf = function () {                                                                    // 2728\n                return this.children.count() === 0;                                                                    // 2729\n            };                                                                                                         // 2730\n            Module.prototype.isIsland = function () {                                                                  // 2731\n                return this.outgoing.count() === 0 && this.incoming.count() === 0;                                     // 2732\n            };                                                                                                         // 2733\n            Module.prototype.isPredefined = function () {                                                              // 2734\n                return typeof this.definition !== \"undefined\";                                                         // 2735\n            };                                                                                                         // 2736\n            return Module;                                                                                             // 2737\n        })();                                                                                                          // 2738\n        powergraph.Module = Module;                                                                                    // 2739\n        function intersection(m, n) {                                                                                  // 2740\n            var i = {};                                                                                                // 2741\n            for (var v in m)                                                                                           // 2742\n                if (v in n)                                                                                            // 2743\n                    i[v] = m[v];                                                                                       // 2744\n            return i;                                                                                                  // 2745\n        }                                                                                                              // 2746\n        var ModuleSet = (function () {                                                                                 // 2747\n            function ModuleSet() {                                                                                     // 2748\n                this.table = {};                                                                                       // 2749\n            }                                                                                                          // 2750\n            ModuleSet.prototype.count = function () {                                                                  // 2751\n                return Object.keys(this.table).length;                                                                 // 2752\n            };                                                                                                         // 2753\n            ModuleSet.prototype.intersection = function (other) {                                                      // 2754\n                var result = new ModuleSet();                                                                          // 2755\n                result.table = intersection(this.table, other.table);                                                  // 2756\n                return result;                                                                                         // 2757\n            };                                                                                                         // 2758\n            ModuleSet.prototype.intersectionCount = function (other) {                                                 // 2759\n                return this.intersection(other).count();                                                               // 2760\n            };                                                                                                         // 2761\n            ModuleSet.prototype.contains = function (id) {                                                             // 2762\n                return id in this.table;                                                                               // 2763\n            };                                                                                                         // 2764\n            ModuleSet.prototype.add = function (m) {                                                                   // 2765\n                this.table[m.id] = m;                                                                                  // 2766\n            };                                                                                                         // 2767\n            ModuleSet.prototype.remove = function (m) {                                                                // 2768\n                delete this.table[m.id];                                                                               // 2769\n            };                                                                                                         // 2770\n            ModuleSet.prototype.forAll = function (f) {                                                                // 2771\n                for (var mid in this.table) {                                                                          // 2772\n                    f(this.table[mid]);                                                                                // 2773\n                }                                                                                                      // 2774\n            };                                                                                                         // 2775\n            ModuleSet.prototype.modules = function () {                                                                // 2776\n                var vs = [];                                                                                           // 2777\n                this.forAll(function (m) {                                                                             // 2778\n                    if (!m.isPredefined())                                                                             // 2779\n                        vs.push(m);                                                                                    // 2780\n                });                                                                                                    // 2781\n                return vs;                                                                                             // 2782\n            };                                                                                                         // 2783\n            return ModuleSet;                                                                                          // 2784\n        })();                                                                                                          // 2785\n        powergraph.ModuleSet = ModuleSet;                                                                              // 2786\n        var LinkSets = (function () {                                                                                  // 2787\n            function LinkSets() {                                                                                      // 2788\n                this.sets = {};                                                                                        // 2789\n                this.n = 0;                                                                                            // 2790\n            }                                                                                                          // 2791\n            LinkSets.prototype.count = function () {                                                                   // 2792\n                return this.n;                                                                                         // 2793\n            };                                                                                                         // 2794\n            LinkSets.prototype.contains = function (id) {                                                              // 2795\n                var result = false;                                                                                    // 2796\n                this.forAllModules(function (m) {                                                                      // 2797\n                    if (!result && m.id == id) {                                                                       // 2798\n                        result = true;                                                                                 // 2799\n                    }                                                                                                  // 2800\n                });                                                                                                    // 2801\n                return result;                                                                                         // 2802\n            };                                                                                                         // 2803\n            LinkSets.prototype.add = function (linktype, m) {                                                          // 2804\n                var s = linktype in this.sets ? this.sets[linktype] : this.sets[linktype] = new ModuleSet();           // 2805\n                s.add(m);                                                                                              // 2806\n                ++this.n;                                                                                              // 2807\n            };                                                                                                         // 2808\n            LinkSets.prototype.remove = function (linktype, m) {                                                       // 2809\n                var ms = this.sets[linktype];                                                                          // 2810\n                ms.remove(m);                                                                                          // 2811\n                if (ms.count() === 0) {                                                                                // 2812\n                    delete this.sets[linktype];                                                                        // 2813\n                }                                                                                                      // 2814\n                --this.n;                                                                                              // 2815\n            };                                                                                                         // 2816\n            LinkSets.prototype.forAll = function (f) {                                                                 // 2817\n                for (var linktype in this.sets) {                                                                      // 2818\n                    f(this.sets[linktype], linktype);                                                                  // 2819\n                }                                                                                                      // 2820\n            };                                                                                                         // 2821\n            LinkSets.prototype.forAllModules = function (f) {                                                          // 2822\n                this.forAll(function (ms, lt) { return ms.forAll(f); });                                               // 2823\n            };                                                                                                         // 2824\n            LinkSets.prototype.intersection = function (other) {                                                       // 2825\n                var result = new LinkSets();                                                                           // 2826\n                this.forAll(function (ms, lt) {                                                                        // 2827\n                    if (lt in other.sets) {                                                                            // 2828\n                        var i = ms.intersection(other.sets[lt]), n = i.count();                                        // 2829\n                        if (n > 0) {                                                                                   // 2830\n                            result.sets[lt] = i;                                                                       // 2831\n                            result.n += n;                                                                             // 2832\n                        }                                                                                              // 2833\n                    }                                                                                                  // 2834\n                });                                                                                                    // 2835\n                return result;                                                                                         // 2836\n            };                                                                                                         // 2837\n            return LinkSets;                                                                                           // 2838\n        })();                                                                                                          // 2839\n        powergraph.LinkSets = LinkSets;                                                                                // 2840\n        function intersectionCount(m, n) {                                                                             // 2841\n            return Object.keys(intersection(m, n)).length;                                                             // 2842\n        }                                                                                                              // 2843\n        function getGroups(nodes, links, la, rootGroup) {                                                              // 2844\n            var n = nodes.length, c = new powergraph.Configuration(n, links, la, rootGroup);                           // 2845\n            while (c.greedyMerge())                                                                                    // 2846\n                ;                                                                                                      // 2847\n            var powerEdges = [];                                                                                       // 2848\n            var g = c.getGroupHierarchy(powerEdges);                                                                   // 2849\n            powerEdges.forEach(function (e) {                                                                          // 2850\n                var f = function (end) {                                                                               // 2851\n                    var g = e[end];                                                                                    // 2852\n                    if (typeof g == \"number\")                                                                          // 2853\n                        e[end] = nodes[g];                                                                             // 2854\n                };                                                                                                     // 2855\n                f(\"source\");                                                                                           // 2856\n                f(\"target\");                                                                                           // 2857\n            });                                                                                                        // 2858\n            return { groups: g, powerEdges: powerEdges };                                                              // 2859\n        }                                                                                                              // 2860\n        powergraph.getGroups = getGroups;                                                                              // 2861\n    })(powergraph = cola.powergraph || (cola.powergraph = {}));                                                        // 2862\n})(cola || (cola = {}));                                                                                               // 2863\n/**                                                                                                                    // 2864\n * @module cola                                                                                                        // 2865\n */                                                                                                                    // 2866\nvar cola;                                                                                                              // 2867\n(function (cola) {                                                                                                     // 2868\n    // compute the size of the union of two sets a and b                                                               // 2869\n    function unionCount(a, b) {                                                                                        // 2870\n        var u = {};                                                                                                    // 2871\n        for (var i in a)                                                                                               // 2872\n            u[i] = {};                                                                                                 // 2873\n        for (var i in b)                                                                                               // 2874\n            u[i] = {};                                                                                                 // 2875\n        return Object.keys(u).length;                                                                                  // 2876\n    }                                                                                                                  // 2877\n    // compute the size of the intersection of two sets a and b                                                        // 2878\n    function intersectionCount(a, b) {                                                                                 // 2879\n        var n = 0;                                                                                                     // 2880\n        for (var i in a)                                                                                               // 2881\n            if (typeof b[i] !== 'undefined')                                                                           // 2882\n                ++n;                                                                                                   // 2883\n        return n;                                                                                                      // 2884\n    }                                                                                                                  // 2885\n    function getNeighbours(links, la) {                                                                                // 2886\n        var neighbours = {};                                                                                           // 2887\n        var addNeighbours = function (u, v) {                                                                          // 2888\n            if (typeof neighbours[u] === 'undefined')                                                                  // 2889\n                neighbours[u] = {};                                                                                    // 2890\n            neighbours[u][v] = {};                                                                                     // 2891\n        };                                                                                                             // 2892\n        links.forEach(function (e) {                                                                                   // 2893\n            var u = la.getSourceIndex(e), v = la.getTargetIndex(e);                                                    // 2894\n            addNeighbours(u, v);                                                                                       // 2895\n            addNeighbours(v, u);                                                                                       // 2896\n        });                                                                                                            // 2897\n        return neighbours;                                                                                             // 2898\n    }                                                                                                                  // 2899\n    // modify the lengths of the specified links by the result of function f weighted by w                             // 2900\n    function computeLinkLengths(links, w, f, la) {                                                                     // 2901\n        var neighbours = getNeighbours(links, la);                                                                     // 2902\n        links.forEach(function (l) {                                                                                   // 2903\n            var a = neighbours[la.getSourceIndex(l)];                                                                  // 2904\n            var b = neighbours[la.getTargetIndex(l)];                                                                  // 2905\n            la.setLength(l, 1 + w * f(a, b));                                                                          // 2906\n        });                                                                                                            // 2907\n    }                                                                                                                  // 2908\n    /** modify the specified link lengths based on the symmetric difference of their neighbours                        // 2909\n     * @class symmetricDiffLinkLengths                                                                                 // 2910\n     */                                                                                                                // 2911\n    function symmetricDiffLinkLengths(links, la, w) {                                                                  // 2912\n        if (w === void 0) { w = 1; }                                                                                   // 2913\n        computeLinkLengths(links, w, function (a, b) { return Math.sqrt(unionCount(a, b) - intersectionCount(a, b)); }, la);\n    }                                                                                                                  // 2915\n    cola.symmetricDiffLinkLengths = symmetricDiffLinkLengths;                                                          // 2916\n    /** modify the specified links lengths based on the jaccard difference between their neighbours                    // 2917\n     * @class jaccardLinkLengths                                                                                       // 2918\n     */                                                                                                                // 2919\n    function jaccardLinkLengths(links, la, w) {                                                                        // 2920\n        if (w === void 0) { w = 1; }                                                                                   // 2921\n        computeLinkLengths(links, w, function (a, b) {                                                                 // 2922\n            return Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b);\n        }, la);                                                                                                        // 2924\n    }                                                                                                                  // 2925\n    cola.jaccardLinkLengths = jaccardLinkLengths;                                                                      // 2926\n    /** generate separation constraints for all edges unless both their source and sink are in the same strongly connected component\n     * @class generateDirectedEdgeConstraints                                                                          // 2928\n     */                                                                                                                // 2929\n    function generateDirectedEdgeConstraints(n, links, axis, la) {                                                     // 2930\n        var components = stronglyConnectedComponents(n, links, la);                                                    // 2931\n        var nodes = {};                                                                                                // 2932\n        components.forEach(function (c, i) {                                                                           // 2933\n            return c.forEach(function (v) { return nodes[v] = i; });                                                   // 2934\n        });                                                                                                            // 2935\n        var constraints = [];                                                                                          // 2936\n        links.forEach(function (l) {                                                                                   // 2937\n            var ui = la.getSourceIndex(l), vi = la.getTargetIndex(l), u = nodes[ui], v = nodes[vi];                    // 2938\n            if (u !== v) {                                                                                             // 2939\n                constraints.push({                                                                                     // 2940\n                    axis: axis,                                                                                        // 2941\n                    left: ui,                                                                                          // 2942\n                    right: vi,                                                                                         // 2943\n                    gap: la.getMinSeparation(l)                                                                        // 2944\n                });                                                                                                    // 2945\n            }                                                                                                          // 2946\n        });                                                                                                            // 2947\n        return constraints;                                                                                            // 2948\n    }                                                                                                                  // 2949\n    cola.generateDirectedEdgeConstraints = generateDirectedEdgeConstraints;                                            // 2950\n    /**                                                                                                                // 2951\n     * Tarjan's strongly connected components algorithm for directed graphs                                            // 2952\n     * returns an array of arrays of node indicies in each of the strongly connected components.                       // 2953\n     * a vertex not in a SCC of two or more nodes is it's own SCC.                                                     // 2954\n     * adaptation of https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm                  // 2955\n     */                                                                                                                // 2956\n    function stronglyConnectedComponents(numVertices, edges, la) {                                                     // 2957\n        var nodes = [];                                                                                                // 2958\n        var index = 0;                                                                                                 // 2959\n        var stack = [];                                                                                                // 2960\n        var components = [];                                                                                           // 2961\n        function strongConnect(v) {                                                                                    // 2962\n            // Set the depth index for v to the smallest unused index                                                  // 2963\n            v.index = v.lowlink = index++;                                                                             // 2964\n            stack.push(v);                                                                                             // 2965\n            v.onStack = true;                                                                                          // 2966\n            // Consider successors of v                                                                                // 2967\n            for (var _i = 0, _a = v.out; _i < _a.length; _i++) {                                                       // 2968\n                var w = _a[_i];                                                                                        // 2969\n                if (typeof w.index === 'undefined') {                                                                  // 2970\n                    // Successor w has not yet been visited; recurse on it                                             // 2971\n                    strongConnect(w);                                                                                  // 2972\n                    v.lowlink = Math.min(v.lowlink, w.lowlink);                                                        // 2973\n                }                                                                                                      // 2974\n                else if (w.onStack) {                                                                                  // 2975\n                    // Successor w is in stack S and hence in the current SCC                                          // 2976\n                    v.lowlink = Math.min(v.lowlink, w.index);                                                          // 2977\n                }                                                                                                      // 2978\n            }                                                                                                          // 2979\n            // If v is a root node, pop the stack and generate an SCC                                                  // 2980\n            if (v.lowlink === v.index) {                                                                               // 2981\n                // start a new strongly connected component                                                            // 2982\n                var component = [];                                                                                    // 2983\n                while (stack.length) {                                                                                 // 2984\n                    w = stack.pop();                                                                                   // 2985\n                    w.onStack = false;                                                                                 // 2986\n                    //add w to current strongly connected component                                                    // 2987\n                    component.push(w);                                                                                 // 2988\n                    if (w === v)                                                                                       // 2989\n                        break;                                                                                         // 2990\n                }                                                                                                      // 2991\n                // output the current strongly connected component                                                     // 2992\n                components.push(component.map(function (v) { return v.id; }));                                         // 2993\n            }                                                                                                          // 2994\n        }                                                                                                              // 2995\n        for (var i = 0; i < numVertices; i++) {                                                                        // 2996\n            nodes.push({ id: i, out: [] });                                                                            // 2997\n        }                                                                                                              // 2998\n        for (var _i = 0; _i < edges.length; _i++) {                                                                    // 2999\n            var e = edges[_i];                                                                                         // 3000\n            var v_1 = nodes[la.getSourceIndex(e)], w = nodes[la.getTargetIndex(e)];                                    // 3001\n            v_1.out.push(w);                                                                                           // 3002\n        }                                                                                                              // 3003\n        for (var _a = 0; _a < nodes.length; _a++) {                                                                    // 3004\n            var v = nodes[_a];                                                                                         // 3005\n            if (typeof v.index === 'undefined')                                                                        // 3006\n                strongConnect(v);                                                                                      // 3007\n        }                                                                                                              // 3008\n        return components;                                                                                             // 3009\n    }                                                                                                                  // 3010\n    cola.stronglyConnectedComponents = stronglyConnectedComponents;                                                    // 3011\n})(cola || (cola = {}));                                                                                               // 3012\nvar PairingHeap = (function () {                                                                                       // 3013\n    // from: https://gist.github.com/nervoussystem                                                                     // 3014\n    //{elem:object, subheaps:[array of heaps]}                                                                         // 3015\n    function PairingHeap(elem) {                                                                                       // 3016\n        this.elem = elem;                                                                                              // 3017\n        this.subheaps = [];                                                                                            // 3018\n    }                                                                                                                  // 3019\n    PairingHeap.prototype.toString = function (selector) {                                                             // 3020\n        var str = \"\", needComma = false;                                                                               // 3021\n        for (var i = 0; i < this.subheaps.length; ++i) {                                                               // 3022\n            var subheap = this.subheaps[i];                                                                            // 3023\n            if (!subheap.elem) {                                                                                       // 3024\n                needComma = false;                                                                                     // 3025\n                continue;                                                                                              // 3026\n            }                                                                                                          // 3027\n            if (needComma) {                                                                                           // 3028\n                str = str + \",\";                                                                                       // 3029\n            }                                                                                                          // 3030\n            str = str + subheap.toString(selector);                                                                    // 3031\n            needComma = true;                                                                                          // 3032\n        }                                                                                                              // 3033\n        if (str !== \"\") {                                                                                              // 3034\n            str = \"(\" + str + \")\";                                                                                     // 3035\n        }                                                                                                              // 3036\n        return (this.elem ? selector(this.elem) : \"\") + str;                                                           // 3037\n    };                                                                                                                 // 3038\n    PairingHeap.prototype.forEach = function (f) {                                                                     // 3039\n        if (!this.empty()) {                                                                                           // 3040\n            f(this.elem, this);                                                                                        // 3041\n            this.subheaps.forEach(function (s) { return s.forEach(f); });                                              // 3042\n        }                                                                                                              // 3043\n    };                                                                                                                 // 3044\n    PairingHeap.prototype.count = function () {                                                                        // 3045\n        return this.empty() ? 0 : 1 + this.subheaps.reduce(function (n, h) {                                           // 3046\n            return n + h.count();                                                                                      // 3047\n        }, 0);                                                                                                         // 3048\n    };                                                                                                                 // 3049\n    PairingHeap.prototype.min = function () {                                                                          // 3050\n        return this.elem;                                                                                              // 3051\n    };                                                                                                                 // 3052\n    PairingHeap.prototype.empty = function () {                                                                        // 3053\n        return this.elem == null;                                                                                      // 3054\n    };                                                                                                                 // 3055\n    PairingHeap.prototype.contains = function (h) {                                                                    // 3056\n        if (this === h)                                                                                                // 3057\n            return true;                                                                                               // 3058\n        for (var i = 0; i < this.subheaps.length; i++) {                                                               // 3059\n            if (this.subheaps[i].contains(h))                                                                          // 3060\n                return true;                                                                                           // 3061\n        }                                                                                                              // 3062\n        return false;                                                                                                  // 3063\n    };                                                                                                                 // 3064\n    PairingHeap.prototype.isHeap = function (lessThan) {                                                               // 3065\n        var _this = this;                                                                                              // 3066\n        return this.subheaps.every(function (h) { return lessThan(_this.elem, h.elem) && h.isHeap(lessThan); });       // 3067\n    };                                                                                                                 // 3068\n    PairingHeap.prototype.insert = function (obj, lessThan) {                                                          // 3069\n        return this.merge(new PairingHeap(obj), lessThan);                                                             // 3070\n    };                                                                                                                 // 3071\n    PairingHeap.prototype.merge = function (heap2, lessThan) {                                                         // 3072\n        if (this.empty())                                                                                              // 3073\n            return heap2;                                                                                              // 3074\n        else if (heap2.empty())                                                                                        // 3075\n            return this;                                                                                               // 3076\n        else if (lessThan(this.elem, heap2.elem)) {                                                                    // 3077\n            this.subheaps.push(heap2);                                                                                 // 3078\n            return this;                                                                                               // 3079\n        }                                                                                                              // 3080\n        else {                                                                                                         // 3081\n            heap2.subheaps.push(this);                                                                                 // 3082\n            return heap2;                                                                                              // 3083\n        }                                                                                                              // 3084\n    };                                                                                                                 // 3085\n    PairingHeap.prototype.removeMin = function (lessThan) {                                                            // 3086\n        if (this.empty())                                                                                              // 3087\n            return null;                                                                                               // 3088\n        else                                                                                                           // 3089\n            return this.mergePairs(lessThan);                                                                          // 3090\n    };                                                                                                                 // 3091\n    PairingHeap.prototype.mergePairs = function (lessThan) {                                                           // 3092\n        if (this.subheaps.length == 0)                                                                                 // 3093\n            return new PairingHeap(null);                                                                              // 3094\n        else if (this.subheaps.length == 1) {                                                                          // 3095\n            return this.subheaps[0];                                                                                   // 3096\n        }                                                                                                              // 3097\n        else {                                                                                                         // 3098\n            var firstPair = this.subheaps.pop().merge(this.subheaps.pop(), lessThan);                                  // 3099\n            var remaining = this.mergePairs(lessThan);                                                                 // 3100\n            return firstPair.merge(remaining, lessThan);                                                               // 3101\n        }                                                                                                              // 3102\n    };                                                                                                                 // 3103\n    PairingHeap.prototype.decreaseKey = function (subheap, newValue, setHeapNode, lessThan) {                          // 3104\n        var newHeap = subheap.removeMin(lessThan);                                                                     // 3105\n        //reassign subheap values to preserve tree                                                                     // 3106\n        subheap.elem = newHeap.elem;                                                                                   // 3107\n        subheap.subheaps = newHeap.subheaps;                                                                           // 3108\n        if (setHeapNode !== null && newHeap.elem !== null) {                                                           // 3109\n            setHeapNode(subheap.elem, subheap);                                                                        // 3110\n        }                                                                                                              // 3111\n        var pairingNode = new PairingHeap(newValue);                                                                   // 3112\n        if (setHeapNode !== null) {                                                                                    // 3113\n            setHeapNode(newValue, pairingNode);                                                                        // 3114\n        }                                                                                                              // 3115\n        return this.merge(pairingNode, lessThan);                                                                      // 3116\n    };                                                                                                                 // 3117\n    return PairingHeap;                                                                                                // 3118\n})();                                                                                                                  // 3119\n/**                                                                                                                    // 3120\n * @class PriorityQueue a min priority queue backed by a pairing heap                                                  // 3121\n */                                                                                                                    // 3122\nvar PriorityQueue = (function () {                                                                                     // 3123\n    function PriorityQueue(lessThan) {                                                                                 // 3124\n        this.lessThan = lessThan;                                                                                      // 3125\n    }                                                                                                                  // 3126\n    /**                                                                                                                // 3127\n     * @method top                                                                                                     // 3128\n     * @return the top element (the min element as defined by lessThan)                                                // 3129\n     */                                                                                                                // 3130\n    PriorityQueue.prototype.top = function () {                                                                        // 3131\n        if (this.empty()) {                                                                                            // 3132\n            return null;                                                                                               // 3133\n        }                                                                                                              // 3134\n        return this.root.elem;                                                                                         // 3135\n    };                                                                                                                 // 3136\n    /**                                                                                                                // 3137\n     * @method push                                                                                                    // 3138\n     * put things on the heap                                                                                          // 3139\n     */                                                                                                                // 3140\n    PriorityQueue.prototype.push = function () {                                                                       // 3141\n        var args = [];                                                                                                 // 3142\n        for (var _i = 0; _i < arguments.length; _i++) {                                                                // 3143\n            args[_i - 0] = arguments[_i];                                                                              // 3144\n        }                                                                                                              // 3145\n        var pairingNode;                                                                                               // 3146\n        for (var i = 0, arg; arg = args[i]; ++i) {                                                                     // 3147\n            pairingNode = new PairingHeap(arg);                                                                        // 3148\n            this.root = this.empty() ?                                                                                 // 3149\n                pairingNode : this.root.merge(pairingNode, this.lessThan);                                             // 3150\n        }                                                                                                              // 3151\n        return pairingNode;                                                                                            // 3152\n    };                                                                                                                 // 3153\n    /**                                                                                                                // 3154\n     * @method empty                                                                                                   // 3155\n     * @return true if no more elements in queue                                                                       // 3156\n     */                                                                                                                // 3157\n    PriorityQueue.prototype.empty = function () {                                                                      // 3158\n        return !this.root || !this.root.elem;                                                                          // 3159\n    };                                                                                                                 // 3160\n    /**                                                                                                                // 3161\n     * @method isHeap check heap condition (for testing)                                                               // 3162\n     * @return true if queue is in valid state                                                                         // 3163\n     */                                                                                                                // 3164\n    PriorityQueue.prototype.isHeap = function () {                                                                     // 3165\n        return this.root.isHeap(this.lessThan);                                                                        // 3166\n    };                                                                                                                 // 3167\n    /**                                                                                                                // 3168\n     * @method forEach apply f to each element of the queue                                                            // 3169\n     * @param f function to apply                                                                                      // 3170\n     */                                                                                                                // 3171\n    PriorityQueue.prototype.forEach = function (f) {                                                                   // 3172\n        this.root.forEach(f);                                                                                          // 3173\n    };                                                                                                                 // 3174\n    /**                                                                                                                // 3175\n     * @method pop remove and return the min element from the queue                                                    // 3176\n     */                                                                                                                // 3177\n    PriorityQueue.prototype.pop = function () {                                                                        // 3178\n        if (this.empty()) {                                                                                            // 3179\n            return null;                                                                                               // 3180\n        }                                                                                                              // 3181\n        var obj = this.root.min();                                                                                     // 3182\n        this.root = this.root.removeMin(this.lessThan);                                                                // 3183\n        return obj;                                                                                                    // 3184\n    };                                                                                                                 // 3185\n    /**                                                                                                                // 3186\n     * @method reduceKey reduce the key value of the specified heap node                                               // 3187\n     */                                                                                                                // 3188\n    PriorityQueue.prototype.reduceKey = function (heapNode, newKey, setHeapNode) {                                     // 3189\n        if (setHeapNode === void 0) { setHeapNode = null; }                                                            // 3190\n        this.root = this.root.decreaseKey(heapNode, newKey, setHeapNode, this.lessThan);                               // 3191\n    };                                                                                                                 // 3192\n    PriorityQueue.prototype.toString = function (selector) {                                                           // 3193\n        return this.root.toString(selector);                                                                           // 3194\n    };                                                                                                                 // 3195\n    /**                                                                                                                // 3196\n     * @method count                                                                                                   // 3197\n     * @return number of elements in queue                                                                             // 3198\n     */                                                                                                                // 3199\n    PriorityQueue.prototype.count = function () {                                                                      // 3200\n        return this.root.count();                                                                                      // 3201\n    };                                                                                                                 // 3202\n    return PriorityQueue;                                                                                              // 3203\n})();                                                                                                                  // 3204\n///<reference path=\"pqueue.ts\"/>                                                                                       // 3205\n/**                                                                                                                    // 3206\n * @module shortestpaths                                                                                               // 3207\n */                                                                                                                    // 3208\nvar cola;                                                                                                              // 3209\n(function (cola) {                                                                                                     // 3210\n    var shortestpaths;                                                                                                 // 3211\n    (function (shortestpaths) {                                                                                        // 3212\n        var Neighbour = (function () {                                                                                 // 3213\n            function Neighbour(id, distance) {                                                                         // 3214\n                this.id = id;                                                                                          // 3215\n                this.distance = distance;                                                                              // 3216\n            }                                                                                                          // 3217\n            return Neighbour;                                                                                          // 3218\n        })();                                                                                                          // 3219\n        var Node = (function () {                                                                                      // 3220\n            function Node(id) {                                                                                        // 3221\n                this.id = id;                                                                                          // 3222\n                this.neighbours = [];                                                                                  // 3223\n            }                                                                                                          // 3224\n            return Node;                                                                                               // 3225\n        })();                                                                                                          // 3226\n        var QueueEntry = (function () {                                                                                // 3227\n            function QueueEntry(node, prev, d) {                                                                       // 3228\n                this.node = node;                                                                                      // 3229\n                this.prev = prev;                                                                                      // 3230\n                this.d = d;                                                                                            // 3231\n            }                                                                                                          // 3232\n            return QueueEntry;                                                                                         // 3233\n        })();                                                                                                          // 3234\n        /**                                                                                                            // 3235\n         * calculates all-pairs shortest paths or shortest paths from a single node                                    // 3236\n         * @class Calculator                                                                                           // 3237\n         * @constructor                                                                                                // 3238\n         * @param n {number} number of nodes                                                                           // 3239\n         * @param es {Edge[]} array of edges                                                                           // 3240\n         */                                                                                                            // 3241\n        var Calculator = (function () {                                                                                // 3242\n            function Calculator(n, es, getSourceIndex, getTargetIndex, getLength) {                                    // 3243\n                this.n = n;                                                                                            // 3244\n                this.es = es;                                                                                          // 3245\n                this.neighbours = new Array(this.n);                                                                   // 3246\n                var i = this.n;                                                                                        // 3247\n                while (i--)                                                                                            // 3248\n                    this.neighbours[i] = new Node(i);                                                                  // 3249\n                i = this.es.length;                                                                                    // 3250\n                while (i--) {                                                                                          // 3251\n                    var e = this.es[i];                                                                                // 3252\n                    var u = getSourceIndex(e), v = getTargetIndex(e);                                                  // 3253\n                    var d = getLength(e);                                                                              // 3254\n                    this.neighbours[u].neighbours.push(new Neighbour(v, d));                                           // 3255\n                    this.neighbours[v].neighbours.push(new Neighbour(u, d));                                           // 3256\n                }                                                                                                      // 3257\n            }                                                                                                          // 3258\n            /**                                                                                                        // 3259\n             * compute shortest paths for graph over n nodes with edges an array of source/target pairs                // 3260\n             * edges may optionally have a length attribute.  1 is the default.                                        // 3261\n             * Uses Johnson's algorithm.                                                                               // 3262\n             *                                                                                                         // 3263\n             * @method DistanceMatrix                                                                                  // 3264\n             * @return the distance matrix                                                                             // 3265\n             */                                                                                                        // 3266\n            Calculator.prototype.DistanceMatrix = function () {                                                        // 3267\n                var D = new Array(this.n);                                                                             // 3268\n                for (var i = 0; i < this.n; ++i) {                                                                     // 3269\n                    D[i] = this.dijkstraNeighbours(i);                                                                 // 3270\n                }                                                                                                      // 3271\n                return D;                                                                                              // 3272\n            };                                                                                                         // 3273\n            /**                                                                                                        // 3274\n             * get shortest paths from a specified start node                                                          // 3275\n             * @method DistancesFromNode                                                                               // 3276\n             * @param start node index                                                                                 // 3277\n             * @return array of path lengths                                                                           // 3278\n             */                                                                                                        // 3279\n            Calculator.prototype.DistancesFromNode = function (start) {                                                // 3280\n                return this.dijkstraNeighbours(start);                                                                 // 3281\n            };                                                                                                         // 3282\n            Calculator.prototype.PathFromNodeToNode = function (start, end) {                                          // 3283\n                return this.dijkstraNeighbours(start, end);                                                            // 3284\n            };                                                                                                         // 3285\n            // find shortest path from start to end, with the opportunity at                                           // 3286\n            // each edge traversal to compute a custom cost based on the                                               // 3287\n            // previous edge.  For example, to penalise bends.                                                         // 3288\n            Calculator.prototype.PathFromNodeToNodeWithPrevCost = function (start, end, prevCost) {                    // 3289\n                var q = new PriorityQueue(function (a, b) { return a.d <= b.d; }), u = this.neighbours[start], qu = new QueueEntry(u, null, 0), visitedFrom = {};\n                q.push(qu);                                                                                            // 3291\n                while (!q.empty()) {                                                                                   // 3292\n                    qu = q.pop();                                                                                      // 3293\n                    u = qu.node;                                                                                       // 3294\n                    if (u.id === end) {                                                                                // 3295\n                        break;                                                                                         // 3296\n                    }                                                                                                  // 3297\n                    var i = u.neighbours.length;                                                                       // 3298\n                    while (i--) {                                                                                      // 3299\n                        var neighbour = u.neighbours[i], v = this.neighbours[neighbour.id];                            // 3300\n                        // don't double back                                                                           // 3301\n                        if (qu.prev && v.id === qu.prev.node.id)                                                       // 3302\n                            continue;                                                                                  // 3303\n                        // don't retraverse an edge if it has already been explored                                    // 3304\n                        // from a lower cost route                                                                     // 3305\n                        var viduid = v.id + ',' + u.id;                                                                // 3306\n                        if (viduid in visitedFrom && visitedFrom[viduid] <= qu.d)                                      // 3307\n                            continue;                                                                                  // 3308\n                        var cc = qu.prev ? prevCost(qu.prev.node.id, u.id, v.id) : 0, t = qu.d + neighbour.distance + cc;\n                        // store cost of this traversal                                                                // 3310\n                        visitedFrom[viduid] = t;                                                                       // 3311\n                        q.push(new QueueEntry(v, qu, t));                                                              // 3312\n                    }                                                                                                  // 3313\n                }                                                                                                      // 3314\n                var path = [];                                                                                         // 3315\n                while (qu.prev) {                                                                                      // 3316\n                    qu = qu.prev;                                                                                      // 3317\n                    path.push(qu.node.id);                                                                             // 3318\n                }                                                                                                      // 3319\n                return path;                                                                                           // 3320\n            };                                                                                                         // 3321\n            Calculator.prototype.dijkstraNeighbours = function (start, dest) {                                         // 3322\n                if (dest === void 0) { dest = -1; }                                                                    // 3323\n                var q = new PriorityQueue(function (a, b) { return a.d <= b.d; }), i = this.neighbours.length, d = new Array(i);\n                while (i--) {                                                                                          // 3325\n                    var node = this.neighbours[i];                                                                     // 3326\n                    node.d = i === start ? 0 : Number.POSITIVE_INFINITY;                                               // 3327\n                    node.q = q.push(node);                                                                             // 3328\n                }                                                                                                      // 3329\n                while (!q.empty()) {                                                                                   // 3330\n                    // console.log(q.toString(function (u) { return u.id + \"=\" + (u.d === Number.POSITIVE_INFINITY ? \"\\u221E\" : u.d.toFixed(2) )}));\n                    var u = q.pop();                                                                                   // 3332\n                    d[u.id] = u.d;                                                                                     // 3333\n                    if (u.id === dest) {                                                                               // 3334\n                        var path = [];                                                                                 // 3335\n                        var v = u;                                                                                     // 3336\n                        while (typeof v.prev !== 'undefined') {                                                        // 3337\n                            path.push(v.prev.id);                                                                      // 3338\n                            v = v.prev;                                                                                // 3339\n                        }                                                                                              // 3340\n                        return path;                                                                                   // 3341\n                    }                                                                                                  // 3342\n                    i = u.neighbours.length;                                                                           // 3343\n                    while (i--) {                                                                                      // 3344\n                        var neighbour = u.neighbours[i];                                                               // 3345\n                        var v = this.neighbours[neighbour.id];                                                         // 3346\n                        var t = u.d + neighbour.distance;                                                              // 3347\n                        if (u.d !== Number.MAX_VALUE && v.d > t) {                                                     // 3348\n                            v.d = t;                                                                                   // 3349\n                            v.prev = u;                                                                                // 3350\n                            q.reduceKey(v.q, v, function (e, q) { return e.q = q; });                                  // 3351\n                        }                                                                                              // 3352\n                    }                                                                                                  // 3353\n                }                                                                                                      // 3354\n                return d;                                                                                              // 3355\n            };                                                                                                         // 3356\n            return Calculator;                                                                                         // 3357\n        })();                                                                                                          // 3358\n        shortestpaths.Calculator = Calculator;                                                                         // 3359\n    })(shortestpaths = cola.shortestpaths || (cola.shortestpaths = {}));                                               // 3360\n})(cola || (cola = {}));                                                                                               // 3361\n///<reference path=\"handledisconnected.ts\"/>                                                                           // 3362\n///<reference path=\"geom.ts\"/>                                                                                         // 3363\n///<reference path=\"descent.ts\"/>                                                                                      // 3364\n///<reference path=\"powergraph.ts\"/>                                                                                   // 3365\n///<reference path=\"linklengths.ts\"/>                                                                                  // 3366\n///<reference path=\"shortestpaths.ts\"/>                                                                                // 3367\n/**                                                                                                                    // 3368\n * @module cola                                                                                                        // 3369\n */                                                                                                                    // 3370\nvar cola;                                                                                                              // 3371\n(function (cola) {                                                                                                     // 3372\n    /**                                                                                                                // 3373\n     * The layout process fires three events:                                                                          // 3374\n     *  - start: layout iterations started                                                                             // 3375\n     *  - tick: fired once per iteration, listen to this to animate                                                    // 3376\n     *  - end: layout converged, you might like to zoom-to-fit or something at notification of this event              // 3377\n     */                                                                                                                // 3378\n    (function (EventType) {                                                                                            // 3379\n        EventType[EventType[\"start\"] = 0] = \"start\";                                                                   // 3380\n        EventType[EventType[\"tick\"] = 1] = \"tick\";                                                                     // 3381\n        EventType[EventType[\"end\"] = 2] = \"end\";                                                                       // 3382\n    })(cola.EventType || (cola.EventType = {}));                                                                       // 3383\n    var EventType = cola.EventType;                                                                                    // 3384\n    ;                                                                                                                  // 3385\n    function isGroup(g) {                                                                                              // 3386\n        return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';                                     // 3387\n    }                                                                                                                  // 3388\n    /**                                                                                                                // 3389\n     * Main interface to cola layout.                                                                                  // 3390\n     * @class Layout                                                                                                   // 3391\n     */                                                                                                                // 3392\n    var Layout = (function () {                                                                                        // 3393\n        function Layout() {                                                                                            // 3394\n            var _this = this;                                                                                          // 3395\n            this._canvasSize = [1, 1];                                                                                 // 3396\n            this._linkDistance = 20;                                                                                   // 3397\n            this._defaultNodeSize = 10;                                                                                // 3398\n            this._linkLengthCalculator = null;                                                                         // 3399\n            this._linkType = null;                                                                                     // 3400\n            this._avoidOverlaps = false;                                                                               // 3401\n            this._handleDisconnected = true;                                                                           // 3402\n            this._running = false;                                                                                     // 3403\n            this._nodes = [];                                                                                          // 3404\n            this._groups = [];                                                                                         // 3405\n            this._rootGroup = null;                                                                                    // 3406\n            this._links = [];                                                                                          // 3407\n            this._constraints = [];                                                                                    // 3408\n            this._distanceMatrix = null;                                                                               // 3409\n            this._descent = null;                                                                                      // 3410\n            this._directedLinkConstraints = null;                                                                      // 3411\n            this._threshold = 0.01;                                                                                    // 3412\n            this._visibilityGraph = null;                                                                              // 3413\n            this._groupCompactness = 1e-6;                                                                             // 3414\n            // sub-class and override this property to replace with a more sophisticated eventing mechanism            // 3415\n            this.event = null;                                                                                         // 3416\n            this.linkAccessor = {                                                                                      // 3417\n                getSourceIndex: Layout.getSourceIndex,                                                                 // 3418\n                getTargetIndex: Layout.getTargetIndex,                                                                 // 3419\n                setLength: Layout.setLinkLength,                                                                       // 3420\n                getType: function (l) { return typeof _this._linkType === \"function\" ? _this._linkType(l) : 0; }       // 3421\n            };                                                                                                         // 3422\n        }                                                                                                              // 3423\n        // subscribe a listener to an event                                                                            // 3424\n        // sub-class and override this method to replace with a more sophisticated eventing mechanism                  // 3425\n        Layout.prototype.on = function (e, listener) {                                                                 // 3426\n            // override me!                                                                                            // 3427\n            if (!this.event)                                                                                           // 3428\n                this.event = {};                                                                                       // 3429\n            if (typeof e === 'string') {                                                                               // 3430\n                this.event[EventType[e]] = listener;                                                                   // 3431\n            }                                                                                                          // 3432\n            else {                                                                                                     // 3433\n                this.event[e] = listener;                                                                              // 3434\n            }                                                                                                          // 3435\n            return this;                                                                                               // 3436\n        };                                                                                                             // 3437\n        // a function that is notified of events like \"tick\"                                                           // 3438\n        // sub-class and override this method to replace with a more sophisticated eventing mechanism                  // 3439\n        Layout.prototype.trigger = function (e) {                                                                      // 3440\n            if (this.event && typeof this.event[e.type] !== 'undefined') {                                             // 3441\n                this.event[e.type](e);                                                                                 // 3442\n            }                                                                                                          // 3443\n        };                                                                                                             // 3444\n        // a function that kicks off the iteration tick loop                                                           // 3445\n        // it calls tick() repeatedly until tick returns true (is converged)                                           // 3446\n        // subclass and override it with something fancier (e.g. dispatch tick on a timer)                             // 3447\n        Layout.prototype.kick = function () {                                                                          // 3448\n            while (!this.tick())                                                                                       // 3449\n                ;                                                                                                      // 3450\n        };                                                                                                             // 3451\n        /**                                                                                                            // 3452\n         * iterate the layout.  Returns true when layout converged.                                                    // 3453\n         */                                                                                                            // 3454\n        Layout.prototype.tick = function () {                                                                          // 3455\n            if (this._alpha < this._threshold) {                                                                       // 3456\n                this._running = false;                                                                                 // 3457\n                this.trigger({ type: EventType.end, alpha: this._alpha = 0, stress: this._lastStress });               // 3458\n                return true;                                                                                           // 3459\n            }                                                                                                          // 3460\n            var n = this._nodes.length, m = this._links.length;                                                        // 3461\n            var o, i;                                                                                                  // 3462\n            this._descent.locks.clear();                                                                               // 3463\n            for (i = 0; i < n; ++i) {                                                                                  // 3464\n                o = this._nodes[i];                                                                                    // 3465\n                if (o.fixed) {                                                                                         // 3466\n                    if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {                                  // 3467\n                        o.px = o.x;                                                                                    // 3468\n                        o.py = o.y;                                                                                    // 3469\n                    }                                                                                                  // 3470\n                    var p = [o.px, o.py];                                                                              // 3471\n                    this._descent.locks.add(i, p);                                                                     // 3472\n                }                                                                                                      // 3473\n            }                                                                                                          // 3474\n            var s1 = this._descent.rungeKutta();                                                                       // 3475\n            //var s1 = descent.reduceStress();                                                                         // 3476\n            if (s1 === 0) {                                                                                            // 3477\n                this._alpha = 0;                                                                                       // 3478\n            }                                                                                                          // 3479\n            else if (typeof this._lastStress !== 'undefined') {                                                        // 3480\n                this._alpha = s1; //Math.abs(Math.abs(this._lastStress / s1) - 1);                                     // 3481\n            }                                                                                                          // 3482\n            this._lastStress = s1;                                                                                     // 3483\n            this.updateNodePositions();                                                                                // 3484\n            this.trigger({ type: EventType.tick, alpha: this._alpha, stress: this._lastStress });                      // 3485\n            return false;                                                                                              // 3486\n        };                                                                                                             // 3487\n        // copy positions out of descent instance into each of the nodes' center coords                                // 3488\n        Layout.prototype.updateNodePositions = function () {                                                           // 3489\n            var x = this._descent.x[0], y = this._descent.x[1];                                                        // 3490\n            var o, i = this._nodes.length;                                                                             // 3491\n            while (i--) {                                                                                              // 3492\n                o = this._nodes[i];                                                                                    // 3493\n                o.x = x[i];                                                                                            // 3494\n                o.y = y[i];                                                                                            // 3495\n            }                                                                                                          // 3496\n        };                                                                                                             // 3497\n        Layout.prototype.nodes = function (v) {                                                                        // 3498\n            if (!v) {                                                                                                  // 3499\n                if (this._nodes.length === 0 && this._links.length > 0) {                                              // 3500\n                    // if we have links but no nodes, create the nodes array now with empty objects for the links to point at.\n                    // in this case the links are expected to be numeric indices for nodes in the range 0..n-1 where n is the number of nodes\n                    var n = 0;                                                                                         // 3503\n                    this._links.forEach(function (l) {                                                                 // 3504\n                        n = Math.max(n, l.source, l.target);                                                           // 3505\n                    });                                                                                                // 3506\n                    this._nodes = new Array(++n);                                                                      // 3507\n                    for (var i = 0; i < n; ++i) {                                                                      // 3508\n                        this._nodes[i] = {};                                                                           // 3509\n                    }                                                                                                  // 3510\n                }                                                                                                      // 3511\n                return this._nodes;                                                                                    // 3512\n            }                                                                                                          // 3513\n            this._nodes = v;                                                                                           // 3514\n            return this;                                                                                               // 3515\n        };                                                                                                             // 3516\n        Layout.prototype.groups = function (x) {                                                                       // 3517\n            var _this = this;                                                                                          // 3518\n            if (!x)                                                                                                    // 3519\n                return this._groups;                                                                                   // 3520\n            this._groups = x;                                                                                          // 3521\n            this._rootGroup = {};                                                                                      // 3522\n            this._groups.forEach(function (g) {                                                                        // 3523\n                if (typeof g.padding === \"undefined\")                                                                  // 3524\n                    g.padding = 1;                                                                                     // 3525\n                if (typeof g.leaves !== \"undefined\")                                                                   // 3526\n                    g.leaves.forEach(function (v, i) { (g.leaves[i] = _this._nodes[v]).parent = g; });                 // 3527\n                if (typeof g.groups !== \"undefined\")                                                                   // 3528\n                    g.groups.forEach(function (gi, i) { (g.groups[i] = _this._groups[gi]).parent = g; });              // 3529\n            });                                                                                                        // 3530\n            this._rootGroup.leaves = this._nodes.filter(function (v) { return typeof v.parent === 'undefined'; });     // 3531\n            this._rootGroup.groups = this._groups.filter(function (g) { return typeof g.parent === 'undefined'; });    // 3532\n            return this;                                                                                               // 3533\n        };                                                                                                             // 3534\n        Layout.prototype.powerGraphGroups = function (f) {                                                             // 3535\n            var g = cola.powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);           // 3536\n            this.groups(g.groups);                                                                                     // 3537\n            f(g);                                                                                                      // 3538\n            return this;                                                                                               // 3539\n        };                                                                                                             // 3540\n        Layout.prototype.avoidOverlaps = function (v) {                                                                // 3541\n            if (!arguments.length)                                                                                     // 3542\n                return this._avoidOverlaps;                                                                            // 3543\n            this._avoidOverlaps = v;                                                                                   // 3544\n            return this;                                                                                               // 3545\n        };                                                                                                             // 3546\n        Layout.prototype.handleDisconnected = function (v) {                                                           // 3547\n            if (!arguments.length)                                                                                     // 3548\n                return this._handleDisconnected;                                                                       // 3549\n            this._handleDisconnected = v;                                                                              // 3550\n            return this;                                                                                               // 3551\n        };                                                                                                             // 3552\n        /**                                                                                                            // 3553\n         * causes constraints to be generated such that directed graphs are laid out either from left-to-right or top-to-bottom.\n         * a separation constraint is generated in the selected axis for each edge that is not involved in a cycle (part of a strongly connected component)\n         * @param axis {string} 'x' for left-to-right, 'y' for top-to-bottom                                           // 3556\n         * @param minSeparation {number|link=>number} either a number specifying a minimum spacing required across all links or a function to return the minimum spacing for each link\n         */                                                                                                            // 3558\n        Layout.prototype.flowLayout = function (axis, minSeparation) {                                                 // 3559\n            if (!arguments.length)                                                                                     // 3560\n                axis = 'y';                                                                                            // 3561\n            this._directedLinkConstraints = {                                                                          // 3562\n                axis: axis,                                                                                            // 3563\n                getMinSeparation: typeof minSeparation === 'number' ? function () { return minSeparation; } : minSeparation\n            };                                                                                                         // 3565\n            return this;                                                                                               // 3566\n        };                                                                                                             // 3567\n        Layout.prototype.links = function (x) {                                                                        // 3568\n            if (!arguments.length)                                                                                     // 3569\n                return this._links;                                                                                    // 3570\n            this._links = x;                                                                                           // 3571\n            return this;                                                                                               // 3572\n        };                                                                                                             // 3573\n        Layout.prototype.constraints = function (c) {                                                                  // 3574\n            if (!arguments.length)                                                                                     // 3575\n                return this._constraints;                                                                              // 3576\n            this._constraints = c;                                                                                     // 3577\n            return this;                                                                                               // 3578\n        };                                                                                                             // 3579\n        Layout.prototype.distanceMatrix = function (d) {                                                               // 3580\n            if (!arguments.length)                                                                                     // 3581\n                return this._distanceMatrix;                                                                           // 3582\n            this._distanceMatrix = d;                                                                                  // 3583\n            return this;                                                                                               // 3584\n        };                                                                                                             // 3585\n        Layout.prototype.size = function (x) {                                                                         // 3586\n            if (!x)                                                                                                    // 3587\n                return this._canvasSize;                                                                               // 3588\n            this._canvasSize = x;                                                                                      // 3589\n            return this;                                                                                               // 3590\n        };                                                                                                             // 3591\n        Layout.prototype.defaultNodeSize = function (x) {                                                              // 3592\n            if (!x)                                                                                                    // 3593\n                return this._defaultNodeSize;                                                                          // 3594\n            this._defaultNodeSize = x;                                                                                 // 3595\n            return this;                                                                                               // 3596\n        };                                                                                                             // 3597\n        Layout.prototype.groupCompactness = function (x) {                                                             // 3598\n            if (!x)                                                                                                    // 3599\n                return this._groupCompactness;                                                                         // 3600\n            this._groupCompactness = x;                                                                                // 3601\n            return this;                                                                                               // 3602\n        };                                                                                                             // 3603\n        Layout.prototype.linkDistance = function (x) {                                                                 // 3604\n            if (!x) {                                                                                                  // 3605\n                return this._linkDistance;                                                                             // 3606\n            }                                                                                                          // 3607\n            this._linkDistance = typeof x === \"function\" ? x : +x;                                                     // 3608\n            this._linkLengthCalculator = null;                                                                         // 3609\n            return this;                                                                                               // 3610\n        };                                                                                                             // 3611\n        Layout.prototype.linkType = function (f) {                                                                     // 3612\n            this._linkType = f;                                                                                        // 3613\n            return this;                                                                                               // 3614\n        };                                                                                                             // 3615\n        Layout.prototype.convergenceThreshold = function (x) {                                                         // 3616\n            if (!x)                                                                                                    // 3617\n                return this._threshold;                                                                                // 3618\n            this._threshold = typeof x === \"function\" ? x : +x;                                                        // 3619\n            return this;                                                                                               // 3620\n        };                                                                                                             // 3621\n        Layout.prototype.alpha = function (x) {                                                                        // 3622\n            if (!arguments.length)                                                                                     // 3623\n                return this._alpha;                                                                                    // 3624\n            else {                                                                                                     // 3625\n                x = +x;                                                                                                // 3626\n                if (this._alpha) {                                                                                     // 3627\n                    if (x > 0)                                                                                         // 3628\n                        this._alpha = x; // we might keep it hot                                                       // 3629\n                    else                                                                                               // 3630\n                        this._alpha = 0; // or, next tick will dispatch \"end\"                                          // 3631\n                }                                                                                                      // 3632\n                else if (x > 0) {                                                                                      // 3633\n                    if (!this._running) {                                                                              // 3634\n                        this._running = true;                                                                          // 3635\n                        this.trigger({ type: EventType.start, alpha: this._alpha = x });                               // 3636\n                        this.kick();                                                                                   // 3637\n                    }                                                                                                  // 3638\n                }                                                                                                      // 3639\n                return this;                                                                                           // 3640\n            }                                                                                                          // 3641\n        };                                                                                                             // 3642\n        Layout.prototype.getLinkLength = function (link) {                                                             // 3643\n            return typeof this._linkDistance === \"function\" ? +(this._linkDistance(link)) : this._linkDistance;        // 3644\n        };                                                                                                             // 3645\n        Layout.setLinkLength = function (link, length) {                                                               // 3646\n            link.length = length;                                                                                      // 3647\n        };                                                                                                             // 3648\n        Layout.prototype.getLinkType = function (link) {                                                               // 3649\n            return typeof this._linkType === \"function\" ? this._linkType(link) : 0;                                    // 3650\n        };                                                                                                             // 3651\n        /**                                                                                                            // 3652\n         * compute an ideal length for each link based on the graph structure around that link.                        // 3653\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.                      // 3654\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: sqrt(|a union b| - |a intersection b|)\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves             // 3657\n         * don't have to have been assigned before invoking this function.                                             // 3658\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)                         // 3660\n         */                                                                                                            // 3661\n        Layout.prototype.symmetricDiffLinkLengths = function (idealLength, w) {                                        // 3662\n            var _this = this;                                                                                          // 3663\n            if (w === void 0) { w = 1; }                                                                               // 3664\n            this.linkDistance(function (l) { return idealLength * l.length; });                                        // 3665\n            this._linkLengthCalculator = function () { return cola.symmetricDiffLinkLengths(_this._links, _this.linkAccessor, w); };\n            return this;                                                                                               // 3667\n        };                                                                                                             // 3668\n        /**                                                                                                            // 3669\n         * compute an ideal length for each link based on the graph structure around that link.                        // 3670\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.                      // 3671\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: |a intersection b|/|a union b|\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves             // 3674\n         * don't have to have been assigned before invoking this function.                                             // 3675\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)                         // 3677\n         */                                                                                                            // 3678\n        Layout.prototype.jaccardLinkLengths = function (idealLength, w) {                                              // 3679\n            var _this = this;                                                                                          // 3680\n            if (w === void 0) { w = 1; }                                                                               // 3681\n            this.linkDistance(function (l) { return idealLength * l.length; });                                        // 3682\n            this._linkLengthCalculator = function () { return cola.jaccardLinkLengths(_this._links, _this.linkAccessor, w); };\n            return this;                                                                                               // 3684\n        };                                                                                                             // 3685\n        /**                                                                                                            // 3686\n         * start the layout process                                                                                    // 3687\n         * @method start                                                                                               // 3688\n         * @param {number} [initialUnconstrainedIterations=0] unconstrained initial layout iterations                  // 3689\n         * @param {number} [initialUserConstraintIterations=0] initial layout iterations with user-specified constraints\n         * @param {number} [initialAllConstraintsIterations=0] initial layout iterations with all constraints including non-overlap\n         * @param {number} [gridSnapIterations=0] iterations of \"grid snap\", which pulls nodes towards grid cell centers - grid of size node[0].width - only really makes sense if all nodes have the same width and height\n         * @param [keepRunning=true] keep iterating asynchronously via the tick method                                 // 3693\n         */                                                                                                            // 3694\n        Layout.prototype.start = function (initialUnconstrainedIterations, initialUserConstraintIterations, initialAllConstraintsIterations, gridSnapIterations, keepRunning) {\n            var _this = this;                                                                                          // 3696\n            if (initialUnconstrainedIterations === void 0) { initialUnconstrainedIterations = 0; }                     // 3697\n            if (initialUserConstraintIterations === void 0) { initialUserConstraintIterations = 0; }                   // 3698\n            if (initialAllConstraintsIterations === void 0) { initialAllConstraintsIterations = 0; }                   // 3699\n            if (gridSnapIterations === void 0) { gridSnapIterations = 0; }                                             // 3700\n            if (keepRunning === void 0) { keepRunning = true; }                                                        // 3701\n            var i, j, n = this.nodes().length, N = n + 2 * this._groups.length, m = this._links.length, w = this._canvasSize[0], h = this._canvasSize[1];\n            if (this._linkLengthCalculator)                                                                            // 3703\n                this._linkLengthCalculator();                                                                          // 3704\n            var x = new Array(N), y = new Array(N);                                                                    // 3705\n            var G = null;                                                                                              // 3706\n            var ao = this._avoidOverlaps;                                                                              // 3707\n            this._nodes.forEach(function (v, i) {                                                                      // 3708\n                v.index = i;                                                                                           // 3709\n                if (typeof v.x === 'undefined') {                                                                      // 3710\n                    v.x = w / 2, v.y = h / 2;                                                                          // 3711\n                }                                                                                                      // 3712\n                x[i] = v.x, y[i] = v.y;                                                                                // 3713\n            });                                                                                                        // 3714\n            //should we do this to clearly label groups?                                                               // 3715\n            //this._groups.forEach((g, i) => g.groupIndex = i);                                                        // 3716\n            var distances;                                                                                             // 3717\n            if (this._distanceMatrix) {                                                                                // 3718\n                // use the user specified distanceMatrix                                                               // 3719\n                distances = this._distanceMatrix;                                                                      // 3720\n            }                                                                                                          // 3721\n            else {                                                                                                     // 3722\n                // construct an n X n distance matrix based on shortest paths through graph (with respect to edge.length).\n                distances = (new cola.shortestpaths.Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, function (l) { return _this.getLinkLength(l); })).DistanceMatrix();\n                // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j            // 3725\n                // otherwise 2. (                                                                                      // 3726\n                G = cola.Descent.createSquareMatrix(N, function () { return 2; });                                     // 3727\n                this._links.forEach(function (l) {                                                                     // 3728\n                    if (typeof l.source == \"number\")                                                                   // 3729\n                        l.source = _this._nodes[l.source];                                                             // 3730\n                    if (typeof l.target == \"number\")                                                                   // 3731\n                        l.target = _this._nodes[l.target];                                                             // 3732\n                });                                                                                                    // 3733\n                this._links.forEach(function (e) {                                                                     // 3734\n                    var u = Layout.getSourceIndex(e), v = Layout.getTargetIndex(e);                                    // 3735\n                    G[u][v] = G[v][u] = e.weight || 1;                                                                 // 3736\n                });                                                                                                    // 3737\n            }                                                                                                          // 3738\n            var D = cola.Descent.createSquareMatrix(N, function (i, j) {                                               // 3739\n                return distances[i][j];                                                                                // 3740\n            });                                                                                                        // 3741\n            if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {                                    // 3742\n                var i = n;                                                                                             // 3743\n                var addAttraction = function (i, j, strength, idealDistance) {                                         // 3744\n                    G[i][j] = G[j][i] = strength;                                                                      // 3745\n                    D[i][j] = D[j][i] = idealDistance;                                                                 // 3746\n                };                                                                                                     // 3747\n                this._groups.forEach(function (g) {                                                                    // 3748\n                    addAttraction(i, i + 1, _this._groupCompactness, 0.1);                                             // 3749\n                    // todo: add terms here attracting children of the group to the group dummy nodes                  // 3750\n                    //if (typeof g.leaves !== 'undefined')                                                             // 3751\n                    //    g.leaves.forEach(l => {                                                                      // 3752\n                    //        addAttraction(l.index, i, 1e-4, 0.1);                                                    // 3753\n                    //        addAttraction(l.index, i + 1, 1e-4, 0.1);                                                // 3754\n                    //    });                                                                                          // 3755\n                    //if (typeof g.groups !== 'undefined')                                                             // 3756\n                    //    g.groups.forEach(g => {                                                                      // 3757\n                    //        var gid = n + g.groupIndex * 2;                                                          // 3758\n                    //        addAttraction(gid, i, 0.1, 0.1);                                                         // 3759\n                    //        addAttraction(gid + 1, i, 0.1, 0.1);                                                     // 3760\n                    //        addAttraction(gid, i + 1, 0.1, 0.1);                                                     // 3761\n                    //        addAttraction(gid + 1, i + 1, 0.1, 0.1);                                                 // 3762\n                    //    });                                                                                          // 3763\n                    x[i] = 0, y[i++] = 0;                                                                              // 3764\n                    x[i] = 0, y[i++] = 0;                                                                              // 3765\n                });                                                                                                    // 3766\n            }                                                                                                          // 3767\n            else                                                                                                       // 3768\n                this._rootGroup = { leaves: this._nodes, groups: [] };                                                 // 3769\n            var curConstraints = this._constraints || [];                                                              // 3770\n            if (this._directedLinkConstraints) {                                                                       // 3771\n                this.linkAccessor.getMinSeparation = this._directedLinkConstraints.getMinSeparation;                   // 3772\n                curConstraints = curConstraints.concat(cola.generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, (this.linkAccessor)));\n            }                                                                                                          // 3774\n            this.avoidOverlaps(false);                                                                                 // 3775\n            this._descent = new cola.Descent([x, y], D);                                                               // 3776\n            this._descent.locks.clear();                                                                               // 3777\n            for (var i = 0; i < n; ++i) {                                                                              // 3778\n                var o = this._nodes[i];                                                                                // 3779\n                if (o.fixed) {                                                                                         // 3780\n                    o.px = o.x;                                                                                        // 3781\n                    o.py = o.y;                                                                                        // 3782\n                    var p = [o.x, o.y];                                                                                // 3783\n                    this._descent.locks.add(i, p);                                                                     // 3784\n                }                                                                                                      // 3785\n            }                                                                                                          // 3786\n            this._descent.threshold = this._threshold;                                                                 // 3787\n            // apply initialIterations without user constraints or nonoverlap constraints                              // 3788\n            // if groups are specified, dummy nodes and edges will be added to untangle                                // 3789\n            // with respect to group connectivity                                                                      // 3790\n            this.initialLayout(initialUnconstrainedIterations, x, y);                                                  // 3791\n            // apply initialIterations with user constraints but no nonoverlap constraints                             // 3792\n            if (curConstraints.length > 0)                                                                             // 3793\n                this._descent.project = new cola.vpsc.Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();\n            this._descent.run(initialUserConstraintIterations);                                                        // 3795\n            this.separateOverlappingComponents(w, h);                                                                  // 3796\n            // subsequent iterations will apply all constraints                                                        // 3797\n            this.avoidOverlaps(ao);                                                                                    // 3798\n            if (ao) {                                                                                                  // 3799\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });                                      // 3800\n                this._descent.project = new cola.vpsc.Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();\n                this._nodes.forEach(function (v, i) { x[i] = v.x, y[i] = v.y; });                                      // 3802\n            }                                                                                                          // 3803\n            // allow not immediately connected nodes to relax apart (p-stress)                                         // 3804\n            this._descent.G = G;                                                                                       // 3805\n            this._descent.run(initialAllConstraintsIterations);                                                        // 3806\n            if (gridSnapIterations) {                                                                                  // 3807\n                this._descent.snapStrength = 1000;                                                                     // 3808\n                this._descent.snapGridSize = this._nodes[0].width;                                                     // 3809\n                this._descent.numGridSnapNodes = n;                                                                    // 3810\n                this._descent.scaleSnapByMaxH = n != N; // if we have groups then need to scale hessian so grid forces still apply\n                var G0 = cola.Descent.createSquareMatrix(N, function (i, j) {                                          // 3812\n                    if (i >= n || j >= n)                                                                              // 3813\n                        return G[i][j];                                                                                // 3814\n                    return 0;                                                                                          // 3815\n                });                                                                                                    // 3816\n                this._descent.G = G0;                                                                                  // 3817\n                this._descent.run(gridSnapIterations);                                                                 // 3818\n            }                                                                                                          // 3819\n            this.updateNodePositions();                                                                                // 3820\n            this.separateOverlappingComponents(w, h);                                                                  // 3821\n            return keepRunning ? this.resume() : this;                                                                 // 3822\n        };                                                                                                             // 3823\n        Layout.prototype.initialLayout = function (iterations, x, y) {                                                 // 3824\n            if (this._groups.length > 0 && iterations > 0) {                                                           // 3825\n                // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children\n                // todo: edges attached to groups are replaced with edges connected to the corresponding group dummy node\n                var n = this._nodes.length;                                                                            // 3828\n                var edges = this._links.map(function (e) { return { source: e.source.index, target: e.target.index }; });\n                var vs = this._nodes.map(function (v) { return { index: v.index }; });                                 // 3830\n                this._groups.forEach(function (g, i) {                                                                 // 3831\n                    vs.push({ index: g.index = n + i });                                                               // 3832\n                });                                                                                                    // 3833\n                this._groups.forEach(function (g, i) {                                                                 // 3834\n                    if (typeof g.leaves !== 'undefined')                                                               // 3835\n                        g.leaves.forEach(function (v) { return edges.push({ source: g.index, target: v.index }); });   // 3836\n                    if (typeof g.groups !== 'undefined')                                                               // 3837\n                        g.groups.forEach(function (gg) { return edges.push({ source: g.index, target: gg.index }); });\n                });                                                                                                    // 3839\n                // layout the flat graph with dummy nodes and edges                                                    // 3840\n                new cola.Layout()                                                                                      // 3841\n                    .size(this.size())                                                                                 // 3842\n                    .nodes(vs)                                                                                         // 3843\n                    .links(edges)                                                                                      // 3844\n                    .avoidOverlaps(false)                                                                              // 3845\n                    .linkDistance(this.linkDistance())                                                                 // 3846\n                    .symmetricDiffLinkLengths(5)                                                                       // 3847\n                    .convergenceThreshold(1e-4)                                                                        // 3848\n                    .start(iterations, 0, 0, 0, false);                                                                // 3849\n                this._nodes.forEach(function (v) {                                                                     // 3850\n                    x[v.index] = vs[v.index].x;                                                                        // 3851\n                    y[v.index] = vs[v.index].y;                                                                        // 3852\n                });                                                                                                    // 3853\n            }                                                                                                          // 3854\n            else {                                                                                                     // 3855\n                this._descent.run(iterations);                                                                         // 3856\n            }                                                                                                          // 3857\n        };                                                                                                             // 3858\n        // recalculate nodes position for disconnected graphs                                                          // 3859\n        Layout.prototype.separateOverlappingComponents = function (width, height) {                                    // 3860\n            var _this = this;                                                                                          // 3861\n            // recalculate nodes position for disconnected graphs                                                      // 3862\n            if (!this._distanceMatrix && this._handleDisconnected) {                                                   // 3863\n                var x = this._descent.x[0], y = this._descent.x[1];                                                    // 3864\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });                                      // 3865\n                var graphs = cola.separateGraphs(this._nodes, this._links);                                            // 3866\n                cola.applyPacking(graphs, width, height, this._defaultNodeSize);                                       // 3867\n                this._nodes.forEach(function (v, i) {                                                                  // 3868\n                    _this._descent.x[0][i] = v.x, _this._descent.x[1][i] = v.y;                                        // 3869\n                    if (v.bounds) {                                                                                    // 3870\n                        v.bounds.setXCentre(v.x);                                                                      // 3871\n                        v.bounds.setYCentre(v.y);                                                                      // 3872\n                    }                                                                                                  // 3873\n                });                                                                                                    // 3874\n            }                                                                                                          // 3875\n        };                                                                                                             // 3876\n        Layout.prototype.resume = function () {                                                                        // 3877\n            return this.alpha(0.1);                                                                                    // 3878\n        };                                                                                                             // 3879\n        Layout.prototype.stop = function () {                                                                          // 3880\n            return this.alpha(0);                                                                                      // 3881\n        };                                                                                                             // 3882\n        /// find a visibility graph over the set of nodes.  assumes all nodes have a                                   // 3883\n        /// bounds property (a rectangle) and that no pair of bounds overlaps.                                         // 3884\n        Layout.prototype.prepareEdgeRouting = function (nodeMargin) {                                                  // 3885\n            if (nodeMargin === void 0) { nodeMargin = 0; }                                                             // 3886\n            this._visibilityGraph = new cola.geom.TangentVisibilityGraph(this._nodes.map(function (v) {                // 3887\n                return v.bounds.inflate(-nodeMargin).vertices();                                                       // 3888\n            }));                                                                                                       // 3889\n        };                                                                                                             // 3890\n        /// find a route avoiding node bounds for the given edge.                                                      // 3891\n        /// assumes the visibility graph has been created (by prepareEdgeRouting method)                               // 3892\n        /// and also assumes that nodes have an index property giving their position in the                            // 3893\n        /// node array.  This index property is created by the start() method.                                         // 3894\n        Layout.prototype.routeEdge = function (edge, draw) {                                                           // 3895\n            var lineData = [];                                                                                         // 3896\n            //if (d.source.id === 10 && d.target.id === 11) {                                                          // 3897\n            //    debugger;                                                                                            // 3898\n            //}                                                                                                        // 3899\n            var vg2 = new cola.geom.TangentVisibilityGraph(this._visibilityGraph.P, { V: this._visibilityGraph.V, E: this._visibilityGraph.E }), port1 = { x: edge.source.x, y: edge.source.y }, port2 = { x: edge.target.x, y: edge.target.y }, start = vg2.addPoint(port1, edge.source.index), end = vg2.addPoint(port2, edge.target.index);\n            vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);                                  // 3901\n            if (typeof draw !== 'undefined') {                                                                         // 3902\n                draw(vg2);                                                                                             // 3903\n            }                                                                                                          // 3904\n            var sourceInd = function (e) { return e.source.id; }, targetInd = function (e) { return e.target.id; }, length = function (e) { return e.length(); }, spCalc = new cola.shortestpaths.Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length), shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);\n            if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {                                   // 3906\n                var route = cola.vpsc.makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, 5);            // 3907\n                lineData = [route.sourceIntersection, route.arrowStart];                                               // 3908\n            }                                                                                                          // 3909\n            else {                                                                                                     // 3910\n                var n = shortestPath.length - 2, p = vg2.V[shortestPath[n]].p, q = vg2.V[shortestPath[0]].p, lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];\n                for (var i = n; i >= 0; --i)                                                                           // 3912\n                    lineData.push(vg2.V[shortestPath[i]].p);                                                           // 3913\n                lineData.push(cola.vpsc.makeEdgeTo(q, edge.target.innerBounds, 5));                                    // 3914\n            }                                                                                                          // 3915\n            //lineData.forEach((v, i) => {                                                                             // 3916\n            //    if (i > 0) {                                                                                         // 3917\n            //        var u = lineData[i - 1];                                                                         // 3918\n            //        this._nodes.forEach(function (node) {                                                            // 3919\n            //            if (node.id === getSourceIndex(d) || node.id === getTargetIndex(d)) return;                  // 3920\n            //            var ints = node.innerBounds.lineIntersections(u.x, u.y, v.x, v.y);                           // 3921\n            //            if (ints.length > 0) {                                                                       // 3922\n            //                debugger;                                                                                // 3923\n            //            }                                                                                            // 3924\n            //        })                                                                                               // 3925\n            //    }                                                                                                    // 3926\n            //})                                                                                                       // 3927\n            return lineData;                                                                                           // 3928\n        };                                                                                                             // 3929\n        //The link source and target may be just a node index, or they may be references to nodes themselves.          // 3930\n        Layout.getSourceIndex = function (e) {                                                                         // 3931\n            return typeof e.source === 'number' ? e.source : e.source.index;                                           // 3932\n        };                                                                                                             // 3933\n        //The link source and target may be just a node index, or they may be references to nodes themselves.          // 3934\n        Layout.getTargetIndex = function (e) {                                                                         // 3935\n            return typeof e.target === 'number' ? e.target : e.target.index;                                           // 3936\n        };                                                                                                             // 3937\n        // Get a string ID for a given link.                                                                           // 3938\n        Layout.linkId = function (e) {                                                                                 // 3939\n            return Layout.getSourceIndex(e) + \"-\" + Layout.getTargetIndex(e);                                          // 3940\n        };                                                                                                             // 3941\n        // The fixed property has three bits:                                                                          // 3942\n        // Bit 1 can be set externally (e.g., d.fixed = true) and show persist.                                        // 3943\n        // Bit 2 stores the dragging state, from mousedown to mouseup.                                                 // 3944\n        // Bit 3 stores the hover state, from mouseover to mouseout.                                                   // 3945\n        Layout.dragStart = function (d) {                                                                              // 3946\n            if (isGroup(d)) {                                                                                          // 3947\n                Layout.storeOffset(d, Layout.dragOrigin(d));                                                           // 3948\n            }                                                                                                          // 3949\n            else {                                                                                                     // 3950\n                Layout.stopNode(d);                                                                                    // 3951\n                d.fixed |= 2; // set bit 2                                                                             // 3952\n            }                                                                                                          // 3953\n        };                                                                                                             // 3954\n        // we clobber any existing desired positions for nodes                                                         // 3955\n        // in case another tick event occurs before the drag                                                           // 3956\n        Layout.stopNode = function (v) {                                                                               // 3957\n            v.px = v.x;                                                                                                // 3958\n            v.py = v.y;                                                                                                // 3959\n        };                                                                                                             // 3960\n        // we store offsets for each node relative to the centre of the ancestor group                                 // 3961\n        // being dragged in a pair of properties on the node                                                           // 3962\n        Layout.storeOffset = function (d, origin) {                                                                    // 3963\n            if (typeof d.leaves !== 'undefined') {                                                                     // 3964\n                d.leaves.forEach(function (v) {                                                                        // 3965\n                    v.fixed |= 2;                                                                                      // 3966\n                    Layout.stopNode(v);                                                                                // 3967\n                    v._dragGroupOffsetX = v.x - origin.x;                                                              // 3968\n                    v._dragGroupOffsetY = v.y - origin.y;                                                              // 3969\n                });                                                                                                    // 3970\n            }                                                                                                          // 3971\n            if (typeof d.groups !== 'undefined') {                                                                     // 3972\n                d.groups.forEach(function (g) { return Layout.storeOffset(g, origin); });                              // 3973\n            }                                                                                                          // 3974\n        };                                                                                                             // 3975\n        // the drag origin is taken as the centre of the node or group                                                 // 3976\n        Layout.dragOrigin = function (d) {                                                                             // 3977\n            if (isGroup(d)) {                                                                                          // 3978\n                return {                                                                                               // 3979\n                    x: d.bounds.cx(),                                                                                  // 3980\n                    y: d.bounds.cy()                                                                                   // 3981\n                };                                                                                                     // 3982\n            }                                                                                                          // 3983\n            else {                                                                                                     // 3984\n                return d;                                                                                              // 3985\n            }                                                                                                          // 3986\n        };                                                                                                             // 3987\n        // for groups, the drag translation is propagated down to all of the children of                               // 3988\n        // the group.                                                                                                  // 3989\n        Layout.drag = function (d, position) {                                                                         // 3990\n            if (isGroup(d)) {                                                                                          // 3991\n                if (typeof d.leaves !== 'undefined') {                                                                 // 3992\n                    d.leaves.forEach(function (v) {                                                                    // 3993\n                        d.bounds.setXCentre(position.x);                                                               // 3994\n                        d.bounds.setYCentre(position.y);                                                               // 3995\n                        v.px = v._dragGroupOffsetX + position.x;                                                       // 3996\n                        v.py = v._dragGroupOffsetY + position.y;                                                       // 3997\n                    });                                                                                                // 3998\n                }                                                                                                      // 3999\n                if (typeof d.groups !== 'undefined') {                                                                 // 4000\n                    d.groups.forEach(function (g) { return Layout.drag(g, position); });                               // 4001\n                }                                                                                                      // 4002\n            }                                                                                                          // 4003\n            else {                                                                                                     // 4004\n                d.px = position.x;                                                                                     // 4005\n                d.py = position.y;                                                                                     // 4006\n            }                                                                                                          // 4007\n        };                                                                                                             // 4008\n        // we unset only bits 2 and 3 so that the user can fix nodes with another a different                          // 4009\n        // bit such that the lock persists between drags                                                               // 4010\n        Layout.dragEnd = function (d) {                                                                                // 4011\n            if (isGroup(d)) {                                                                                          // 4012\n                if (typeof d.leaves !== 'undefined') {                                                                 // 4013\n                    d.leaves.forEach(function (v) {                                                                    // 4014\n                        Layout.dragEnd(v);                                                                             // 4015\n                        delete v._dragGroupOffsetX;                                                                    // 4016\n                        delete v._dragGroupOffsetY;                                                                    // 4017\n                    });                                                                                                // 4018\n                }                                                                                                      // 4019\n                if (typeof d.groups !== 'undefined') {                                                                 // 4020\n                    d.groups.forEach(Layout.dragEnd);                                                                  // 4021\n                }                                                                                                      // 4022\n            }                                                                                                          // 4023\n            else {                                                                                                     // 4024\n                d.fixed &= ~6; // unset bits 2 and 3                                                                   // 4025\n            }                                                                                                          // 4026\n        };                                                                                                             // 4027\n        // in d3 hover temporarily locks nodes, currently not used in cola                                             // 4028\n        Layout.mouseOver = function (d) {                                                                              // 4029\n            d.fixed |= 4; // set bit 3                                                                                 // 4030\n            d.px = d.x, d.py = d.y; // set velocity to zero                                                            // 4031\n        };                                                                                                             // 4032\n        // in d3 hover temporarily locks nodes, currently not used in cola                                             // 4033\n        Layout.mouseOut = function (d) {                                                                               // 4034\n            d.fixed &= ~4; // unset bit 3                                                                              // 4035\n        };                                                                                                             // 4036\n        return Layout;                                                                                                 // 4037\n    })();                                                                                                              // 4038\n    cola.Layout = Layout;                                                                                              // 4039\n})(cola || (cola = {}));                                                                                               // 4040\n///<reference path=\"../extern/d3.d.ts\"/>                                                                               // 4041\n///<reference path=\"layout.ts\"/>                                                                                       // 4042\nvar cola;                                                                                                              // 4043\n(function (cola) {                                                                                                     // 4044\n    var D3StyleLayoutAdaptor = (function (_super) {                                                                    // 4045\n        __extends(D3StyleLayoutAdaptor, _super);                                                                       // 4046\n        function D3StyleLayoutAdaptor() {                                                                              // 4047\n            _super.call(this);                                                                                         // 4048\n            this.event = d3.dispatch(cola.EventType[cola.EventType.start], cola.EventType[cola.EventType.tick], cola.EventType[cola.EventType.end]);\n            // bit of trickyness remapping 'this' so we can reference it in the function body.                         // 4050\n            var d3layout = this;                                                                                       // 4051\n            var drag;                                                                                                  // 4052\n            this.drag = function () {                                                                                  // 4053\n                if (!drag) {                                                                                           // 4054\n                    var drag = d3.behavior.drag()                                                                      // 4055\n                        .origin(cola.Layout.dragOrigin)                                                                // 4056\n                        .on(\"dragstart.d3adaptor\", cola.Layout.dragStart)                                              // 4057\n                        .on(\"drag.d3adaptor\", function (d) {                                                           // 4058\n                        cola.Layout.drag(d, d3.event);                                                                 // 4059\n                        d3layout.resume(); // restart annealing                                                        // 4060\n                    })                                                                                                 // 4061\n                        .on(\"dragend.d3adaptor\", cola.Layout.dragEnd);                                                 // 4062\n                }                                                                                                      // 4063\n                if (!arguments.length)                                                                                 // 4064\n                    return drag;                                                                                       // 4065\n                // this is the context of the function, i.e. the d3 selection                                          // 4066\n                this //.on(\"mouseover.adaptor\", colaMouseover)                                                         // 4067\n                    .call(drag);                                                                                       // 4068\n            };                                                                                                         // 4069\n        }                                                                                                              // 4070\n        D3StyleLayoutAdaptor.prototype.trigger = function (e) {                                                        // 4071\n            var d3event = { type: cola.EventType[e.type], alpha: e.alpha, stress: e.stress };                          // 4072\n            this.event[d3event.type](d3event); // via d3 dispatcher, e.g. event.start(e);                              // 4073\n        };                                                                                                             // 4074\n        // iterate layout using a d3.timer, which queues calls to tick repeatedly until tick returns true              // 4075\n        D3StyleLayoutAdaptor.prototype.kick = function () {                                                            // 4076\n            var _this = this;                                                                                          // 4077\n            d3.timer(function () { return _super.prototype.tick.call(_this); });                                       // 4078\n        };                                                                                                             // 4079\n        // a function for binding to events on the adapter                                                             // 4080\n        D3StyleLayoutAdaptor.prototype.on = function (eventType, listener) {                                           // 4081\n            if (typeof eventType === 'string') {                                                                       // 4082\n                this.event.on(eventType, listener);                                                                    // 4083\n            }                                                                                                          // 4084\n            else {                                                                                                     // 4085\n                this.event.on(cola.EventType[eventType], listener);                                                    // 4086\n            }                                                                                                          // 4087\n            return this;                                                                                               // 4088\n        };                                                                                                             // 4089\n        return D3StyleLayoutAdaptor;                                                                                   // 4090\n    })(cola.Layout);                                                                                                   // 4091\n    cola.D3StyleLayoutAdaptor = D3StyleLayoutAdaptor;                                                                  // 4092\n    /**                                                                                                                // 4093\n     * provides an interface for use with d3:                                                                          // 4094\n     * - uses the d3 event system to dispatch layout events such as:                                                   // 4095\n     *   o \"start\" (start layout process)                                                                              // 4096\n     *   o \"tick\" (after each layout iteration)                                                                        // 4097\n     *   o \"end\" (layout converged and complete).                                                                      // 4098\n     * - uses the d3 timer to queue layout iterations.                                                                 // 4099\n     * - sets up d3.behavior.drag to drag nodes                                                                        // 4100\n     *   o use `node.call(<the returned instance of Layout>.drag)` to make nodes draggable                             // 4101\n     * returns an instance of the cola.Layout itself with which the user                                               // 4102\n     * can interact directly.                                                                                          // 4103\n     */                                                                                                                // 4104\n    function d3adaptor() {                                                                                             // 4105\n        return new D3StyleLayoutAdaptor();                                                                             // 4106\n    }                                                                                                                  // 4107\n    cola.d3adaptor = d3adaptor;                                                                                        // 4108\n})(cola || (cola = {}));                                                                                               // 4109\n/// <reference path=\"rectangle.ts\"/>                                                                                   // 4110\n/// <reference path=\"shortestpaths.ts\"/>                                                                               // 4111\n/// <reference path=\"geom.ts\"/>                                                                                        // 4112\n/// <reference path=\"vpsc.ts\"/>                                                                                        // 4113\nvar cola;                                                                                                              // 4114\n(function (cola) {                                                                                                     // 4115\n    var NodeWrapper = (function () {                                                                                   // 4116\n        function NodeWrapper(id, rect, children) {                                                                     // 4117\n            this.id = id;                                                                                              // 4118\n            this.rect = rect;                                                                                          // 4119\n            this.children = children;                                                                                  // 4120\n            this.leaf = typeof children === 'undefined' || children.length === 0;                                      // 4121\n        }                                                                                                              // 4122\n        return NodeWrapper;                                                                                            // 4123\n    })();                                                                                                              // 4124\n    cola.NodeWrapper = NodeWrapper;                                                                                    // 4125\n    var Vert = (function () {                                                                                          // 4126\n        function Vert(id, x, y, node, line) {                                                                          // 4127\n            if (node === void 0) { node = null; }                                                                      // 4128\n            if (line === void 0) { line = null; }                                                                      // 4129\n            this.id = id;                                                                                              // 4130\n            this.x = x;                                                                                                // 4131\n            this.y = y;                                                                                                // 4132\n            this.node = node;                                                                                          // 4133\n            this.line = line;                                                                                          // 4134\n        }                                                                                                              // 4135\n        return Vert;                                                                                                   // 4136\n    })();                                                                                                              // 4137\n    cola.Vert = Vert;                                                                                                  // 4138\n    var LongestCommonSubsequence = (function () {                                                                      // 4139\n        function LongestCommonSubsequence(s, t) {                                                                      // 4140\n            this.s = s;                                                                                                // 4141\n            this.t = t;                                                                                                // 4142\n            var mf = LongestCommonSubsequence.findMatch(s, t);                                                         // 4143\n            var tr = t.slice(0).reverse();                                                                             // 4144\n            var mr = LongestCommonSubsequence.findMatch(s, tr);                                                        // 4145\n            if (mf.length >= mr.length) {                                                                              // 4146\n                this.length = mf.length;                                                                               // 4147\n                this.si = mf.si;                                                                                       // 4148\n                this.ti = mf.ti;                                                                                       // 4149\n                this.reversed = false;                                                                                 // 4150\n            }                                                                                                          // 4151\n            else {                                                                                                     // 4152\n                this.length = mr.length;                                                                               // 4153\n                this.si = mr.si;                                                                                       // 4154\n                this.ti = t.length - mr.ti - mr.length;                                                                // 4155\n                this.reversed = true;                                                                                  // 4156\n            }                                                                                                          // 4157\n        }                                                                                                              // 4158\n        LongestCommonSubsequence.findMatch = function (s, t) {                                                         // 4159\n            var m = s.length;                                                                                          // 4160\n            var n = t.length;                                                                                          // 4161\n            var match = { length: 0, si: -1, ti: -1 };                                                                 // 4162\n            var l = new Array(m);                                                                                      // 4163\n            for (var i = 0; i < m; i++) {                                                                              // 4164\n                l[i] = new Array(n);                                                                                   // 4165\n                for (var j = 0; j < n; j++)                                                                            // 4166\n                    if (s[i] === t[j]) {                                                                               // 4167\n                        var v = l[i][j] = (i === 0 || j === 0) ? 1 : l[i - 1][j - 1] + 1;                              // 4168\n                        if (v > match.length) {                                                                        // 4169\n                            match.length = v;                                                                          // 4170\n                            match.si = i - v + 1;                                                                      // 4171\n                            match.ti = j - v + 1;                                                                      // 4172\n                        }                                                                                              // 4173\n                        ;                                                                                              // 4174\n                    }                                                                                                  // 4175\n                    else                                                                                               // 4176\n                        l[i][j] = 0;                                                                                   // 4177\n            }                                                                                                          // 4178\n            return match;                                                                                              // 4179\n        };                                                                                                             // 4180\n        LongestCommonSubsequence.prototype.getSequence = function () {                                                 // 4181\n            return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];                               // 4182\n        };                                                                                                             // 4183\n        return LongestCommonSubsequence;                                                                               // 4184\n    })();                                                                                                              // 4185\n    cola.LongestCommonSubsequence = LongestCommonSubsequence;                                                          // 4186\n    var GridRouter = (function () {                                                                                    // 4187\n        function GridRouter(originalnodes, accessor, groupPadding) {                                                   // 4188\n            var _this = this;                                                                                          // 4189\n            if (groupPadding === void 0) { groupPadding = 12; }                                                        // 4190\n            this.originalnodes = originalnodes;                                                                        // 4191\n            this.groupPadding = groupPadding;                                                                          // 4192\n            this.leaves = null;                                                                                        // 4193\n            this.nodes = originalnodes.map(function (v, i) { return new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v)); });\n            this.leaves = this.nodes.filter(function (v) { return v.leaf; });                                          // 4195\n            this.groups = this.nodes.filter(function (g) { return !g.leaf; });                                         // 4196\n            this.cols = this.getGridLines('x');                                                                        // 4197\n            this.rows = this.getGridLines('y');                                                                        // 4198\n            // create parents for each node or group that is a member of another's children                            // 4199\n            this.groups.forEach(function (v) {                                                                         // 4200\n                return v.children.forEach(function (c) { return _this.nodes[c].parent = v; });                         // 4201\n            });                                                                                                        // 4202\n            // root claims the remaining orphans                                                                       // 4203\n            this.root = { children: [] };                                                                              // 4204\n            this.nodes.forEach(function (v) {                                                                          // 4205\n                if (typeof v.parent === 'undefined') {                                                                 // 4206\n                    v.parent = _this.root;                                                                             // 4207\n                    _this.root.children.push(v.id);                                                                    // 4208\n                }                                                                                                      // 4209\n                // each node will have grid vertices associated with it,                                               // 4210\n                // some inside the node and some on the boundary                                                       // 4211\n                // leaf nodes will have exactly one internal node at the center                                        // 4212\n                // and four boundary nodes                                                                             // 4213\n                // groups will have potentially many of each                                                           // 4214\n                v.ports = [];                                                                                          // 4215\n            });                                                                                                        // 4216\n            // nodes ordered by their position in the group hierarchy                                                  // 4217\n            this.backToFront = this.nodes.slice(0);                                                                    // 4218\n            this.backToFront.sort(function (x, y) { return _this.getDepth(x) - _this.getDepth(y); });                  // 4219\n            // compute boundary rectangles for each group                                                              // 4220\n            // has to be done from front to back, i.e. inside groups to outside groups                                 // 4221\n            // such that each can be made large enough to enclose its interior                                         // 4222\n            var frontToBackGroups = this.backToFront.slice(0).reverse().filter(function (g) { return !g.leaf; });      // 4223\n            frontToBackGroups.forEach(function (v) {                                                                   // 4224\n                var r = cola.vpsc.Rectangle.empty();                                                                   // 4225\n                v.children.forEach(function (c) { return r = r.union(_this.nodes[c].rect); });                         // 4226\n                v.rect = r.inflate(_this.groupPadding);                                                                // 4227\n            });                                                                                                        // 4228\n            var colMids = this.midPoints(this.cols.map(function (r) { return r.pos; }));                               // 4229\n            var rowMids = this.midPoints(this.rows.map(function (r) { return r.pos; }));                               // 4230\n            // setup extents of lines                                                                                  // 4231\n            var rowx = colMids[0], rowX = colMids[colMids.length - 1];                                                 // 4232\n            var coly = rowMids[0], colY = rowMids[rowMids.length - 1];                                                 // 4233\n            // horizontal lines                                                                                        // 4234\n            var hlines = this.rows.map(function (r) { return { x1: rowx, x2: rowX, y1: r.pos, y2: r.pos }; })          // 4235\n                .concat(rowMids.map(function (m) { return { x1: rowx, x2: rowX, y1: m, y2: m }; }));                   // 4236\n            // vertical lines                                                                                          // 4237\n            var vlines = this.cols.map(function (c) { return { x1: c.pos, x2: c.pos, y1: coly, y2: colY }; })          // 4238\n                .concat(colMids.map(function (m) { return { x1: m, x2: m, y1: coly, y2: colY }; }));                   // 4239\n            // the full set of lines                                                                                   // 4240\n            var lines = hlines.concat(vlines);                                                                         // 4241\n            // we record the vertices associated with each line                                                        // 4242\n            lines.forEach(function (l) { return l.verts = []; });                                                      // 4243\n            // the routing graph                                                                                       // 4244\n            this.verts = [];                                                                                           // 4245\n            this.edges = [];                                                                                           // 4246\n            // create vertices at the crossings of horizontal and vertical grid-lines                                  // 4247\n            hlines.forEach(function (h) {                                                                              // 4248\n                return vlines.forEach(function (v) {                                                                   // 4249\n                    var p = new Vert(_this.verts.length, v.x1, h.y1);                                                  // 4250\n                    h.verts.push(p);                                                                                   // 4251\n                    v.verts.push(p);                                                                                   // 4252\n                    _this.verts.push(p);                                                                               // 4253\n                    // assign vertices to the nodes immediately under them                                             // 4254\n                    var i = _this.backToFront.length;                                                                  // 4255\n                    while (i-- > 0) {                                                                                  // 4256\n                        var node = _this.backToFront[i], r = node.rect;                                                // 4257\n                        var dx = Math.abs(p.x - r.cx()), dy = Math.abs(p.y - r.cy());                                  // 4258\n                        if (dx < r.width() / 2 && dy < r.height() / 2) {                                               // 4259\n                            p.node = node;                                                                             // 4260\n                            break;                                                                                     // 4261\n                        }                                                                                              // 4262\n                    }                                                                                                  // 4263\n                });                                                                                                    // 4264\n            });                                                                                                        // 4265\n            lines.forEach(function (l, li) {                                                                           // 4266\n                // create vertices at the intersections of nodes and lines                                             // 4267\n                _this.nodes.forEach(function (v, i) {                                                                  // 4268\n                    v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach(function (intersect, j) {                 // 4269\n                        //console.log(li+','+i+','+j+':'+intersect.x + ',' + intersect.y);                             // 4270\n                        var p = new Vert(_this.verts.length, intersect.x, intersect.y, v, l);                          // 4271\n                        _this.verts.push(p);                                                                           // 4272\n                        l.verts.push(p);                                                                               // 4273\n                        v.ports.push(p);                                                                               // 4274\n                    });                                                                                                // 4275\n                });                                                                                                    // 4276\n                // split lines into edges joining vertices                                                             // 4277\n                var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;                                                             // 4278\n                var delta = function (a, b) { return isHoriz ? b.x - a.x : b.y - a.y; };                               // 4279\n                l.verts.sort(delta);                                                                                   // 4280\n                for (var i = 1; i < l.verts.length; i++) {                                                             // 4281\n                    var u = l.verts[i - 1], v = l.verts[i];                                                            // 4282\n                    if (u.node && u.node === v.node && u.node.leaf)                                                    // 4283\n                        continue;                                                                                      // 4284\n                    _this.edges.push({ source: u.id, target: v.id, length: Math.abs(delta(u, v)) });                   // 4285\n                }                                                                                                      // 4286\n            });                                                                                                        // 4287\n        }                                                                                                              // 4288\n        GridRouter.prototype.avg = function (a) { return a.reduce(function (x, y) { return x + y; }) / a.length; };    // 4289\n        // in the given axis, find sets of leaves overlapping in that axis                                             // 4290\n        // center of each GridLine is average of all nodes in column                                                   // 4291\n        GridRouter.prototype.getGridLines = function (axis) {                                                          // 4292\n            var columns = [];                                                                                          // 4293\n            var ls = this.leaves.slice(0, this.leaves.length);                                                         // 4294\n            while (ls.length > 0) {                                                                                    // 4295\n                // find a column of all leaves overlapping in axis with the first leaf                                 // 4296\n                var overlapping = ls.filter(function (v) { return v.rect['overlap' + axis.toUpperCase()](ls[0].rect); });\n                var col = {                                                                                            // 4298\n                    nodes: overlapping,                                                                                // 4299\n                    pos: this.avg(overlapping.map(function (v) { return v.rect['c' + axis](); }))                      // 4300\n                };                                                                                                     // 4301\n                columns.push(col);                                                                                     // 4302\n                col.nodes.forEach(function (v) { return ls.splice(ls.indexOf(v), 1); });                               // 4303\n            }                                                                                                          // 4304\n            columns.sort(function (a, b) { return a.pos - b.pos; });                                                   // 4305\n            return columns;                                                                                            // 4306\n        };                                                                                                             // 4307\n        // get the depth of the given node in the group hierarchy                                                      // 4308\n        GridRouter.prototype.getDepth = function (v) {                                                                 // 4309\n            var depth = 0;                                                                                             // 4310\n            while (v.parent !== this.root) {                                                                           // 4311\n                depth++;                                                                                               // 4312\n                v = v.parent;                                                                                          // 4313\n            }                                                                                                          // 4314\n            return depth;                                                                                              // 4315\n        };                                                                                                             // 4316\n        // medial axes between node centres and also boundary lines for the grid                                       // 4317\n        GridRouter.prototype.midPoints = function (a) {                                                                // 4318\n            var gap = a[1] - a[0];                                                                                     // 4319\n            var mids = [a[0] - gap / 2];                                                                               // 4320\n            for (var i = 1; i < a.length; i++) {                                                                       // 4321\n                mids.push((a[i] + a[i - 1]) / 2);                                                                      // 4322\n            }                                                                                                          // 4323\n            mids.push(a[a.length - 1] + gap / 2);                                                                      // 4324\n            return mids;                                                                                               // 4325\n        };                                                                                                             // 4326\n        // find path from v to root including both v and root                                                          // 4327\n        GridRouter.prototype.findLineage = function (v) {                                                              // 4328\n            var lineage = [v];                                                                                         // 4329\n            do {                                                                                                       // 4330\n                v = v.parent;                                                                                          // 4331\n                lineage.push(v);                                                                                       // 4332\n            } while (v !== this.root);                                                                                 // 4333\n            return lineage.reverse();                                                                                  // 4334\n        };                                                                                                             // 4335\n        // find path connecting a and b through their lowest common ancestor                                           // 4336\n        GridRouter.prototype.findAncestorPathBetween = function (a, b) {                                               // 4337\n            var aa = this.findLineage(a), ba = this.findLineage(b), i = 0;                                             // 4338\n            while (aa[i] === ba[i])                                                                                    // 4339\n                i++;                                                                                                   // 4340\n            // i-1 to include common ancestor only once (as first element)                                             // 4341\n            return { commonAncestor: aa[i - 1], lineages: aa.slice(i).concat(ba.slice(i)) };                           // 4342\n        };                                                                                                             // 4343\n        // when finding a path between two nodes a and b, siblings of a and b on the                                   // 4344\n        // paths from a and b to their least common ancestor are obstacles                                             // 4345\n        GridRouter.prototype.siblingObstacles = function (a, b) {                                                      // 4346\n            var _this = this;                                                                                          // 4347\n            var path = this.findAncestorPathBetween(a, b);                                                             // 4348\n            var lineageLookup = {};                                                                                    // 4349\n            path.lineages.forEach(function (v) { return lineageLookup[v.id] = {}; });                                  // 4350\n            var obstacles = path.commonAncestor.children.filter(function (v) { return !(v in lineageLookup); });       // 4351\n            path.lineages                                                                                              // 4352\n                .filter(function (v) { return v.parent !== path.commonAncestor; })                                     // 4353\n                .forEach(function (v) { return obstacles = obstacles.concat(v.parent.children.filter(function (c) { return c !== v.id; })); });\n            return obstacles.map(function (v) { return _this.nodes[v]; });                                             // 4355\n        };                                                                                                             // 4356\n        // for the given routes, extract all the segments orthogonal to the axis x                                     // 4357\n        // and return all them grouped by x position                                                                   // 4358\n        GridRouter.getSegmentSets = function (routes, x, y) {                                                          // 4359\n            // vsegments is a list of vertical segments sorted by x position                                           // 4360\n            var vsegments = [];                                                                                        // 4361\n            for (var ei = 0; ei < routes.length; ei++) {                                                               // 4362\n                var route = routes[ei];                                                                                // 4363\n                for (var si = 0; si < route.length; si++) {                                                            // 4364\n                    var s = route[si];                                                                                 // 4365\n                    s.edgeid = ei;                                                                                     // 4366\n                    s.i = si;                                                                                          // 4367\n                    var sdx = s[1][x] - s[0][x];                                                                       // 4368\n                    if (Math.abs(sdx) < 0.1) {                                                                         // 4369\n                        vsegments.push(s);                                                                             // 4370\n                    }                                                                                                  // 4371\n                }                                                                                                      // 4372\n            }                                                                                                          // 4373\n            vsegments.sort(function (a, b) { return a[0][x] - b[0][x]; });                                             // 4374\n            // vsegmentsets is a set of sets of segments grouped by x position                                         // 4375\n            var vsegmentsets = [];                                                                                     // 4376\n            var segmentset = null;                                                                                     // 4377\n            for (var i = 0; i < vsegments.length; i++) {                                                               // 4378\n                var s = vsegments[i];                                                                                  // 4379\n                if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {                                         // 4380\n                    segmentset = { pos: s[0][x], segments: [] };                                                       // 4381\n                    vsegmentsets.push(segmentset);                                                                     // 4382\n                }                                                                                                      // 4383\n                segmentset.segments.push(s);                                                                           // 4384\n            }                                                                                                          // 4385\n            return vsegmentsets;                                                                                       // 4386\n        };                                                                                                             // 4387\n        // for all segments in this bundle create a vpsc problem such that                                             // 4388\n        // each segment's x position is a variable and separation constraints                                          // 4389\n        // are given by the partial order over the edges to which the segments belong                                  // 4390\n        // for each pair s1,s2 of segments in the open set:                                                            // 4391\n        //   e1 = edge of s1, e2 = edge of s2                                                                          // 4392\n        //   if leftOf(e1,e2) create constraint s1.x + gap <= s2.x                                                     // 4393\n        //   else if leftOf(e2,e1) create cons. s2.x + gap <= s1.x                                                     // 4394\n        GridRouter.nudgeSegs = function (x, y, routes, segments, leftOf, gap) {                                        // 4395\n            var n = segments.length;                                                                                   // 4396\n            if (n <= 1)                                                                                                // 4397\n                return;                                                                                                // 4398\n            var vs = segments.map(function (s) { return new cola.vpsc.Variable(s[0][x]); });                           // 4399\n            var cs = [];                                                                                               // 4400\n            for (var i = 0; i < n; i++) {                                                                              // 4401\n                for (var j = 0; j < n; j++) {                                                                          // 4402\n                    if (i === j)                                                                                       // 4403\n                        continue;                                                                                      // 4404\n                    var s1 = segments[i], s2 = segments[j], e1 = s1.edgeid, e2 = s2.edgeid, lind = -1, rind = -1;      // 4405\n                    // in page coordinates (not cartesian) the notion of 'leftof' is flipped in the horizontal axis from the vertical axis\n                    // that is, when nudging vertical segments, if they increase in the y(conj) direction the segment belonging to the\n                    // 'left' edge actually needs to be nudged to the right                                            // 4408\n                    // when nudging horizontal segments, if the segments increase in the x direction                   // 4409\n                    // then the 'left' segment needs to go higher, i.e. to have y pos less than that of the right      // 4410\n                    if (x == 'x') {                                                                                    // 4411\n                        if (leftOf(e1, e2)) {                                                                          // 4412\n                            //console.log('s1: ' + s1[0][x] + ',' + s1[0][y] + '-' + s1[1][x] + ',' + s1[1][y]);       // 4413\n                            if (s1[0][y] < s1[1][y]) {                                                                 // 4414\n                                lind = j, rind = i;                                                                    // 4415\n                            }                                                                                          // 4416\n                            else {                                                                                     // 4417\n                                lind = i, rind = j;                                                                    // 4418\n                            }                                                                                          // 4419\n                        }                                                                                              // 4420\n                    }                                                                                                  // 4421\n                    else {                                                                                             // 4422\n                        if (leftOf(e1, e2)) {                                                                          // 4423\n                            if (s1[0][y] < s1[1][y]) {                                                                 // 4424\n                                lind = i, rind = j;                                                                    // 4425\n                            }                                                                                          // 4426\n                            else {                                                                                     // 4427\n                                lind = j, rind = i;                                                                    // 4428\n                            }                                                                                          // 4429\n                        }                                                                                              // 4430\n                    }                                                                                                  // 4431\n                    if (lind >= 0) {                                                                                   // 4432\n                        //console.log(x+' constraint: ' + lind + '<' + rind);                                          // 4433\n                        cs.push(new cola.vpsc.Constraint(vs[lind], vs[rind], gap));                                    // 4434\n                    }                                                                                                  // 4435\n                }                                                                                                      // 4436\n            }                                                                                                          // 4437\n            var solver = new cola.vpsc.Solver(vs, cs);                                                                 // 4438\n            solver.solve();                                                                                            // 4439\n            vs.forEach(function (v, i) {                                                                               // 4440\n                var s = segments[i];                                                                                   // 4441\n                var pos = v.position();                                                                                // 4442\n                s[0][x] = s[1][x] = pos;                                                                               // 4443\n                var route = routes[s.edgeid];                                                                          // 4444\n                if (s.i > 0)                                                                                           // 4445\n                    route[s.i - 1][1][x] = pos;                                                                        // 4446\n                if (s.i < route.length - 1)                                                                            // 4447\n                    route[s.i + 1][0][x] = pos;                                                                        // 4448\n            });                                                                                                        // 4449\n        };                                                                                                             // 4450\n        GridRouter.nudgeSegments = function (routes, x, y, leftOf, gap) {                                              // 4451\n            var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);                                                // 4452\n            // scan the grouped (by x) segment sets to find co-linear bundles                                          // 4453\n            for (var i = 0; i < vsegmentsets.length; i++) {                                                            // 4454\n                var ss = vsegmentsets[i];                                                                              // 4455\n                var events = [];                                                                                       // 4456\n                for (var j = 0; j < ss.segments.length; j++) {                                                         // 4457\n                    var s = ss.segments[j];                                                                            // 4458\n                    events.push({ type: 0, s: s, pos: Math.min(s[0][y], s[1][y]) });                                   // 4459\n                    events.push({ type: 1, s: s, pos: Math.max(s[0][y], s[1][y]) });                                   // 4460\n                }                                                                                                      // 4461\n                events.sort(function (a, b) { return a.pos - b.pos + a.type - b.type; });                              // 4462\n                var open = [];                                                                                         // 4463\n                var openCount = 0;                                                                                     // 4464\n                events.forEach(function (e) {                                                                          // 4465\n                    if (e.type === 0) {                                                                                // 4466\n                        open.push(e.s);                                                                                // 4467\n                        openCount++;                                                                                   // 4468\n                    }                                                                                                  // 4469\n                    else {                                                                                             // 4470\n                        openCount--;                                                                                   // 4471\n                    }                                                                                                  // 4472\n                    if (openCount == 0) {                                                                              // 4473\n                        GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);                                         // 4474\n                        open = [];                                                                                     // 4475\n                    }                                                                                                  // 4476\n                });                                                                                                    // 4477\n            }                                                                                                          // 4478\n        };                                                                                                             // 4479\n        // obtain routes for the specified edges, nicely nudged apart                                                  // 4480\n        // warning: edge paths may be reversed such that common paths are ordered consistently within bundles!         // 4481\n        // @param edges list of edges                                                                                  // 4482\n        // @param nudgeGap how much to space parallel edge segements                                                   // 4483\n        // @param source function to retrieve the index of the source node for a given edge                            // 4484\n        // @param target function to retrieve the index of the target node for a given edge                            // 4485\n        // @returns an array giving, for each edge, an array of segments, each segment a pair of points in an array    // 4486\n        GridRouter.prototype.routeEdges = function (edges, nudgeGap, source, target) {                                 // 4487\n            var _this = this;                                                                                          // 4488\n            var routePaths = edges.map(function (e) { return _this.route(source(e), target(e)); });                    // 4489\n            var order = cola.GridRouter.orderEdges(routePaths);                                                        // 4490\n            var routes = routePaths.map(function (e) { return cola.GridRouter.makeSegments(e); });                     // 4491\n            cola.GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);                                          // 4492\n            cola.GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);                                          // 4493\n            cola.GridRouter.unreverseEdges(routes, routePaths);                                                        // 4494\n            return routes;                                                                                             // 4495\n        };                                                                                                             // 4496\n        // path may have been reversed by the subsequence processing in orderEdges                                     // 4497\n        // so now we need to restore the original order                                                                // 4498\n        GridRouter.unreverseEdges = function (routes, routePaths) {                                                    // 4499\n            routes.forEach(function (segments, i) {                                                                    // 4500\n                var path = routePaths[i];                                                                              // 4501\n                if (path.reversed) {                                                                                   // 4502\n                    segments.reverse(); // reverse order of segments                                                   // 4503\n                    segments.forEach(function (segment) {                                                              // 4504\n                        segment.reverse(); // reverse each segment                                                     // 4505\n                    });                                                                                                // 4506\n                }                                                                                                      // 4507\n            });                                                                                                        // 4508\n        };                                                                                                             // 4509\n        GridRouter.angleBetween2Lines = function (line1, line2) {                                                      // 4510\n            var angle1 = Math.atan2(line1[0].y - line1[1].y, line1[0].x - line1[1].x);                                 // 4511\n            var angle2 = Math.atan2(line2[0].y - line2[1].y, line2[0].x - line2[1].x);                                 // 4512\n            var diff = angle1 - angle2;                                                                                // 4513\n            if (diff > Math.PI || diff < -Math.PI) {                                                                   // 4514\n                diff = angle2 - angle1;                                                                                // 4515\n            }                                                                                                          // 4516\n            return diff;                                                                                               // 4517\n        };                                                                                                             // 4518\n        // does the path a-b-c describe a left turn?                                                                   // 4519\n        GridRouter.isLeft = function (a, b, c) {                                                                       // 4520\n            return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) <= 0;                                       // 4521\n        };                                                                                                             // 4522\n        // for the given list of ordered pairs, returns a function that (efficiently) looks-up a specific pair to      // 4523\n        // see if it exists in the list                                                                                // 4524\n        GridRouter.getOrder = function (pairs) {                                                                       // 4525\n            var outgoing = {};                                                                                         // 4526\n            for (var i = 0; i < pairs.length; i++) {                                                                   // 4527\n                var p = pairs[i];                                                                                      // 4528\n                if (typeof outgoing[p.l] === 'undefined')                                                              // 4529\n                    outgoing[p.l] = {};                                                                                // 4530\n                outgoing[p.l][p.r] = true;                                                                             // 4531\n            }                                                                                                          // 4532\n            return function (l, r) { return typeof outgoing[l] !== 'undefined' && outgoing[l][r]; };                   // 4533\n        };                                                                                                             // 4534\n        // returns an ordering (a lookup function) that determines the correct order to nudge the                      // 4535\n        // edge paths apart to minimize crossings                                                                      // 4536\n        GridRouter.orderEdges = function (edges) {                                                                     // 4537\n            var edgeOrder = [];                                                                                        // 4538\n            for (var i = 0; i < edges.length - 1; i++) {                                                               // 4539\n                for (var j = i + 1; j < edges.length; j++) {                                                           // 4540\n                    var e = edges[i], f = edges[j], lcs = new cola.LongestCommonSubsequence(e, f);                     // 4541\n                    var u, vi, vj;                                                                                     // 4542\n                    if (lcs.length === 0)                                                                              // 4543\n                        continue; // no common subpath                                                                 // 4544\n                    if (lcs.reversed) {                                                                                // 4545\n                        // if we found a common subpath but one of the edges runs the wrong way,                       // 4546\n                        // then reverse f.                                                                             // 4547\n                        f.reverse();                                                                                   // 4548\n                        f.reversed = true;                                                                             // 4549\n                        lcs = new cola.LongestCommonSubsequence(e, f);                                                 // 4550\n                    }                                                                                                  // 4551\n                    if ((lcs.si <= 0 || lcs.ti <= 0) &&                                                                // 4552\n                        (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {                        // 4553\n                        // the paths do not diverge, so make an arbitrary ordering decision                            // 4554\n                        edgeOrder.push({ l: i, r: j });                                                                // 4555\n                        continue;                                                                                      // 4556\n                    }                                                                                                  // 4557\n                    if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {                          // 4558\n                        // if the common subsequence of the                                                            // 4559\n                        // two edges being considered goes all the way to the                                          // 4560\n                        // end of one (or both) of the lines then we have to                                           // 4561\n                        // base our ordering decision on the other end of the                                          // 4562\n                        // common subsequence                                                                          // 4563\n                        u = e[lcs.si + 1];                                                                             // 4564\n                        vj = e[lcs.si - 1];                                                                            // 4565\n                        vi = f[lcs.ti - 1];                                                                            // 4566\n                    }                                                                                                  // 4567\n                    else {                                                                                             // 4568\n                        u = e[lcs.si + lcs.length - 2];                                                                // 4569\n                        vi = e[lcs.si + lcs.length];                                                                   // 4570\n                        vj = f[lcs.ti + lcs.length];                                                                   // 4571\n                    }                                                                                                  // 4572\n                    if (GridRouter.isLeft(u, vi, vj)) {                                                                // 4573\n                        edgeOrder.push({ l: j, r: i });                                                                // 4574\n                    }                                                                                                  // 4575\n                    else {                                                                                             // 4576\n                        edgeOrder.push({ l: i, r: j });                                                                // 4577\n                    }                                                                                                  // 4578\n                }                                                                                                      // 4579\n            }                                                                                                          // 4580\n            //edgeOrder.forEach(function (e) { console.log('l:' + e.l + ',r:' + e.r) });                               // 4581\n            return cola.GridRouter.getOrder(edgeOrder);                                                                // 4582\n        };                                                                                                             // 4583\n        // for an orthogonal path described by a sequence of points, create a list of segments                         // 4584\n        // if consecutive segments would make a straight line they are merged into a single segment                    // 4585\n        // segments are over cloned points, not the original vertices                                                  // 4586\n        GridRouter.makeSegments = function (path) {                                                                    // 4587\n            function copyPoint(p) {                                                                                    // 4588\n                return { x: p.x, y: p.y };                                                                             // 4589\n            }                                                                                                          // 4590\n            var isStraight = function (a, b, c) { return Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001; };\n            var segments = [];                                                                                         // 4592\n            var a = copyPoint(path[0]);                                                                                // 4593\n            for (var i = 1; i < path.length; i++) {                                                                    // 4594\n                var b = copyPoint(path[i]), c = i < path.length - 1 ? path[i + 1] : null;                              // 4595\n                if (!c || !isStraight(a, b, c)) {                                                                      // 4596\n                    segments.push([a, b]);                                                                             // 4597\n                    a = b;                                                                                             // 4598\n                }                                                                                                      // 4599\n            }                                                                                                          // 4600\n            return segments;                                                                                           // 4601\n        };                                                                                                             // 4602\n        // find a route between node s and node t                                                                      // 4603\n        // returns an array of indices to verts                                                                        // 4604\n        GridRouter.prototype.route = function (s, t) {                                                                 // 4605\n            var _this = this;                                                                                          // 4606\n            var source = this.nodes[s], target = this.nodes[t];                                                        // 4607\n            this.obstacles = this.siblingObstacles(source, target);                                                    // 4608\n            var obstacleLookup = {};                                                                                   // 4609\n            this.obstacles.forEach(function (o) { return obstacleLookup[o.id] = o; });                                 // 4610\n            this.passableEdges = this.edges.filter(function (e) {                                                      // 4611\n                var u = _this.verts[e.source], v = _this.verts[e.target];                                              // 4612\n                return !(u.node && u.node.id in obstacleLookup                                                         // 4613\n                    || v.node && v.node.id in obstacleLookup);                                                         // 4614\n            });                                                                                                        // 4615\n            // add dummy segments linking ports inside source and target                                               // 4616\n            for (var i = 1; i < source.ports.length; i++) {                                                            // 4617\n                var u = source.ports[0].id;                                                                            // 4618\n                var v = source.ports[i].id;                                                                            // 4619\n                this.passableEdges.push({                                                                              // 4620\n                    source: u,                                                                                         // 4621\n                    target: v,                                                                                         // 4622\n                    length: 0                                                                                          // 4623\n                });                                                                                                    // 4624\n            }                                                                                                          // 4625\n            for (var i = 1; i < target.ports.length; i++) {                                                            // 4626\n                var u = target.ports[0].id;                                                                            // 4627\n                var v = target.ports[i].id;                                                                            // 4628\n                this.passableEdges.push({                                                                              // 4629\n                    source: u,                                                                                         // 4630\n                    target: v,                                                                                         // 4631\n                    length: 0                                                                                          // 4632\n                });                                                                                                    // 4633\n            }                                                                                                          // 4634\n            var getSource = function (e) { return e.source; }, getTarget = function (e) { return e.target; }, getLength = function (e) { return e.length; };\n            var shortestPathCalculator = new cola.shortestpaths.Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);\n            var bendPenalty = function (u, v, w) {                                                                     // 4637\n                var a = _this.verts[u], b = _this.verts[v], c = _this.verts[w];                                        // 4638\n                var dx = Math.abs(c.x - a.x), dy = Math.abs(c.y - a.y);                                                // 4639\n                // don't count bends from internal node edges                                                          // 4640\n                if (a.node === source && a.node === b.node || b.node === target && b.node === c.node)                  // 4641\n                    return 0;                                                                                          // 4642\n                return dx > 1 && dy > 1 ? 1000 : 0;                                                                    // 4643\n            };                                                                                                         // 4644\n            // get shortest path                                                                                       // 4645\n            var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(source.ports[0].id, target.ports[0].id, bendPenalty);\n            // shortest path is reversed and does not include the target port                                          // 4647\n            var pathPoints = shortestPath.reverse().map(function (vi) { return _this.verts[vi]; });                    // 4648\n            pathPoints.push(this.nodes[target.id].ports[0]);                                                           // 4649\n            // filter out any extra end points that are inside the source or target (i.e. the dummy segments above)    // 4650\n            return pathPoints.filter(function (v, i) {                                                                 // 4651\n                return !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source           // 4652\n                    || i > 0 && v.node === target && pathPoints[i - 1].node === target);                               // 4653\n            });                                                                                                        // 4654\n        };                                                                                                             // 4655\n        GridRouter.getRoutePath = function (route, cornerradius, arrowwidth, arrowheight) {                            // 4656\n            var result = {                                                                                             // 4657\n                routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',                                           // 4658\n                arrowpath: ''                                                                                          // 4659\n            };                                                                                                         // 4660\n            if (route.length > 1) {                                                                                    // 4661\n                for (var i = 0; i < route.length; i++) {                                                               // 4662\n                    var li = route[i];                                                                                 // 4663\n                    var x = li[1].x, y = li[1].y;                                                                      // 4664\n                    var dx = x - li[0].x;                                                                              // 4665\n                    var dy = y - li[0].y;                                                                              // 4666\n                    if (i < route.length - 1) {                                                                        // 4667\n                        if (Math.abs(dx) > 0) {                                                                        // 4668\n                            x -= dx / Math.abs(dx) * cornerradius;                                                     // 4669\n                        }                                                                                              // 4670\n                        else {                                                                                         // 4671\n                            y -= dy / Math.abs(dy) * cornerradius;                                                     // 4672\n                        }                                                                                              // 4673\n                        result.routepath += 'L ' + x + ' ' + y + ' ';                                                  // 4674\n                        var l = route[i + 1];                                                                          // 4675\n                        var x0 = l[0].x, y0 = l[0].y;                                                                  // 4676\n                        var x1 = l[1].x;                                                                               // 4677\n                        var y1 = l[1].y;                                                                               // 4678\n                        dx = x1 - x0;                                                                                  // 4679\n                        dy = y1 - y0;                                                                                  // 4680\n                        var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;                                  // 4681\n                        //console.log(cola.GridRouter.angleBetween2Lines(li, l))                                       // 4682\n                        var x2, y2;                                                                                    // 4683\n                        if (Math.abs(dx) > 0) {                                                                        // 4684\n                            x2 = x0 + dx / Math.abs(dx) * cornerradius;                                                // 4685\n                            y2 = y0;                                                                                   // 4686\n                        }                                                                                              // 4687\n                        else {                                                                                         // 4688\n                            x2 = x0;                                                                                   // 4689\n                            y2 = y0 + dy / Math.abs(dy) * cornerradius;                                                // 4690\n                        }                                                                                              // 4691\n                        var cx = Math.abs(x2 - x);                                                                     // 4692\n                        var cy = Math.abs(y2 - y);                                                                     // 4693\n                        result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';        // 4694\n                    }                                                                                                  // 4695\n                    else {                                                                                             // 4696\n                        var arrowtip = [x, y];                                                                         // 4697\n                        var arrowcorner1, arrowcorner2;                                                                // 4698\n                        if (Math.abs(dx) > 0) {                                                                        // 4699\n                            x -= dx / Math.abs(dx) * arrowheight;                                                      // 4700\n                            arrowcorner1 = [x, y + arrowwidth];                                                        // 4701\n                            arrowcorner2 = [x, y - arrowwidth];                                                        // 4702\n                        }                                                                                              // 4703\n                        else {                                                                                         // 4704\n                            y -= dy / Math.abs(dy) * arrowheight;                                                      // 4705\n                            arrowcorner1 = [x + arrowwidth, y];                                                        // 4706\n                            arrowcorner2 = [x - arrowwidth, y];                                                        // 4707\n                        }                                                                                              // 4708\n                        result.routepath += 'L ' + x + ' ' + y + ' ';                                                  // 4709\n                        if (arrowheight > 0) {                                                                         // 4710\n                            result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\n                                + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];                                     // 4712\n                        }                                                                                              // 4713\n                    }                                                                                                  // 4714\n                }                                                                                                      // 4715\n            }                                                                                                          // 4716\n            else {                                                                                                     // 4717\n                var li = route[0];                                                                                     // 4718\n                var x = li[1].x, y = li[1].y;                                                                          // 4719\n                var dx = x - li[0].x;                                                                                  // 4720\n                var dy = y - li[0].y;                                                                                  // 4721\n                var arrowtip = [x, y];                                                                                 // 4722\n                var arrowcorner1, arrowcorner2;                                                                        // 4723\n                if (Math.abs(dx) > 0) {                                                                                // 4724\n                    x -= dx / Math.abs(dx) * arrowheight;                                                              // 4725\n                    arrowcorner1 = [x, y + arrowwidth];                                                                // 4726\n                    arrowcorner2 = [x, y - arrowwidth];                                                                // 4727\n                }                                                                                                      // 4728\n                else {                                                                                                 // 4729\n                    y -= dy / Math.abs(dy) * arrowheight;                                                              // 4730\n                    arrowcorner1 = [x + arrowwidth, y];                                                                // 4731\n                    arrowcorner2 = [x - arrowwidth, y];                                                                // 4732\n                }                                                                                                      // 4733\n                result.routepath += 'L ' + x + ' ' + y + ' ';                                                          // 4734\n                if (arrowheight > 0) {                                                                                 // 4735\n                    result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\n                        + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];                                             // 4737\n                }                                                                                                      // 4738\n            }                                                                                                          // 4739\n            return result;                                                                                             // 4740\n        };                                                                                                             // 4741\n        return GridRouter;                                                                                             // 4742\n    })();                                                                                                              // 4743\n    cola.GridRouter = GridRouter;                                                                                      // 4744\n})(cola || (cola = {}));                                                                                               // 4745\n/**                                                                                                                    // 4746\n * Use cola to do a layout in 3D!! Yay.                                                                                // 4747\n * Pretty simple for the moment.                                                                                       // 4748\n */                                                                                                                    // 4749\nvar cola;                                                                                                              // 4750\n(function (cola) {                                                                                                     // 4751\n    var Link3D = (function () {                                                                                        // 4752\n        function Link3D(source, target) {                                                                              // 4753\n            this.source = source;                                                                                      // 4754\n            this.target = target;                                                                                      // 4755\n        }                                                                                                              // 4756\n        Link3D.prototype.actualLength = function (x) {                                                                 // 4757\n            var _this = this;                                                                                          // 4758\n            return Math.sqrt(x.reduce(function (c, v) {                                                                // 4759\n                var dx = v[_this.target] - v[_this.source];                                                            // 4760\n                return c + dx * dx;                                                                                    // 4761\n            }, 0));                                                                                                    // 4762\n        };                                                                                                             // 4763\n        return Link3D;                                                                                                 // 4764\n    })();                                                                                                              // 4765\n    cola.Link3D = Link3D;                                                                                              // 4766\n    var Node3D = (function () {                                                                                        // 4767\n        function Node3D(x, y, z) {                                                                                     // 4768\n            if (x === void 0) { x = 0; }                                                                               // 4769\n            if (y === void 0) { y = 0; }                                                                               // 4770\n            if (z === void 0) { z = 0; }                                                                               // 4771\n            this.x = x;                                                                                                // 4772\n            this.y = y;                                                                                                // 4773\n            this.z = z;                                                                                                // 4774\n        }                                                                                                              // 4775\n        return Node3D;                                                                                                 // 4776\n    })();                                                                                                              // 4777\n    cola.Node3D = Node3D;                                                                                              // 4778\n    var Layout3D = (function () {                                                                                      // 4779\n        function Layout3D(nodes, links, idealLinkLength) {                                                             // 4780\n            var _this = this;                                                                                          // 4781\n            if (idealLinkLength === void 0) { idealLinkLength = 1; }                                                   // 4782\n            this.nodes = nodes;                                                                                        // 4783\n            this.links = links;                                                                                        // 4784\n            this.idealLinkLength = idealLinkLength;                                                                    // 4785\n            this.constraints = null;                                                                                   // 4786\n            this.useJaccardLinkLengths = true;                                                                         // 4787\n            this.result = new Array(Layout3D.k);                                                                       // 4788\n            for (var i = 0; i < Layout3D.k; ++i) {                                                                     // 4789\n                this.result[i] = new Array(nodes.length);                                                              // 4790\n            }                                                                                                          // 4791\n            nodes.forEach(function (v, i) {                                                                            // 4792\n                for (var _i = 0, _a = Layout3D.dims; _i < _a.length; _i++) {                                           // 4793\n                    var dim = _a[_i];                                                                                  // 4794\n                    if (typeof v[dim] == 'undefined')                                                                  // 4795\n                        v[dim] = Math.random();                                                                        // 4796\n                }                                                                                                      // 4797\n                _this.result[0][i] = v.x;                                                                              // 4798\n                _this.result[1][i] = v.y;                                                                              // 4799\n                _this.result[2][i] = v.z;                                                                              // 4800\n            });                                                                                                        // 4801\n        }                                                                                                              // 4802\n        ;                                                                                                              // 4803\n        Layout3D.prototype.linkLength = function (l) {                                                                 // 4804\n            return l.actualLength(this.result);                                                                        // 4805\n        };                                                                                                             // 4806\n        Layout3D.prototype.start = function (iterations) {                                                             // 4807\n            var _this = this;                                                                                          // 4808\n            if (iterations === void 0) { iterations = 100; }                                                           // 4809\n            var n = this.nodes.length;                                                                                 // 4810\n            var linkAccessor = new LinkAccessor();                                                                     // 4811\n            if (this.useJaccardLinkLengths)                                                                            // 4812\n                cola.jaccardLinkLengths(this.links, linkAccessor, 1.5);                                                // 4813\n            this.links.forEach(function (e) { return e.length *= _this.idealLinkLength; });                            // 4814\n            // Create the distance matrix that Cola needs                                                              // 4815\n            var distanceMatrix = (new cola.shortestpaths.Calculator(n, this.links, function (e) { return e.source; }, function (e) { return e.target; }, function (e) { return e.length; })).DistanceMatrix();\n            var D = cola.Descent.createSquareMatrix(n, function (i, j) { return distanceMatrix[i][j]; });              // 4817\n            // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j                // 4818\n            // otherwise 2.                                                                                            // 4819\n            var G = cola.Descent.createSquareMatrix(n, function () { return 2; });                                     // 4820\n            this.links.forEach(function (_a) {                                                                         // 4821\n                var source = _a.source, target = _a.target;                                                            // 4822\n                return G[source][target] = G[target][source] = 1;                                                      // 4823\n            });                                                                                                        // 4824\n            this.descent = new cola.Descent(this.result, D);                                                           // 4825\n            this.descent.threshold = 1e-3;                                                                             // 4826\n            this.descent.G = G;                                                                                        // 4827\n            //let constraints = this.links.map(e=> <any>{                                                              // 4828\n            //    axis: 'y', left: e.source, right: e.target, gap: e.length*1.5                                        // 4829\n            //});                                                                                                      // 4830\n            if (this.constraints)                                                                                      // 4831\n                this.descent.project = new cola.vpsc.Projection(this.nodes, null, null, this.constraints).projectFunctions();\n            for (var i = 0; i < this.nodes.length; i++) {                                                              // 4833\n                var v = this.nodes[i];                                                                                 // 4834\n                if (v.fixed) {                                                                                         // 4835\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);                                                        // 4836\n                }                                                                                                      // 4837\n            }                                                                                                          // 4838\n            this.descent.run(iterations);                                                                              // 4839\n            return this;                                                                                               // 4840\n        };                                                                                                             // 4841\n        Layout3D.prototype.tick = function () {                                                                        // 4842\n            this.descent.locks.clear();                                                                                // 4843\n            for (var i = 0; i < this.nodes.length; i++) {                                                              // 4844\n                var v = this.nodes[i];                                                                                 // 4845\n                if (v.fixed) {                                                                                         // 4846\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);                                                        // 4847\n                }                                                                                                      // 4848\n            }                                                                                                          // 4849\n            return this.descent.rungeKutta();                                                                          // 4850\n        };                                                                                                             // 4851\n        Layout3D.dims = ['x', 'y', 'z'];                                                                               // 4852\n        Layout3D.k = Layout3D.dims.length;                                                                             // 4853\n        return Layout3D;                                                                                               // 4854\n    })();                                                                                                              // 4855\n    cola.Layout3D = Layout3D;                                                                                          // 4856\n    var LinkAccessor = (function () {                                                                                  // 4857\n        function LinkAccessor() {                                                                                      // 4858\n        }                                                                                                              // 4859\n        LinkAccessor.prototype.getSourceIndex = function (e) { return e.source; };                                     // 4860\n        LinkAccessor.prototype.getTargetIndex = function (e) { return e.target; };                                     // 4861\n        LinkAccessor.prototype.getLength = function (e) { return e.length; };                                          // 4862\n        LinkAccessor.prototype.setLength = function (e, l) { e.length = l; };                                          // 4863\n        return LinkAccessor;                                                                                           // 4864\n    })();                                                                                                              // 4865\n})(cola || (cola = {}));                                                                                               // 4866\n/**                                                                                                                    // 4867\n * When compiled, this file will build a CommonJS module for WebCola.                                                  // 4868\n *                                                                                                                     // 4869\n * Unfortunately, internal and external TypeScript modules do not get                                                  // 4870\n * along well. This method of converting internal modules to external                                                  // 4871\n * modules is a bit of a hack, but is minimally invasive (i.e., no modules                                             // 4872\n * need to be rewritten as external modules and modules can still span                                                 // 4873\n * multiple files)                                                                                                     // 4874\n *                                                                                                                     // 4875\n * When starting a new project from scratch where CommonJS compatibility                                               // 4876\n * is desired, consider instead preferring external modules to internal                                                // 4877\n * modules.                                                                                                            // 4878\n */                                                                                                                    // 4879\n///<reference path=\"./src/d3adaptor.ts\"/>                                                                              // 4880\n///<reference path=\"./src/descent.ts\"/>                                                                                // 4881\n///<reference path=\"./src/geom.ts\"/>                                                                                   // 4882\n///<reference path=\"./src/gridrouter.ts\"/>                                                                             // 4883\n///<reference path=\"./src/handledisconnected.ts\"/>                                                                     // 4884\n///<reference path=\"./src/layout.ts\"/>                                                                                 // 4885\n///<reference path=\"./src/layout3d.ts\"/>                                                                               // 4886\n///<reference path=\"./src/linklengths.ts\"/>                                                                            // 4887\n///<reference path=\"./src/powergraph.ts\"/>                                                                             // 4888\n///<reference path=\"./src/pqueue.ts\"/>                                                                                 // 4889\n///<reference path=\"./src/rectangle.ts\"/>                                                                              // 4890\n///<reference path=\"./src/shortestpaths.ts\"/>                                                                          // 4891\n///<reference path=\"./src/vpsc.ts\"/>                                                                                   // 4892\n///<reference path=\"./src/rbtree.ts\"/>                                                                                 // 4893\n// Export cola as a CommonJS module. Note that we're bypassing TypeScript's external                                   // 4894\n// module system here. Because internal modules were written with the browser in mind,                                 // 4895\n// TypeScript's model is that the current context is the global context (i.e., window.cola                             // 4896\n// === cola), so `export = cola` is transpiled as a no-op.                                                             // 4897\nmodule.exports = cola;                                                                                                 // 4898\n                                                                                                                       // 4899\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},\"meteor-node-stubs\":{\"package.json\":function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/package.json                                                                         //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nexports.name = \"meteor-node-stubs\";                                                                                    // 1\nexports.version = \"0.2.1\";                                                                                             // 2\nexports.main = \"index.js\";                                                                                             // 3\n                                                                                                                       // 4\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"./map.json\",function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/index.js                                                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar map = require(\"./map.json\");                                                                                       // 1\nvar meteorAliases = {};                                                                                                // 2\n                                                                                                                       // 3\nObject.keys(map).forEach(function (id) {                                                                               // 4\n  if (typeof map[id] === \"string\") {                                                                                   // 5\n    try {                                                                                                              // 6\n      exports[id] = meteorAliases[id + \".js\"] =                                                                        // 7\n        require.resolve(map[id]);                                                                                      // 8\n    } catch (e) {                                                                                                      // 9\n      // Resolution can fail at runtime if the stub was not included in the                                            // 10\n      // bundle because nothing depended on it.                                                                        // 11\n    }                                                                                                                  // 12\n  } else {                                                                                                             // 13\n    exports[id] = map[id];                                                                                             // 14\n    meteorAliases[id + \".js\"] = function(){};                                                                          // 15\n  }                                                                                                                    // 16\n});                                                                                                                    // 17\n                                                                                                                       // 18\nif (typeof meteorInstall === \"function\") {                                                                             // 19\n  meteorInstall({                                                                                                      // 20\n    // Install the aliases into a node_modules directory one level up from                                             // 21\n    // the root directory, so that they do not clutter the namespace                                                   // 22\n    // available to apps and packages.                                                                                 // 23\n    \"..\": {                                                                                                            // 24\n      node_modules: meteorAliases                                                                                      // 25\n    }                                                                                                                  // 26\n  });                                                                                                                  // 27\n}                                                                                                                      // 28\n                                                                                                                       // 29\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"map.json\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/map.json                                                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.exports = {                                                                                                     // 1\n  \"assert\": \"assert/\",                                                                                                 // 2\n  \"buffer\": \"buffer/\",                                                                                                 // 3\n  \"child_process\": null,                                                                                               // 4\n  \"cluster\": null,                                                                                                     // 5\n  \"console\": \"console-browserify\",                                                                                     // 6\n  \"constants\": \"constants-browserify\",                                                                                 // 7\n  \"crypto\": \"crypto-browserify\",                                                                                       // 8\n  \"dgram\": null,                                                                                                       // 9\n  \"dns\": null,                                                                                                         // 10\n  \"domain\": \"domain-browser\",                                                                                          // 11\n  \"events\": \"events/\",                                                                                                 // 12\n  \"fs\": null,                                                                                                          // 13\n  \"http\": \"http-browserify\",                                                                                           // 14\n  \"https\": \"https-browserify\",                                                                                         // 15\n  \"module\": null,                                                                                                      // 16\n  \"net\": null,                                                                                                         // 17\n  \"os\": \"os-browserify/browser.js\",                                                                                    // 18\n  \"path\": \"path-browserify\",                                                                                           // 19\n  \"process\": \"process/browser.js\",                                                                                     // 20\n  \"punycode\": \"punycode/\",                                                                                             // 21\n  \"querystring\": \"querystring-es3/\",                                                                                   // 22\n  \"readline\": null,                                                                                                    // 23\n  \"repl\": null,                                                                                                        // 24\n  \"stream\": \"stream-browserify\",                                                                                       // 25\n  \"_stream_duplex\": \"readable-stream/duplex.js\",                                                                       // 26\n  \"_stream_passthrough\": \"readable-stream/passthrough.js\",                                                             // 27\n  \"_stream_readable\": \"readable-stream/readable.js\",                                                                   // 28\n  \"_stream_transform\": \"readable-stream/transform.js\",                                                                 // 29\n  \"_stream_writable\": \"readable-stream/writable.js\",                                                                   // 30\n  \"string_decoder\": \"string_decoder/\",                                                                                 // 31\n  \"sys\": \"util/util.js\",                                                                                               // 32\n  \"timers\": \"timers-browserify\",                                                                                       // 33\n  \"tls\": null,                                                                                                         // 34\n  \"tty\": \"tty-browserify\",                                                                                             // 35\n  \"url\": \"url/\",                                                                                                       // 36\n  \"util\": \"util/util.js\",                                                                                              // 37\n  \"vm\": \"vm-browserify\",                                                                                               // 38\n  \"zlib\": \"browserify-zlib\"                                                                                            // 39\n};                                                                                                                     // 40\n                                                                                                                       // 41\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"deps\":{\"buffer.js\":[\"buffer/\",function(require){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/deps/buffer.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nrequire(\"buffer/\");                                                                                                    // 1\n                                                                                                                       // 2\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"process.js\":[\"process/browser.js\",function(require){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/deps/process.js                                                                      //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nrequire(\"process/browser.js\");                                                                                         // 1\n                                                                                                                       // 2\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"domain.js\":[\"domain-browser\",function(require){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/deps/domain.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nrequire(\"domain-browser\");                                                                                             // 1\n                                                                                                                       // 2\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"node_modules\":{\"buffer\":{\"package.json\":function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/node_modules/buffer/package.json                                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nexports.name = \"buffer\";                                                                                               // 1\nexports.version = \"4.5.0\";                                                                                             // 2\nexports.main = \"index.js\";                                                                                             // 3\n                                                                                                                       // 4\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"base64-js\",\"ieee754\",\"isarray\",function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/node_modules/buffer/index.js                                                         //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/*!                                                                                                                    // 1\n * The buffer module from node.js, for the browser.                                                                    // 2\n *                                                                                                                     // 3\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>                                               // 4\n * @license  MIT                                                                                                       // 5\n */                                                                                                                    // 6\n/* eslint-disable no-proto */                                                                                          // 7\n                                                                                                                       // 8\n'use strict'                                                                                                           // 9\n                                                                                                                       // 10\nvar base64 = require('base64-js')                                                                                      // 11\nvar ieee754 = require('ieee754')                                                                                       // 12\nvar isArray = require('isarray')                                                                                       // 13\n                                                                                                                       // 14\nexports.Buffer = Buffer                                                                                                // 15\nexports.SlowBuffer = SlowBuffer                                                                                        // 16\nexports.INSPECT_MAX_BYTES = 50                                                                                         // 17\nBuffer.poolSize = 8192 // not used by this implementation                                                              // 18\n                                                                                                                       // 19\nvar rootParent = {}                                                                                                    // 20\n                                                                                                                       // 21\n/**                                                                                                                    // 22\n * If `Buffer.TYPED_ARRAY_SUPPORT`:                                                                                    // 23\n *   === true    Use Uint8Array implementation (fastest)                                                               // 24\n *   === false   Use Object implementation (most compatible, even IE6)                                                 // 25\n *                                                                                                                     // 26\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,                                  // 27\n * Opera 11.6+, iOS 4.2+.                                                                                              // 28\n *                                                                                                                     // 29\n * Due to various browser bugs, sometimes the Object implementation will be used even                                  // 30\n * when the browser supports typed arrays.                                                                             // 31\n *                                                                                                                     // 32\n * Note:                                                                                                               // 33\n *                                                                                                                     // 34\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,                                 // 35\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.                                                       // 36\n *                                                                                                                     // 37\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.                                            // 38\n *                                                                                                                     // 39\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of                              // 40\n *     incorrect length in some situations.                                                                            // 41\n                                                                                                                       // 42\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they                              // 43\n * get the Object implementation, which is slower but behaves correctly.                                               // 44\n */                                                                                                                    // 45\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined                                                  // 46\n  ? global.TYPED_ARRAY_SUPPORT                                                                                         // 47\n  : typedArraySupport()                                                                                                // 48\n                                                                                                                       // 49\nfunction typedArraySupport () {                                                                                        // 50\n  try {                                                                                                                // 51\n    var arr = new Uint8Array(1)                                                                                        // 52\n    arr.foo = function () { return 42 }                                                                                // 53\n    return arr.foo() === 42 && // typed array instances can be augmented                                               // 54\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`                                           // 55\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`                                              // 56\n  } catch (e) {                                                                                                        // 57\n    return false                                                                                                       // 58\n  }                                                                                                                    // 59\n}                                                                                                                      // 60\n                                                                                                                       // 61\nfunction kMaxLength () {                                                                                               // 62\n  return Buffer.TYPED_ARRAY_SUPPORT                                                                                    // 63\n    ? 0x7fffffff                                                                                                       // 64\n    : 0x3fffffff                                                                                                       // 65\n}                                                                                                                      // 66\n                                                                                                                       // 67\n/**                                                                                                                    // 68\n * The Buffer constructor returns instances of `Uint8Array` that have their                                            // 69\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of                                     // 70\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods                                     // 71\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it                                       // 72\n * returns a single octet.                                                                                             // 73\n *                                                                                                                     // 74\n * The `Uint8Array` prototype remains unmodified.                                                                      // 75\n */                                                                                                                    // 76\nfunction Buffer (arg) {                                                                                                // 77\n  if (!(this instanceof Buffer)) {                                                                                     // 78\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.                                           // 79\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])                                                     // 80\n    return new Buffer(arg)                                                                                             // 81\n  }                                                                                                                    // 82\n                                                                                                                       // 83\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {                                                                                   // 84\n    this.length = 0                                                                                                    // 85\n    this.parent = undefined                                                                                            // 86\n  }                                                                                                                    // 87\n                                                                                                                       // 88\n  // Common case.                                                                                                      // 89\n  if (typeof arg === 'number') {                                                                                       // 90\n    return fromNumber(this, arg)                                                                                       // 91\n  }                                                                                                                    // 92\n                                                                                                                       // 93\n  // Slightly less common case.                                                                                        // 94\n  if (typeof arg === 'string') {                                                                                       // 95\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')                                         // 96\n  }                                                                                                                    // 97\n                                                                                                                       // 98\n  // Unusual.                                                                                                          // 99\n  return fromObject(this, arg)                                                                                         // 100\n}                                                                                                                      // 101\n                                                                                                                       // 102\n// TODO: Legacy, not needed anymore. Remove in next major version.                                                     // 103\nBuffer._augment = function (arr) {                                                                                     // 104\n  arr.__proto__ = Buffer.prototype                                                                                     // 105\n  return arr                                                                                                           // 106\n}                                                                                                                      // 107\n                                                                                                                       // 108\nfunction fromNumber (that, length) {                                                                                   // 109\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)                                                          // 110\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {                                                                                   // 111\n    for (var i = 0; i < length; i++) {                                                                                 // 112\n      that[i] = 0                                                                                                      // 113\n    }                                                                                                                  // 114\n  }                                                                                                                    // 115\n  return that                                                                                                          // 116\n}                                                                                                                      // 117\n                                                                                                                       // 118\nfunction fromString (that, string, encoding) {                                                                         // 119\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'                                               // 120\n                                                                                                                       // 121\n  // Assumption: byteLength() return value is always < kMaxLength.                                                     // 122\n  var length = byteLength(string, encoding) | 0                                                                        // 123\n  that = allocate(that, length)                                                                                        // 124\n                                                                                                                       // 125\n  that.write(string, encoding)                                                                                         // 126\n  return that                                                                                                          // 127\n}                                                                                                                      // 128\n                                                                                                                       // 129\nfunction fromObject (that, object) {                                                                                   // 130\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)                                                         // 131\n                                                                                                                       // 132\n  if (isArray(object)) return fromArray(that, object)                                                                  // 133\n                                                                                                                       // 134\n  if (object == null) {                                                                                                // 135\n    throw new TypeError('must start with number, buffer, array or string')                                             // 136\n  }                                                                                                                    // 137\n                                                                                                                       // 138\n  if (typeof ArrayBuffer !== 'undefined') {                                                                            // 139\n    if (object.buffer instanceof ArrayBuffer) {                                                                        // 140\n      return fromTypedArray(that, object)                                                                              // 141\n    }                                                                                                                  // 142\n    if (object instanceof ArrayBuffer) {                                                                               // 143\n      return fromArrayBuffer(that, object)                                                                             // 144\n    }                                                                                                                  // 145\n  }                                                                                                                    // 146\n                                                                                                                       // 147\n  if (object.length) return fromArrayLike(that, object)                                                                // 148\n                                                                                                                       // 149\n  return fromJsonObject(that, object)                                                                                  // 150\n}                                                                                                                      // 151\n                                                                                                                       // 152\nfunction fromBuffer (that, buffer) {                                                                                   // 153\n  var length = checked(buffer.length) | 0                                                                              // 154\n  that = allocate(that, length)                                                                                        // 155\n  buffer.copy(that, 0, 0, length)                                                                                      // 156\n  return that                                                                                                          // 157\n}                                                                                                                      // 158\n                                                                                                                       // 159\nfunction fromArray (that, array) {                                                                                     // 160\n  var length = checked(array.length) | 0                                                                               // 161\n  that = allocate(that, length)                                                                                        // 162\n  for (var i = 0; i < length; i += 1) {                                                                                // 163\n    that[i] = array[i] & 255                                                                                           // 164\n  }                                                                                                                    // 165\n  return that                                                                                                          // 166\n}                                                                                                                      // 167\n                                                                                                                       // 168\n// Duplicate of fromArray() to keep fromArray() monomorphic.                                                           // 169\nfunction fromTypedArray (that, array) {                                                                                // 170\n  var length = checked(array.length) | 0                                                                               // 171\n  that = allocate(that, length)                                                                                        // 172\n  // Truncating the elements is probably not what people expect from typed                                             // 173\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior                                           // 174\n  // of the old Buffer constructor.                                                                                    // 175\n  for (var i = 0; i < length; i += 1) {                                                                                // 176\n    that[i] = array[i] & 255                                                                                           // 177\n  }                                                                                                                    // 178\n  return that                                                                                                          // 179\n}                                                                                                                      // 180\n                                                                                                                       // 181\nfunction fromArrayBuffer (that, array) {                                                                               // 182\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer                                                // 183\n                                                                                                                       // 184\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                    // 185\n    // Return an augmented `Uint8Array` instance, for best performance                                                 // 186\n    that = new Uint8Array(array)                                                                                       // 187\n    that.__proto__ = Buffer.prototype                                                                                  // 188\n  } else {                                                                                                             // 189\n    // Fallback: Return an object instance of the Buffer class                                                         // 190\n    that = fromTypedArray(that, new Uint8Array(array))                                                                 // 191\n  }                                                                                                                    // 192\n  return that                                                                                                          // 193\n}                                                                                                                      // 194\n                                                                                                                       // 195\nfunction fromArrayLike (that, array) {                                                                                 // 196\n  var length = checked(array.length) | 0                                                                               // 197\n  that = allocate(that, length)                                                                                        // 198\n  for (var i = 0; i < length; i += 1) {                                                                                // 199\n    that[i] = array[i] & 255                                                                                           // 200\n  }                                                                                                                    // 201\n  return that                                                                                                          // 202\n}                                                                                                                      // 203\n                                                                                                                       // 204\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.                                             // 205\n// Returns a zero-length buffer for inputs that don't conform to the spec.                                             // 206\nfunction fromJsonObject (that, object) {                                                                               // 207\n  var array                                                                                                            // 208\n  var length = 0                                                                                                       // 209\n                                                                                                                       // 210\n  if (object.type === 'Buffer' && isArray(object.data)) {                                                              // 211\n    array = object.data                                                                                                // 212\n    length = checked(array.length) | 0                                                                                 // 213\n  }                                                                                                                    // 214\n  that = allocate(that, length)                                                                                        // 215\n                                                                                                                       // 216\n  for (var i = 0; i < length; i += 1) {                                                                                // 217\n    that[i] = array[i] & 255                                                                                           // 218\n  }                                                                                                                    // 219\n  return that                                                                                                          // 220\n}                                                                                                                      // 221\n                                                                                                                       // 222\nif (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                      // 223\n  Buffer.prototype.__proto__ = Uint8Array.prototype                                                                    // 224\n  Buffer.__proto__ = Uint8Array                                                                                        // 225\n  if (typeof Symbol !== 'undefined' && Symbol.species &&                                                               // 226\n      Buffer[Symbol.species] === Buffer) {                                                                             // 227\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97                                         // 228\n    Object.defineProperty(Buffer, Symbol.species, {                                                                    // 229\n      value: null,                                                                                                     // 230\n      configurable: true                                                                                               // 231\n    })                                                                                                                 // 232\n  }                                                                                                                    // 233\n} else {                                                                                                               // 234\n  // pre-set for values that may exist in the future                                                                   // 235\n  Buffer.prototype.length = undefined                                                                                  // 236\n  Buffer.prototype.parent = undefined                                                                                  // 237\n}                                                                                                                      // 238\n                                                                                                                       // 239\nfunction allocate (that, length) {                                                                                     // 240\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                    // 241\n    // Return an augmented `Uint8Array` instance, for best performance                                                 // 242\n    that = new Uint8Array(length)                                                                                      // 243\n    that.__proto__ = Buffer.prototype                                                                                  // 244\n  } else {                                                                                                             // 245\n    // Fallback: Return an object instance of the Buffer class                                                         // 246\n    that.length = length                                                                                               // 247\n  }                                                                                                                    // 248\n                                                                                                                       // 249\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1                                                       // 250\n  if (fromPool) that.parent = rootParent                                                                               // 251\n                                                                                                                       // 252\n  return that                                                                                                          // 253\n}                                                                                                                      // 254\n                                                                                                                       // 255\nfunction checked (length) {                                                                                            // 256\n  // Note: cannot use `length < kMaxLength` here because that fails when                                               // 257\n  // length is NaN (which is otherwise coerced to zero.)                                                               // 258\n  if (length >= kMaxLength()) {                                                                                        // 259\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +                                           // 260\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')                                            // 261\n  }                                                                                                                    // 262\n  return length | 0                                                                                                    // 263\n}                                                                                                                      // 264\n                                                                                                                       // 265\nfunction SlowBuffer (subject, encoding) {                                                                              // 266\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)                                          // 267\n                                                                                                                       // 268\n  var buf = new Buffer(subject, encoding)                                                                              // 269\n  delete buf.parent                                                                                                    // 270\n  return buf                                                                                                           // 271\n}                                                                                                                      // 272\n                                                                                                                       // 273\nBuffer.isBuffer = function isBuffer (b) {                                                                              // 274\n  return !!(b != null && b._isBuffer)                                                                                  // 275\n}                                                                                                                      // 276\n                                                                                                                       // 277\nBuffer.compare = function compare (a, b) {                                                                             // 278\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {                                                                    // 279\n    throw new TypeError('Arguments must be Buffers')                                                                   // 280\n  }                                                                                                                    // 281\n                                                                                                                       // 282\n  if (a === b) return 0                                                                                                // 283\n                                                                                                                       // 284\n  var x = a.length                                                                                                     // 285\n  var y = b.length                                                                                                     // 286\n                                                                                                                       // 287\n  var i = 0                                                                                                            // 288\n  var len = Math.min(x, y)                                                                                             // 289\n  while (i < len) {                                                                                                    // 290\n    if (a[i] !== b[i]) break                                                                                           // 291\n                                                                                                                       // 292\n    ++i                                                                                                                // 293\n  }                                                                                                                    // 294\n                                                                                                                       // 295\n  if (i !== len) {                                                                                                     // 296\n    x = a[i]                                                                                                           // 297\n    y = b[i]                                                                                                           // 298\n  }                                                                                                                    // 299\n                                                                                                                       // 300\n  if (x < y) return -1                                                                                                 // 301\n  if (y < x) return 1                                                                                                  // 302\n  return 0                                                                                                             // 303\n}                                                                                                                      // 304\n                                                                                                                       // 305\nBuffer.isEncoding = function isEncoding (encoding) {                                                                   // 306\n  switch (String(encoding).toLowerCase()) {                                                                            // 307\n    case 'hex':                                                                                                        // 308\n    case 'utf8':                                                                                                       // 309\n    case 'utf-8':                                                                                                      // 310\n    case 'ascii':                                                                                                      // 311\n    case 'binary':                                                                                                     // 312\n    case 'base64':                                                                                                     // 313\n    case 'raw':                                                                                                        // 314\n    case 'ucs2':                                                                                                       // 315\n    case 'ucs-2':                                                                                                      // 316\n    case 'utf16le':                                                                                                    // 317\n    case 'utf-16le':                                                                                                   // 318\n      return true                                                                                                      // 319\n    default:                                                                                                           // 320\n      return false                                                                                                     // 321\n  }                                                                                                                    // 322\n}                                                                                                                      // 323\n                                                                                                                       // 324\nBuffer.concat = function concat (list, length) {                                                                       // 325\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')                                // 326\n                                                                                                                       // 327\n  if (list.length === 0) {                                                                                             // 328\n    return new Buffer(0)                                                                                               // 329\n  }                                                                                                                    // 330\n                                                                                                                       // 331\n  var i                                                                                                                // 332\n  if (length === undefined) {                                                                                          // 333\n    length = 0                                                                                                         // 334\n    for (i = 0; i < list.length; i++) {                                                                                // 335\n      length += list[i].length                                                                                         // 336\n    }                                                                                                                  // 337\n  }                                                                                                                    // 338\n                                                                                                                       // 339\n  var buf = new Buffer(length)                                                                                         // 340\n  var pos = 0                                                                                                          // 341\n  for (i = 0; i < list.length; i++) {                                                                                  // 342\n    var item = list[i]                                                                                                 // 343\n    item.copy(buf, pos)                                                                                                // 344\n    pos += item.length                                                                                                 // 345\n  }                                                                                                                    // 346\n  return buf                                                                                                           // 347\n}                                                                                                                      // 348\n                                                                                                                       // 349\nfunction byteLength (string, encoding) {                                                                               // 350\n  if (typeof string !== 'string') string = '' + string                                                                 // 351\n                                                                                                                       // 352\n  var len = string.length                                                                                              // 353\n  if (len === 0) return 0                                                                                              // 354\n                                                                                                                       // 355\n  // Use a for loop to avoid recursion                                                                                 // 356\n  var loweredCase = false                                                                                              // 357\n  for (;;) {                                                                                                           // 358\n    switch (encoding) {                                                                                                // 359\n      case 'ascii':                                                                                                    // 360\n      case 'binary':                                                                                                   // 361\n      // Deprecated                                                                                                    // 362\n      case 'raw':                                                                                                      // 363\n      case 'raws':                                                                                                     // 364\n        return len                                                                                                     // 365\n      case 'utf8':                                                                                                     // 366\n      case 'utf-8':                                                                                                    // 367\n        return utf8ToBytes(string).length                                                                              // 368\n      case 'ucs2':                                                                                                     // 369\n      case 'ucs-2':                                                                                                    // 370\n      case 'utf16le':                                                                                                  // 371\n      case 'utf-16le':                                                                                                 // 372\n        return len * 2                                                                                                 // 373\n      case 'hex':                                                                                                      // 374\n        return len >>> 1                                                                                               // 375\n      case 'base64':                                                                                                   // 376\n        return base64ToBytes(string).length                                                                            // 377\n      default:                                                                                                         // 378\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8                                              // 379\n        encoding = ('' + encoding).toLowerCase()                                                                       // 380\n        loweredCase = true                                                                                             // 381\n    }                                                                                                                  // 382\n  }                                                                                                                    // 383\n}                                                                                                                      // 384\nBuffer.byteLength = byteLength                                                                                         // 385\n                                                                                                                       // 386\nfunction slowToString (encoding, start, end) {                                                                         // 387\n  var loweredCase = false                                                                                              // 388\n                                                                                                                       // 389\n  start = start | 0                                                                                                    // 390\n  end = end === undefined || end === Infinity ? this.length : end | 0                                                  // 391\n                                                                                                                       // 392\n  if (!encoding) encoding = 'utf8'                                                                                     // 393\n  if (start < 0) start = 0                                                                                             // 394\n  if (end > this.length) end = this.length                                                                             // 395\n  if (end <= start) return ''                                                                                          // 396\n                                                                                                                       // 397\n  while (true) {                                                                                                       // 398\n    switch (encoding) {                                                                                                // 399\n      case 'hex':                                                                                                      // 400\n        return hexSlice(this, start, end)                                                                              // 401\n                                                                                                                       // 402\n      case 'utf8':                                                                                                     // 403\n      case 'utf-8':                                                                                                    // 404\n        return utf8Slice(this, start, end)                                                                             // 405\n                                                                                                                       // 406\n      case 'ascii':                                                                                                    // 407\n        return asciiSlice(this, start, end)                                                                            // 408\n                                                                                                                       // 409\n      case 'binary':                                                                                                   // 410\n        return binarySlice(this, start, end)                                                                           // 411\n                                                                                                                       // 412\n      case 'base64':                                                                                                   // 413\n        return base64Slice(this, start, end)                                                                           // 414\n                                                                                                                       // 415\n      case 'ucs2':                                                                                                     // 416\n      case 'ucs-2':                                                                                                    // 417\n      case 'utf16le':                                                                                                  // 418\n      case 'utf-16le':                                                                                                 // 419\n        return utf16leSlice(this, start, end)                                                                          // 420\n                                                                                                                       // 421\n      default:                                                                                                         // 422\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)                                          // 423\n        encoding = (encoding + '').toLowerCase()                                                                       // 424\n        loweredCase = true                                                                                             // 425\n    }                                                                                                                  // 426\n  }                                                                                                                    // 427\n}                                                                                                                      // 428\n                                                                                                                       // 429\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect                                 // 430\n// Buffer instances.                                                                                                   // 431\nBuffer.prototype._isBuffer = true                                                                                      // 432\n                                                                                                                       // 433\nBuffer.prototype.toString = function toString () {                                                                     // 434\n  var length = this.length | 0                                                                                         // 435\n  if (length === 0) return ''                                                                                          // 436\n  if (arguments.length === 0) return utf8Slice(this, 0, length)                                                        // 437\n  return slowToString.apply(this, arguments)                                                                           // 438\n}                                                                                                                      // 439\n                                                                                                                       // 440\nBuffer.prototype.equals = function equals (b) {                                                                        // 441\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')                                            // 442\n  if (this === b) return true                                                                                          // 443\n  return Buffer.compare(this, b) === 0                                                                                 // 444\n}                                                                                                                      // 445\n                                                                                                                       // 446\nBuffer.prototype.inspect = function inspect () {                                                                       // 447\n  var str = ''                                                                                                         // 448\n  var max = exports.INSPECT_MAX_BYTES                                                                                  // 449\n  if (this.length > 0) {                                                                                               // 450\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')                                                        // 451\n    if (this.length > max) str += ' ... '                                                                              // 452\n  }                                                                                                                    // 453\n  return '<Buffer ' + str + '>'                                                                                        // 454\n}                                                                                                                      // 455\n                                                                                                                       // 456\nBuffer.prototype.compare = function compare (b) {                                                                      // 457\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')                                            // 458\n  if (this === b) return 0                                                                                             // 459\n  return Buffer.compare(this, b)                                                                                       // 460\n}                                                                                                                      // 461\n                                                                                                                       // 462\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {                                                        // 463\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff                                                                 // 464\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000                                                          // 465\n  byteOffset >>= 0                                                                                                     // 466\n                                                                                                                       // 467\n  if (this.length === 0) return -1                                                                                     // 468\n  if (byteOffset >= this.length) return -1                                                                             // 469\n                                                                                                                       // 470\n  // Negative offsets start from the end of the buffer                                                                 // 471\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)                                               // 472\n                                                                                                                       // 473\n  if (typeof val === 'string') {                                                                                       // 474\n    if (val.length === 0) return -1 // special case: looking for empty string always fails                             // 475\n    return String.prototype.indexOf.call(this, val, byteOffset)                                                        // 476\n  }                                                                                                                    // 477\n  if (Buffer.isBuffer(val)) {                                                                                          // 478\n    return arrayIndexOf(this, val, byteOffset)                                                                         // 479\n  }                                                                                                                    // 480\n  if (typeof val === 'number') {                                                                                       // 481\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {                                   // 482\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)                                                  // 483\n    }                                                                                                                  // 484\n    return arrayIndexOf(this, [ val ], byteOffset)                                                                     // 485\n  }                                                                                                                    // 486\n                                                                                                                       // 487\n  function arrayIndexOf (arr, val, byteOffset) {                                                                       // 488\n    var foundIndex = -1                                                                                                // 489\n    for (var i = 0; byteOffset + i < arr.length; i++) {                                                                // 490\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {                                       // 491\n        if (foundIndex === -1) foundIndex = i                                                                          // 492\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex                                          // 493\n      } else {                                                                                                         // 494\n        foundIndex = -1                                                                                                // 495\n      }                                                                                                                // 496\n    }                                                                                                                  // 497\n    return -1                                                                                                          // 498\n  }                                                                                                                    // 499\n                                                                                                                       // 500\n  throw new TypeError('val must be string, number or Buffer')                                                          // 501\n}                                                                                                                      // 502\n                                                                                                                       // 503\nfunction hexWrite (buf, string, offset, length) {                                                                      // 504\n  offset = Number(offset) || 0                                                                                         // 505\n  var remaining = buf.length - offset                                                                                  // 506\n  if (!length) {                                                                                                       // 507\n    length = remaining                                                                                                 // 508\n  } else {                                                                                                             // 509\n    length = Number(length)                                                                                            // 510\n    if (length > remaining) {                                                                                          // 511\n      length = remaining                                                                                               // 512\n    }                                                                                                                  // 513\n  }                                                                                                                    // 514\n                                                                                                                       // 515\n  // must be an even number of digits                                                                                  // 516\n  var strLen = string.length                                                                                           // 517\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')                                                          // 518\n                                                                                                                       // 519\n  if (length > strLen / 2) {                                                                                           // 520\n    length = strLen / 2                                                                                                // 521\n  }                                                                                                                    // 522\n  for (var i = 0; i < length; i++) {                                                                                   // 523\n    var parsed = parseInt(string.substr(i * 2, 2), 16)                                                                 // 524\n    if (isNaN(parsed)) throw new Error('Invalid hex string')                                                           // 525\n    buf[offset + i] = parsed                                                                                           // 526\n  }                                                                                                                    // 527\n  return i                                                                                                             // 528\n}                                                                                                                      // 529\n                                                                                                                       // 530\nfunction utf8Write (buf, string, offset, length) {                                                                     // 531\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)                                     // 532\n}                                                                                                                      // 533\n                                                                                                                       // 534\nfunction asciiWrite (buf, string, offset, length) {                                                                    // 535\n  return blitBuffer(asciiToBytes(string), buf, offset, length)                                                         // 536\n}                                                                                                                      // 537\n                                                                                                                       // 538\nfunction binaryWrite (buf, string, offset, length) {                                                                   // 539\n  return asciiWrite(buf, string, offset, length)                                                                       // 540\n}                                                                                                                      // 541\n                                                                                                                       // 542\nfunction base64Write (buf, string, offset, length) {                                                                   // 543\n  return blitBuffer(base64ToBytes(string), buf, offset, length)                                                        // 544\n}                                                                                                                      // 545\n                                                                                                                       // 546\nfunction ucs2Write (buf, string, offset, length) {                                                                     // 547\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)                                  // 548\n}                                                                                                                      // 549\n                                                                                                                       // 550\nBuffer.prototype.write = function write (string, offset, length, encoding) {                                           // 551\n  // Buffer#write(string)                                                                                              // 552\n  if (offset === undefined) {                                                                                          // 553\n    encoding = 'utf8'                                                                                                  // 554\n    length = this.length                                                                                               // 555\n    offset = 0                                                                                                         // 556\n  // Buffer#write(string, encoding)                                                                                    // 557\n  } else if (length === undefined && typeof offset === 'string') {                                                     // 558\n    encoding = offset                                                                                                  // 559\n    length = this.length                                                                                               // 560\n    offset = 0                                                                                                         // 561\n  // Buffer#write(string, offset[, length][, encoding])                                                                // 562\n  } else if (isFinite(offset)) {                                                                                       // 563\n    offset = offset | 0                                                                                                // 564\n    if (isFinite(length)) {                                                                                            // 565\n      length = length | 0                                                                                              // 566\n      if (encoding === undefined) encoding = 'utf8'                                                                    // 567\n    } else {                                                                                                           // 568\n      encoding = length                                                                                                // 569\n      length = undefined                                                                                               // 570\n    }                                                                                                                  // 571\n  // legacy write(string, encoding, offset, length) - remove in v0.13                                                  // 572\n  } else {                                                                                                             // 573\n    var swap = encoding                                                                                                // 574\n    encoding = offset                                                                                                  // 575\n    offset = length | 0                                                                                                // 576\n    length = swap                                                                                                      // 577\n  }                                                                                                                    // 578\n                                                                                                                       // 579\n  var remaining = this.length - offset                                                                                 // 580\n  if (length === undefined || length > remaining) length = remaining                                                   // 581\n                                                                                                                       // 582\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {                                     // 583\n    throw new RangeError('attempt to write outside buffer bounds')                                                     // 584\n  }                                                                                                                    // 585\n                                                                                                                       // 586\n  if (!encoding) encoding = 'utf8'                                                                                     // 587\n                                                                                                                       // 588\n  var loweredCase = false                                                                                              // 589\n  for (;;) {                                                                                                           // 590\n    switch (encoding) {                                                                                                // 591\n      case 'hex':                                                                                                      // 592\n        return hexWrite(this, string, offset, length)                                                                  // 593\n                                                                                                                       // 594\n      case 'utf8':                                                                                                     // 595\n      case 'utf-8':                                                                                                    // 596\n        return utf8Write(this, string, offset, length)                                                                 // 597\n                                                                                                                       // 598\n      case 'ascii':                                                                                                    // 599\n        return asciiWrite(this, string, offset, length)                                                                // 600\n                                                                                                                       // 601\n      case 'binary':                                                                                                   // 602\n        return binaryWrite(this, string, offset, length)                                                               // 603\n                                                                                                                       // 604\n      case 'base64':                                                                                                   // 605\n        // Warning: maxLength not taken into account in base64Write                                                    // 606\n        return base64Write(this, string, offset, length)                                                               // 607\n                                                                                                                       // 608\n      case 'ucs2':                                                                                                     // 609\n      case 'ucs-2':                                                                                                    // 610\n      case 'utf16le':                                                                                                  // 611\n      case 'utf-16le':                                                                                                 // 612\n        return ucs2Write(this, string, offset, length)                                                                 // 613\n                                                                                                                       // 614\n      default:                                                                                                         // 615\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)                                          // 616\n        encoding = ('' + encoding).toLowerCase()                                                                       // 617\n        loweredCase = true                                                                                             // 618\n    }                                                                                                                  // 619\n  }                                                                                                                    // 620\n}                                                                                                                      // 621\n                                                                                                                       // 622\nBuffer.prototype.toJSON = function toJSON () {                                                                         // 623\n  return {                                                                                                             // 624\n    type: 'Buffer',                                                                                                    // 625\n    data: Array.prototype.slice.call(this._arr || this, 0)                                                             // 626\n  }                                                                                                                    // 627\n}                                                                                                                      // 628\n                                                                                                                       // 629\nfunction base64Slice (buf, start, end) {                                                                               // 630\n  if (start === 0 && end === buf.length) {                                                                             // 631\n    return base64.fromByteArray(buf)                                                                                   // 632\n  } else {                                                                                                             // 633\n    return base64.fromByteArray(buf.slice(start, end))                                                                 // 634\n  }                                                                                                                    // 635\n}                                                                                                                      // 636\n                                                                                                                       // 637\nfunction utf8Slice (buf, start, end) {                                                                                 // 638\n  end = Math.min(buf.length, end)                                                                                      // 639\n  var res = []                                                                                                         // 640\n                                                                                                                       // 641\n  var i = start                                                                                                        // 642\n  while (i < end) {                                                                                                    // 643\n    var firstByte = buf[i]                                                                                             // 644\n    var codePoint = null                                                                                               // 645\n    var bytesPerSequence = (firstByte > 0xEF) ? 4                                                                      // 646\n      : (firstByte > 0xDF) ? 3                                                                                         // 647\n      : (firstByte > 0xBF) ? 2                                                                                         // 648\n      : 1                                                                                                              // 649\n                                                                                                                       // 650\n    if (i + bytesPerSequence <= end) {                                                                                 // 651\n      var secondByte, thirdByte, fourthByte, tempCodePoint                                                             // 652\n                                                                                                                       // 653\n      switch (bytesPerSequence) {                                                                                      // 654\n        case 1:                                                                                                        // 655\n          if (firstByte < 0x80) {                                                                                      // 656\n            codePoint = firstByte                                                                                      // 657\n          }                                                                                                            // 658\n          break                                                                                                        // 659\n        case 2:                                                                                                        // 660\n          secondByte = buf[i + 1]                                                                                      // 661\n          if ((secondByte & 0xC0) === 0x80) {                                                                          // 662\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)                                            // 663\n            if (tempCodePoint > 0x7F) {                                                                                // 664\n              codePoint = tempCodePoint                                                                                // 665\n            }                                                                                                          // 666\n          }                                                                                                            // 667\n          break                                                                                                        // 668\n        case 3:                                                                                                        // 669\n          secondByte = buf[i + 1]                                                                                      // 670\n          thirdByte = buf[i + 2]                                                                                       // 671\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {                                           // 672\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)                 // 673\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {                         // 674\n              codePoint = tempCodePoint                                                                                // 675\n            }                                                                                                          // 676\n          }                                                                                                            // 677\n          break                                                                                                        // 678\n        case 4:                                                                                                        // 679\n          secondByte = buf[i + 1]                                                                                      // 680\n          thirdByte = buf[i + 2]                                                                                       // 681\n          fourthByte = buf[i + 3]                                                                                      // 682\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {           // 683\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {                                                  // 685\n              codePoint = tempCodePoint                                                                                // 686\n            }                                                                                                          // 687\n          }                                                                                                            // 688\n      }                                                                                                                // 689\n    }                                                                                                                  // 690\n                                                                                                                       // 691\n    if (codePoint === null) {                                                                                          // 692\n      // we did not generate a valid codePoint so insert a                                                             // 693\n      // replacement char (U+FFFD) and advance only 1 byte                                                             // 694\n      codePoint = 0xFFFD                                                                                               // 695\n      bytesPerSequence = 1                                                                                             // 696\n    } else if (codePoint > 0xFFFF) {                                                                                   // 697\n      // encode to utf16 (surrogate pair dance)                                                                        // 698\n      codePoint -= 0x10000                                                                                             // 699\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)                                                                      // 700\n      codePoint = 0xDC00 | codePoint & 0x3FF                                                                           // 701\n    }                                                                                                                  // 702\n                                                                                                                       // 703\n    res.push(codePoint)                                                                                                // 704\n    i += bytesPerSequence                                                                                              // 705\n  }                                                                                                                    // 706\n                                                                                                                       // 707\n  return decodeCodePointsArray(res)                                                                                    // 708\n}                                                                                                                      // 709\n                                                                                                                       // 710\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with                                               // 711\n// the lowest limit is Chrome, with 0x10000 args.                                                                      // 712\n// We go 1 magnitude less, for safety                                                                                  // 713\nvar MAX_ARGUMENTS_LENGTH = 0x1000                                                                                      // 714\n                                                                                                                       // 715\nfunction decodeCodePointsArray (codePoints) {                                                                          // 716\n  var len = codePoints.length                                                                                          // 717\n  if (len <= MAX_ARGUMENTS_LENGTH) {                                                                                   // 718\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()                                        // 719\n  }                                                                                                                    // 720\n                                                                                                                       // 721\n  // Decode in chunks to avoid \"call stack size exceeded\".                                                             // 722\n  var res = ''                                                                                                         // 723\n  var i = 0                                                                                                            // 724\n  while (i < len) {                                                                                                    // 725\n    res += String.fromCharCode.apply(                                                                                  // 726\n      String,                                                                                                          // 727\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)                                                                   // 728\n    )                                                                                                                  // 729\n  }                                                                                                                    // 730\n  return res                                                                                                           // 731\n}                                                                                                                      // 732\n                                                                                                                       // 733\nfunction asciiSlice (buf, start, end) {                                                                                // 734\n  var ret = ''                                                                                                         // 735\n  end = Math.min(buf.length, end)                                                                                      // 736\n                                                                                                                       // 737\n  for (var i = start; i < end; i++) {                                                                                  // 738\n    ret += String.fromCharCode(buf[i] & 0x7F)                                                                          // 739\n  }                                                                                                                    // 740\n  return ret                                                                                                           // 741\n}                                                                                                                      // 742\n                                                                                                                       // 743\nfunction binarySlice (buf, start, end) {                                                                               // 744\n  var ret = ''                                                                                                         // 745\n  end = Math.min(buf.length, end)                                                                                      // 746\n                                                                                                                       // 747\n  for (var i = start; i < end; i++) {                                                                                  // 748\n    ret += String.fromCharCode(buf[i])                                                                                 // 749\n  }                                                                                                                    // 750\n  return ret                                                                                                           // 751\n}                                                                                                                      // 752\n                                                                                                                       // 753\nfunction hexSlice (buf, start, end) {                                                                                  // 754\n  var len = buf.length                                                                                                 // 755\n                                                                                                                       // 756\n  if (!start || start < 0) start = 0                                                                                   // 757\n  if (!end || end < 0 || end > len) end = len                                                                          // 758\n                                                                                                                       // 759\n  var out = ''                                                                                                         // 760\n  for (var i = start; i < end; i++) {                                                                                  // 761\n    out += toHex(buf[i])                                                                                               // 762\n  }                                                                                                                    // 763\n  return out                                                                                                           // 764\n}                                                                                                                      // 765\n                                                                                                                       // 766\nfunction utf16leSlice (buf, start, end) {                                                                              // 767\n  var bytes = buf.slice(start, end)                                                                                    // 768\n  var res = ''                                                                                                         // 769\n  for (var i = 0; i < bytes.length; i += 2) {                                                                          // 770\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)                                                          // 771\n  }                                                                                                                    // 772\n  return res                                                                                                           // 773\n}                                                                                                                      // 774\n                                                                                                                       // 775\nBuffer.prototype.slice = function slice (start, end) {                                                                 // 776\n  var len = this.length                                                                                                // 777\n  start = ~~start                                                                                                      // 778\n  end = end === undefined ? len : ~~end                                                                                // 779\n                                                                                                                       // 780\n  if (start < 0) {                                                                                                     // 781\n    start += len                                                                                                       // 782\n    if (start < 0) start = 0                                                                                           // 783\n  } else if (start > len) {                                                                                            // 784\n    start = len                                                                                                        // 785\n  }                                                                                                                    // 786\n                                                                                                                       // 787\n  if (end < 0) {                                                                                                       // 788\n    end += len                                                                                                         // 789\n    if (end < 0) end = 0                                                                                               // 790\n  } else if (end > len) {                                                                                              // 791\n    end = len                                                                                                          // 792\n  }                                                                                                                    // 793\n                                                                                                                       // 794\n  if (end < start) end = start                                                                                         // 795\n                                                                                                                       // 796\n  var newBuf                                                                                                           // 797\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                    // 798\n    newBuf = this.subarray(start, end)                                                                                 // 799\n    newBuf.__proto__ = Buffer.prototype                                                                                // 800\n  } else {                                                                                                             // 801\n    var sliceLen = end - start                                                                                         // 802\n    newBuf = new Buffer(sliceLen, undefined)                                                                           // 803\n    for (var i = 0; i < sliceLen; i++) {                                                                               // 804\n      newBuf[i] = this[i + start]                                                                                      // 805\n    }                                                                                                                  // 806\n  }                                                                                                                    // 807\n                                                                                                                       // 808\n  if (newBuf.length) newBuf.parent = this.parent || this                                                               // 809\n                                                                                                                       // 810\n  return newBuf                                                                                                        // 811\n}                                                                                                                      // 812\n                                                                                                                       // 813\n/*                                                                                                                     // 814\n * Need to make sure that buffer isn't trying to write out of bounds.                                                  // 815\n */                                                                                                                    // 816\nfunction checkOffset (offset, ext, length) {                                                                           // 817\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')                                     // 818\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')                             // 819\n}                                                                                                                      // 820\n                                                                                                                       // 821\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {                                     // 822\n  offset = offset | 0                                                                                                  // 823\n  byteLength = byteLength | 0                                                                                          // 824\n  if (!noAssert) checkOffset(offset, byteLength, this.length)                                                          // 825\n                                                                                                                       // 826\n  var val = this[offset]                                                                                               // 827\n  var mul = 1                                                                                                          // 828\n  var i = 0                                                                                                            // 829\n  while (++i < byteLength && (mul *= 0x100)) {                                                                         // 830\n    val += this[offset + i] * mul                                                                                      // 831\n  }                                                                                                                    // 832\n                                                                                                                       // 833\n  return val                                                                                                           // 834\n}                                                                                                                      // 835\n                                                                                                                       // 836\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {                                     // 837\n  offset = offset | 0                                                                                                  // 838\n  byteLength = byteLength | 0                                                                                          // 839\n  if (!noAssert) {                                                                                                     // 840\n    checkOffset(offset, byteLength, this.length)                                                                       // 841\n  }                                                                                                                    // 842\n                                                                                                                       // 843\n  var val = this[offset + --byteLength]                                                                                // 844\n  var mul = 1                                                                                                          // 845\n  while (byteLength > 0 && (mul *= 0x100)) {                                                                           // 846\n    val += this[offset + --byteLength] * mul                                                                           // 847\n  }                                                                                                                    // 848\n                                                                                                                       // 849\n  return val                                                                                                           // 850\n}                                                                                                                      // 851\n                                                                                                                       // 852\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {                                                   // 853\n  if (!noAssert) checkOffset(offset, 1, this.length)                                                                   // 854\n  return this[offset]                                                                                                  // 855\n}                                                                                                                      // 856\n                                                                                                                       // 857\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {                                             // 858\n  if (!noAssert) checkOffset(offset, 2, this.length)                                                                   // 859\n  return this[offset] | (this[offset + 1] << 8)                                                                        // 860\n}                                                                                                                      // 861\n                                                                                                                       // 862\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {                                             // 863\n  if (!noAssert) checkOffset(offset, 2, this.length)                                                                   // 864\n  return (this[offset] << 8) | this[offset + 1]                                                                        // 865\n}                                                                                                                      // 866\n                                                                                                                       // 867\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {                                             // 868\n  if (!noAssert) checkOffset(offset, 4, this.length)                                                                   // 869\n                                                                                                                       // 870\n  return ((this[offset]) |                                                                                             // 871\n      (this[offset + 1] << 8) |                                                                                        // 872\n      (this[offset + 2] << 16)) +                                                                                      // 873\n      (this[offset + 3] * 0x1000000)                                                                                   // 874\n}                                                                                                                      // 875\n                                                                                                                       // 876\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {                                             // 877\n  if (!noAssert) checkOffset(offset, 4, this.length)                                                                   // 878\n                                                                                                                       // 879\n  return (this[offset] * 0x1000000) +                                                                                  // 880\n    ((this[offset + 1] << 16) |                                                                                        // 881\n    (this[offset + 2] << 8) |                                                                                          // 882\n    this[offset + 3])                                                                                                  // 883\n}                                                                                                                      // 884\n                                                                                                                       // 885\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {                                       // 886\n  offset = offset | 0                                                                                                  // 887\n  byteLength = byteLength | 0                                                                                          // 888\n  if (!noAssert) checkOffset(offset, byteLength, this.length)                                                          // 889\n                                                                                                                       // 890\n  var val = this[offset]                                                                                               // 891\n  var mul = 1                                                                                                          // 892\n  var i = 0                                                                                                            // 893\n  while (++i < byteLength && (mul *= 0x100)) {                                                                         // 894\n    val += this[offset + i] * mul                                                                                      // 895\n  }                                                                                                                    // 896\n  mul *= 0x80                                                                                                          // 897\n                                                                                                                       // 898\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)                                                                   // 899\n                                                                                                                       // 900\n  return val                                                                                                           // 901\n}                                                                                                                      // 902\n                                                                                                                       // 903\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {                                       // 904\n  offset = offset | 0                                                                                                  // 905\n  byteLength = byteLength | 0                                                                                          // 906\n  if (!noAssert) checkOffset(offset, byteLength, this.length)                                                          // 907\n                                                                                                                       // 908\n  var i = byteLength                                                                                                   // 909\n  var mul = 1                                                                                                          // 910\n  var val = this[offset + --i]                                                                                         // 911\n  while (i > 0 && (mul *= 0x100)) {                                                                                    // 912\n    val += this[offset + --i] * mul                                                                                    // 913\n  }                                                                                                                    // 914\n  mul *= 0x80                                                                                                          // 915\n                                                                                                                       // 916\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)                                                                   // 917\n                                                                                                                       // 918\n  return val                                                                                                           // 919\n}                                                                                                                      // 920\n                                                                                                                       // 921\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {                                                     // 922\n  if (!noAssert) checkOffset(offset, 1, this.length)                                                                   // 923\n  if (!(this[offset] & 0x80)) return (this[offset])                                                                    // 924\n  return ((0xff - this[offset] + 1) * -1)                                                                              // 925\n}                                                                                                                      // 926\n                                                                                                                       // 927\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {                                               // 928\n  if (!noAssert) checkOffset(offset, 2, this.length)                                                                   // 929\n  var val = this[offset] | (this[offset + 1] << 8)                                                                     // 930\n  return (val & 0x8000) ? val | 0xFFFF0000 : val                                                                       // 931\n}                                                                                                                      // 932\n                                                                                                                       // 933\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {                                               // 934\n  if (!noAssert) checkOffset(offset, 2, this.length)                                                                   // 935\n  var val = this[offset + 1] | (this[offset] << 8)                                                                     // 936\n  return (val & 0x8000) ? val | 0xFFFF0000 : val                                                                       // 937\n}                                                                                                                      // 938\n                                                                                                                       // 939\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {                                               // 940\n  if (!noAssert) checkOffset(offset, 4, this.length)                                                                   // 941\n                                                                                                                       // 942\n  return (this[offset]) |                                                                                              // 943\n    (this[offset + 1] << 8) |                                                                                          // 944\n    (this[offset + 2] << 16) |                                                                                         // 945\n    (this[offset + 3] << 24)                                                                                           // 946\n}                                                                                                                      // 947\n                                                                                                                       // 948\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {                                               // 949\n  if (!noAssert) checkOffset(offset, 4, this.length)                                                                   // 950\n                                                                                                                       // 951\n  return (this[offset] << 24) |                                                                                        // 952\n    (this[offset + 1] << 16) |                                                                                         // 953\n    (this[offset + 2] << 8) |                                                                                          // 954\n    (this[offset + 3])                                                                                                 // 955\n}                                                                                                                      // 956\n                                                                                                                       // 957\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {                                               // 958\n  if (!noAssert) checkOffset(offset, 4, this.length)                                                                   // 959\n  return ieee754.read(this, offset, true, 23, 4)                                                                       // 960\n}                                                                                                                      // 961\n                                                                                                                       // 962\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {                                               // 963\n  if (!noAssert) checkOffset(offset, 4, this.length)                                                                   // 964\n  return ieee754.read(this, offset, false, 23, 4)                                                                      // 965\n}                                                                                                                      // 966\n                                                                                                                       // 967\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {                                             // 968\n  if (!noAssert) checkOffset(offset, 8, this.length)                                                                   // 969\n  return ieee754.read(this, offset, true, 52, 8)                                                                       // 970\n}                                                                                                                      // 971\n                                                                                                                       // 972\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {                                             // 973\n  if (!noAssert) checkOffset(offset, 8, this.length)                                                                   // 974\n  return ieee754.read(this, offset, false, 52, 8)                                                                      // 975\n}                                                                                                                      // 976\n                                                                                                                       // 977\nfunction checkInt (buf, value, offset, ext, max, min) {                                                                // 978\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')                                   // 979\n  if (value > max || value < min) throw new RangeError('value is out of bounds')                                       // 980\n  if (offset + ext > buf.length) throw new RangeError('index out of range')                                            // 981\n}                                                                                                                      // 982\n                                                                                                                       // 983\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {                            // 984\n  value = +value                                                                                                       // 985\n  offset = offset | 0                                                                                                  // 986\n  byteLength = byteLength | 0                                                                                          // 987\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)                             // 988\n                                                                                                                       // 989\n  var mul = 1                                                                                                          // 990\n  var i = 0                                                                                                            // 991\n  this[offset] = value & 0xFF                                                                                          // 992\n  while (++i < byteLength && (mul *= 0x100)) {                                                                         // 993\n    this[offset + i] = (value / mul) & 0xFF                                                                            // 994\n  }                                                                                                                    // 995\n                                                                                                                       // 996\n  return offset + byteLength                                                                                           // 997\n}                                                                                                                      // 998\n                                                                                                                       // 999\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {                            // 1000\n  value = +value                                                                                                       // 1001\n  offset = offset | 0                                                                                                  // 1002\n  byteLength = byteLength | 0                                                                                          // 1003\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)                             // 1004\n                                                                                                                       // 1005\n  var i = byteLength - 1                                                                                               // 1006\n  var mul = 1                                                                                                          // 1007\n  this[offset + i] = value & 0xFF                                                                                      // 1008\n  while (--i >= 0 && (mul *= 0x100)) {                                                                                 // 1009\n    this[offset + i] = (value / mul) & 0xFF                                                                            // 1010\n  }                                                                                                                    // 1011\n                                                                                                                       // 1012\n  return offset + byteLength                                                                                           // 1013\n}                                                                                                                      // 1014\n                                                                                                                       // 1015\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {                                          // 1016\n  value = +value                                                                                                       // 1017\n  offset = offset | 0                                                                                                  // 1018\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)                                                             // 1019\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)                                                           // 1020\n  this[offset] = (value & 0xff)                                                                                        // 1021\n  return offset + 1                                                                                                    // 1022\n}                                                                                                                      // 1023\n                                                                                                                       // 1024\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {                                                        // 1025\n  if (value < 0) value = 0xffff + value + 1                                                                            // 1026\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {                                                  // 1027\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>                                         // 1028\n      (littleEndian ? i : 1 - i) * 8                                                                                   // 1029\n  }                                                                                                                    // 1030\n}                                                                                                                      // 1031\n                                                                                                                       // 1032\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {                                    // 1033\n  value = +value                                                                                                       // 1034\n  offset = offset | 0                                                                                                  // 1035\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)                                                           // 1036\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                    // 1037\n    this[offset] = (value & 0xff)                                                                                      // 1038\n    this[offset + 1] = (value >>> 8)                                                                                   // 1039\n  } else {                                                                                                             // 1040\n    objectWriteUInt16(this, value, offset, true)                                                                       // 1041\n  }                                                                                                                    // 1042\n  return offset + 2                                                                                                    // 1043\n}                                                                                                                      // 1044\n                                                                                                                       // 1045\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {                                    // 1046\n  value = +value                                                                                                       // 1047\n  offset = offset | 0                                                                                                  // 1048\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)                                                           // 1049\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                    // 1050\n    this[offset] = (value >>> 8)                                                                                       // 1051\n    this[offset + 1] = (value & 0xff)                                                                                  // 1052\n  } else {                                                                                                             // 1053\n    objectWriteUInt16(this, value, offset, false)                                                                      // 1054\n  }                                                                                                                    // 1055\n  return offset + 2                                                                                                    // 1056\n}                                                                                                                      // 1057\n                                                                                                                       // 1058\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {                                                        // 1059\n  if (value < 0) value = 0xffffffff + value + 1                                                                        // 1060\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {                                                  // 1061\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff                                                // 1062\n  }                                                                                                                    // 1063\n}                                                                                                                      // 1064\n                                                                                                                       // 1065\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {                                    // 1066\n  value = +value                                                                                                       // 1067\n  offset = offset | 0                                                                                                  // 1068\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)                                                       // 1069\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                    // 1070\n    this[offset + 3] = (value >>> 24)                                                                                  // 1071\n    this[offset + 2] = (value >>> 16)                                                                                  // 1072\n    this[offset + 1] = (value >>> 8)                                                                                   // 1073\n    this[offset] = (value & 0xff)                                                                                      // 1074\n  } else {                                                                                                             // 1075\n    objectWriteUInt32(this, value, offset, true)                                                                       // 1076\n  }                                                                                                                    // 1077\n  return offset + 4                                                                                                    // 1078\n}                                                                                                                      // 1079\n                                                                                                                       // 1080\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {                                    // 1081\n  value = +value                                                                                                       // 1082\n  offset = offset | 0                                                                                                  // 1083\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)                                                       // 1084\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                    // 1085\n    this[offset] = (value >>> 24)                                                                                      // 1086\n    this[offset + 1] = (value >>> 16)                                                                                  // 1087\n    this[offset + 2] = (value >>> 8)                                                                                   // 1088\n    this[offset + 3] = (value & 0xff)                                                                                  // 1089\n  } else {                                                                                                             // 1090\n    objectWriteUInt32(this, value, offset, false)                                                                      // 1091\n  }                                                                                                                    // 1092\n  return offset + 4                                                                                                    // 1093\n}                                                                                                                      // 1094\n                                                                                                                       // 1095\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {                              // 1096\n  value = +value                                                                                                       // 1097\n  offset = offset | 0                                                                                                  // 1098\n  if (!noAssert) {                                                                                                     // 1099\n    var limit = Math.pow(2, 8 * byteLength - 1)                                                                        // 1100\n                                                                                                                       // 1101\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)                                                       // 1102\n  }                                                                                                                    // 1103\n                                                                                                                       // 1104\n  var i = 0                                                                                                            // 1105\n  var mul = 1                                                                                                          // 1106\n  var sub = value < 0 ? 1 : 0                                                                                          // 1107\n  this[offset] = value & 0xFF                                                                                          // 1108\n  while (++i < byteLength && (mul *= 0x100)) {                                                                         // 1109\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF                                                               // 1110\n  }                                                                                                                    // 1111\n                                                                                                                       // 1112\n  return offset + byteLength                                                                                           // 1113\n}                                                                                                                      // 1114\n                                                                                                                       // 1115\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {                              // 1116\n  value = +value                                                                                                       // 1117\n  offset = offset | 0                                                                                                  // 1118\n  if (!noAssert) {                                                                                                     // 1119\n    var limit = Math.pow(2, 8 * byteLength - 1)                                                                        // 1120\n                                                                                                                       // 1121\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)                                                       // 1122\n  }                                                                                                                    // 1123\n                                                                                                                       // 1124\n  var i = byteLength - 1                                                                                               // 1125\n  var mul = 1                                                                                                          // 1126\n  var sub = value < 0 ? 1 : 0                                                                                          // 1127\n  this[offset + i] = value & 0xFF                                                                                      // 1128\n  while (--i >= 0 && (mul *= 0x100)) {                                                                                 // 1129\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF                                                               // 1130\n  }                                                                                                                    // 1131\n                                                                                                                       // 1132\n  return offset + byteLength                                                                                           // 1133\n}                                                                                                                      // 1134\n                                                                                                                       // 1135\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {                                            // 1136\n  value = +value                                                                                                       // 1137\n  offset = offset | 0                                                                                                  // 1138\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)                                                         // 1139\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)                                                           // 1140\n  if (value < 0) value = 0xff + value + 1                                                                              // 1141\n  this[offset] = (value & 0xff)                                                                                        // 1142\n  return offset + 1                                                                                                    // 1143\n}                                                                                                                      // 1144\n                                                                                                                       // 1145\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {                                      // 1146\n  value = +value                                                                                                       // 1147\n  offset = offset | 0                                                                                                  // 1148\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)                                                     // 1149\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                    // 1150\n    this[offset] = (value & 0xff)                                                                                      // 1151\n    this[offset + 1] = (value >>> 8)                                                                                   // 1152\n  } else {                                                                                                             // 1153\n    objectWriteUInt16(this, value, offset, true)                                                                       // 1154\n  }                                                                                                                    // 1155\n  return offset + 2                                                                                                    // 1156\n}                                                                                                                      // 1157\n                                                                                                                       // 1158\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {                                      // 1159\n  value = +value                                                                                                       // 1160\n  offset = offset | 0                                                                                                  // 1161\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)                                                     // 1162\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                    // 1163\n    this[offset] = (value >>> 8)                                                                                       // 1164\n    this[offset + 1] = (value & 0xff)                                                                                  // 1165\n  } else {                                                                                                             // 1166\n    objectWriteUInt16(this, value, offset, false)                                                                      // 1167\n  }                                                                                                                    // 1168\n  return offset + 2                                                                                                    // 1169\n}                                                                                                                      // 1170\n                                                                                                                       // 1171\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {                                      // 1172\n  value = +value                                                                                                       // 1173\n  offset = offset | 0                                                                                                  // 1174\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)                                             // 1175\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                    // 1176\n    this[offset] = (value & 0xff)                                                                                      // 1177\n    this[offset + 1] = (value >>> 8)                                                                                   // 1178\n    this[offset + 2] = (value >>> 16)                                                                                  // 1179\n    this[offset + 3] = (value >>> 24)                                                                                  // 1180\n  } else {                                                                                                             // 1181\n    objectWriteUInt32(this, value, offset, true)                                                                       // 1182\n  }                                                                                                                    // 1183\n  return offset + 4                                                                                                    // 1184\n}                                                                                                                      // 1185\n                                                                                                                       // 1186\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {                                      // 1187\n  value = +value                                                                                                       // 1188\n  offset = offset | 0                                                                                                  // 1189\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)                                             // 1190\n  if (value < 0) value = 0xffffffff + value + 1                                                                        // 1191\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                    // 1192\n    this[offset] = (value >>> 24)                                                                                      // 1193\n    this[offset + 1] = (value >>> 16)                                                                                  // 1194\n    this[offset + 2] = (value >>> 8)                                                                                   // 1195\n    this[offset + 3] = (value & 0xff)                                                                                  // 1196\n  } else {                                                                                                             // 1197\n    objectWriteUInt32(this, value, offset, false)                                                                      // 1198\n  }                                                                                                                    // 1199\n  return offset + 4                                                                                                    // 1200\n}                                                                                                                      // 1201\n                                                                                                                       // 1202\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {                                                            // 1203\n  if (offset + ext > buf.length) throw new RangeError('index out of range')                                            // 1204\n  if (offset < 0) throw new RangeError('index out of range')                                                           // 1205\n}                                                                                                                      // 1206\n                                                                                                                       // 1207\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {                                                     // 1208\n  if (!noAssert) {                                                                                                     // 1209\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)                               // 1210\n  }                                                                                                                    // 1211\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)                                                               // 1212\n  return offset + 4                                                                                                    // 1213\n}                                                                                                                      // 1214\n                                                                                                                       // 1215\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {                                      // 1216\n  return writeFloat(this, value, offset, true, noAssert)                                                               // 1217\n}                                                                                                                      // 1218\n                                                                                                                       // 1219\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {                                      // 1220\n  return writeFloat(this, value, offset, false, noAssert)                                                              // 1221\n}                                                                                                                      // 1222\n                                                                                                                       // 1223\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {                                                    // 1224\n  if (!noAssert) {                                                                                                     // 1225\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)                             // 1226\n  }                                                                                                                    // 1227\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)                                                               // 1228\n  return offset + 8                                                                                                    // 1229\n}                                                                                                                      // 1230\n                                                                                                                       // 1231\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {                                    // 1232\n  return writeDouble(this, value, offset, true, noAssert)                                                              // 1233\n}                                                                                                                      // 1234\n                                                                                                                       // 1235\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {                                    // 1236\n  return writeDouble(this, value, offset, false, noAssert)                                                             // 1237\n}                                                                                                                      // 1238\n                                                                                                                       // 1239\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)                                           // 1240\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {                                              // 1241\n  if (!start) start = 0                                                                                                // 1242\n  if (!end && end !== 0) end = this.length                                                                             // 1243\n  if (targetStart >= target.length) targetStart = target.length                                                        // 1244\n  if (!targetStart) targetStart = 0                                                                                    // 1245\n  if (end > 0 && end < start) end = start                                                                              // 1246\n                                                                                                                       // 1247\n  // Copy 0 bytes; we're done                                                                                          // 1248\n  if (end === start) return 0                                                                                          // 1249\n  if (target.length === 0 || this.length === 0) return 0                                                               // 1250\n                                                                                                                       // 1251\n  // Fatal error conditions                                                                                            // 1252\n  if (targetStart < 0) {                                                                                               // 1253\n    throw new RangeError('targetStart out of bounds')                                                                  // 1254\n  }                                                                                                                    // 1255\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')                             // 1256\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')                                                         // 1257\n                                                                                                                       // 1258\n  // Are we oob?                                                                                                       // 1259\n  if (end > this.length) end = this.length                                                                             // 1260\n  if (target.length - targetStart < end - start) {                                                                     // 1261\n    end = target.length - targetStart + start                                                                          // 1262\n  }                                                                                                                    // 1263\n                                                                                                                       // 1264\n  var len = end - start                                                                                                // 1265\n  var i                                                                                                                // 1266\n                                                                                                                       // 1267\n  if (this === target && start < targetStart && targetStart < end) {                                                   // 1268\n    // descending copy from end                                                                                        // 1269\n    for (i = len - 1; i >= 0; i--) {                                                                                   // 1270\n      target[i + targetStart] = this[i + start]                                                                        // 1271\n    }                                                                                                                  // 1272\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {                                                              // 1273\n    // ascending copy from start                                                                                       // 1274\n    for (i = 0; i < len; i++) {                                                                                        // 1275\n      target[i + targetStart] = this[i + start]                                                                        // 1276\n    }                                                                                                                  // 1277\n  } else {                                                                                                             // 1278\n    Uint8Array.prototype.set.call(                                                                                     // 1279\n      target,                                                                                                          // 1280\n      this.subarray(start, start + len),                                                                               // 1281\n      targetStart                                                                                                      // 1282\n    )                                                                                                                  // 1283\n  }                                                                                                                    // 1284\n                                                                                                                       // 1285\n  return len                                                                                                           // 1286\n}                                                                                                                      // 1287\n                                                                                                                       // 1288\n// fill(value, start=0, end=buffer.length)                                                                             // 1289\nBuffer.prototype.fill = function fill (value, start, end) {                                                            // 1290\n  if (!value) value = 0                                                                                                // 1291\n  if (!start) start = 0                                                                                                // 1292\n  if (!end) end = this.length                                                                                          // 1293\n                                                                                                                       // 1294\n  if (end < start) throw new RangeError('end < start')                                                                 // 1295\n                                                                                                                       // 1296\n  // Fill 0 bytes; we're done                                                                                          // 1297\n  if (end === start) return                                                                                            // 1298\n  if (this.length === 0) return                                                                                        // 1299\n                                                                                                                       // 1300\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')                                   // 1301\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')                                          // 1302\n                                                                                                                       // 1303\n  var i                                                                                                                // 1304\n  if (typeof value === 'number') {                                                                                     // 1305\n    for (i = start; i < end; i++) {                                                                                    // 1306\n      this[i] = value                                                                                                  // 1307\n    }                                                                                                                  // 1308\n  } else {                                                                                                             // 1309\n    var bytes = utf8ToBytes(value.toString())                                                                          // 1310\n    var len = bytes.length                                                                                             // 1311\n    for (i = start; i < end; i++) {                                                                                    // 1312\n      this[i] = bytes[i % len]                                                                                         // 1313\n    }                                                                                                                  // 1314\n  }                                                                                                                    // 1315\n                                                                                                                       // 1316\n  return this                                                                                                          // 1317\n}                                                                                                                      // 1318\n                                                                                                                       // 1319\n// HELPER FUNCTIONS                                                                                                    // 1320\n// ================                                                                                                    // 1321\n                                                                                                                       // 1322\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g                                                                           // 1323\n                                                                                                                       // 1324\nfunction base64clean (str) {                                                                                           // 1325\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not                             // 1326\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')                                                                 // 1327\n  // Node converts strings with length < 2 to ''                                                                       // 1328\n  if (str.length < 2) return ''                                                                                        // 1329\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not                              // 1330\n  while (str.length % 4 !== 0) {                                                                                       // 1331\n    str = str + '='                                                                                                    // 1332\n  }                                                                                                                    // 1333\n  return str                                                                                                           // 1334\n}                                                                                                                      // 1335\n                                                                                                                       // 1336\nfunction stringtrim (str) {                                                                                            // 1337\n  if (str.trim) return str.trim()                                                                                      // 1338\n  return str.replace(/^\\s+|\\s+$/g, '')                                                                                 // 1339\n}                                                                                                                      // 1340\n                                                                                                                       // 1341\nfunction toHex (n) {                                                                                                   // 1342\n  if (n < 16) return '0' + n.toString(16)                                                                              // 1343\n  return n.toString(16)                                                                                                // 1344\n}                                                                                                                      // 1345\n                                                                                                                       // 1346\nfunction utf8ToBytes (string, units) {                                                                                 // 1347\n  units = units || Infinity                                                                                            // 1348\n  var codePoint                                                                                                        // 1349\n  var length = string.length                                                                                           // 1350\n  var leadSurrogate = null                                                                                             // 1351\n  var bytes = []                                                                                                       // 1352\n                                                                                                                       // 1353\n  for (var i = 0; i < length; i++) {                                                                                   // 1354\n    codePoint = string.charCodeAt(i)                                                                                   // 1355\n                                                                                                                       // 1356\n    // is surrogate component                                                                                          // 1357\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {                                                                    // 1358\n      // last char was a lead                                                                                          // 1359\n      if (!leadSurrogate) {                                                                                            // 1360\n        // no lead yet                                                                                                 // 1361\n        if (codePoint > 0xDBFF) {                                                                                      // 1362\n          // unexpected trail                                                                                          // 1363\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)                                                          // 1364\n          continue                                                                                                     // 1365\n        } else if (i + 1 === length) {                                                                                 // 1366\n          // unpaired lead                                                                                             // 1367\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)                                                          // 1368\n          continue                                                                                                     // 1369\n        }                                                                                                              // 1370\n                                                                                                                       // 1371\n        // valid lead                                                                                                  // 1372\n        leadSurrogate = codePoint                                                                                      // 1373\n                                                                                                                       // 1374\n        continue                                                                                                       // 1375\n      }                                                                                                                // 1376\n                                                                                                                       // 1377\n      // 2 leads in a row                                                                                              // 1378\n      if (codePoint < 0xDC00) {                                                                                        // 1379\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)                                                            // 1380\n        leadSurrogate = codePoint                                                                                      // 1381\n        continue                                                                                                       // 1382\n      }                                                                                                                // 1383\n                                                                                                                       // 1384\n      // valid surrogate pair                                                                                          // 1385\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000                                        // 1386\n    } else if (leadSurrogate) {                                                                                        // 1387\n      // valid bmp char, but last char was a lead                                                                      // 1388\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)                                                              // 1389\n    }                                                                                                                  // 1390\n                                                                                                                       // 1391\n    leadSurrogate = null                                                                                               // 1392\n                                                                                                                       // 1393\n    // encode utf8                                                                                                     // 1394\n    if (codePoint < 0x80) {                                                                                            // 1395\n      if ((units -= 1) < 0) break                                                                                      // 1396\n      bytes.push(codePoint)                                                                                            // 1397\n    } else if (codePoint < 0x800) {                                                                                    // 1398\n      if ((units -= 2) < 0) break                                                                                      // 1399\n      bytes.push(                                                                                                      // 1400\n        codePoint >> 0x6 | 0xC0,                                                                                       // 1401\n        codePoint & 0x3F | 0x80                                                                                        // 1402\n      )                                                                                                                // 1403\n    } else if (codePoint < 0x10000) {                                                                                  // 1404\n      if ((units -= 3) < 0) break                                                                                      // 1405\n      bytes.push(                                                                                                      // 1406\n        codePoint >> 0xC | 0xE0,                                                                                       // 1407\n        codePoint >> 0x6 & 0x3F | 0x80,                                                                                // 1408\n        codePoint & 0x3F | 0x80                                                                                        // 1409\n      )                                                                                                                // 1410\n    } else if (codePoint < 0x110000) {                                                                                 // 1411\n      if ((units -= 4) < 0) break                                                                                      // 1412\n      bytes.push(                                                                                                      // 1413\n        codePoint >> 0x12 | 0xF0,                                                                                      // 1414\n        codePoint >> 0xC & 0x3F | 0x80,                                                                                // 1415\n        codePoint >> 0x6 & 0x3F | 0x80,                                                                                // 1416\n        codePoint & 0x3F | 0x80                                                                                        // 1417\n      )                                                                                                                // 1418\n    } else {                                                                                                           // 1419\n      throw new Error('Invalid code point')                                                                            // 1420\n    }                                                                                                                  // 1421\n  }                                                                                                                    // 1422\n                                                                                                                       // 1423\n  return bytes                                                                                                         // 1424\n}                                                                                                                      // 1425\n                                                                                                                       // 1426\nfunction asciiToBytes (str) {                                                                                          // 1427\n  var byteArray = []                                                                                                   // 1428\n  for (var i = 0; i < str.length; i++) {                                                                               // 1429\n    // Node's code seems to be doing this and not & 0x7F..                                                             // 1430\n    byteArray.push(str.charCodeAt(i) & 0xFF)                                                                           // 1431\n  }                                                                                                                    // 1432\n  return byteArray                                                                                                     // 1433\n}                                                                                                                      // 1434\n                                                                                                                       // 1435\nfunction utf16leToBytes (str, units) {                                                                                 // 1436\n  var c, hi, lo                                                                                                        // 1437\n  var byteArray = []                                                                                                   // 1438\n  for (var i = 0; i < str.length; i++) {                                                                               // 1439\n    if ((units -= 2) < 0) break                                                                                        // 1440\n                                                                                                                       // 1441\n    c = str.charCodeAt(i)                                                                                              // 1442\n    hi = c >> 8                                                                                                        // 1443\n    lo = c % 256                                                                                                       // 1444\n    byteArray.push(lo)                                                                                                 // 1445\n    byteArray.push(hi)                                                                                                 // 1446\n  }                                                                                                                    // 1447\n                                                                                                                       // 1448\n  return byteArray                                                                                                     // 1449\n}                                                                                                                      // 1450\n                                                                                                                       // 1451\nfunction base64ToBytes (str) {                                                                                         // 1452\n  return base64.toByteArray(base64clean(str))                                                                          // 1453\n}                                                                                                                      // 1454\n                                                                                                                       // 1455\nfunction blitBuffer (src, dst, offset, length) {                                                                       // 1456\n  for (var i = 0; i < length; i++) {                                                                                   // 1457\n    if ((i + offset >= dst.length) || (i >= src.length)) break                                                         // 1458\n    dst[i + offset] = src[i]                                                                                           // 1459\n  }                                                                                                                    // 1460\n  return i                                                                                                             // 1461\n}                                                                                                                      // 1462\n                                                                                                                       // 1463\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"base64-js\":{\"package.json\":function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/node_modules/base64-js/package.json                                                  //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nexports.name = \"base64-js\";                                                                                            // 1\nexports.version = \"1.0.4\";                                                                                             // 2\nexports.main = \"lib/b64.js\";                                                                                           // 3\n                                                                                                                       // 4\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"lib\":{\"b64.js\":function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/node_modules/base64-js/lib/b64.js                                                    //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n;(function (exports) {                                                                                                 // 1\n  'use strict'                                                                                                         // 2\n                                                                                                                       // 3\n  var i                                                                                                                // 4\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'                                        // 5\n  var lookup = []                                                                                                      // 6\n  for (i = 0; i < code.length; i++) {                                                                                  // 7\n    lookup[i] = code[i]                                                                                                // 8\n  }                                                                                                                    // 9\n  var revLookup = []                                                                                                   // 10\n                                                                                                                       // 11\n  for (i = 0; i < code.length; ++i) {                                                                                  // 12\n    revLookup[code.charCodeAt(i)] = i                                                                                  // 13\n  }                                                                                                                    // 14\n  revLookup['-'.charCodeAt(0)] = 62                                                                                    // 15\n  revLookup['_'.charCodeAt(0)] = 63                                                                                    // 16\n                                                                                                                       // 17\n  var Arr = (typeof Uint8Array !== 'undefined')                                                                        // 18\n    ? Uint8Array                                                                                                       // 19\n    : Array                                                                                                            // 20\n                                                                                                                       // 21\n  function decode (elt) {                                                                                              // 22\n    var v = revLookup[elt.charCodeAt(0)]                                                                               // 23\n    return v !== undefined ? v : -1                                                                                    // 24\n  }                                                                                                                    // 25\n                                                                                                                       // 26\n  function b64ToByteArray (b64) {                                                                                      // 27\n    var i, j, l, tmp, placeHolders, arr                                                                                // 28\n                                                                                                                       // 29\n    if (b64.length % 4 > 0) {                                                                                          // 30\n      throw new Error('Invalid string. Length must be a multiple of 4')                                                // 31\n    }                                                                                                                  // 32\n                                                                                                                       // 33\n    // the number of equal signs (place holders)                                                                       // 34\n    // if there are two placeholders, than the two characters before it                                                // 35\n    // represent one byte                                                                                              // 36\n    // if there is only one, then the three characters before it represent 2 bytes                                     // 37\n    // this is just a cheap hack to not do indexOf twice                                                               // 38\n    var len = b64.length                                                                                               // 39\n    placeHolders = b64.charAt(len - 2) === '=' ? 2 : b64.charAt(len - 1) === '=' ? 1 : 0                               // 40\n                                                                                                                       // 41\n    // base64 is 4/3 + up to two characters of the original data                                                       // 42\n    arr = new Arr(b64.length * 3 / 4 - placeHolders)                                                                   // 43\n                                                                                                                       // 44\n    // if there are placeholders, only get up to the last complete 4 chars                                             // 45\n    l = placeHolders > 0 ? b64.length - 4 : b64.length                                                                 // 46\n                                                                                                                       // 47\n    var L = 0                                                                                                          // 48\n                                                                                                                       // 49\n    function push (v) {                                                                                                // 50\n      arr[L++] = v                                                                                                     // 51\n    }                                                                                                                  // 52\n                                                                                                                       // 53\n    for (i = 0, j = 0; i < l; i += 4, j += 3) {                                                                        // 54\n      tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n      push((tmp & 0xFF0000) >> 16)                                                                                     // 56\n      push((tmp & 0xFF00) >> 8)                                                                                        // 57\n      push(tmp & 0xFF)                                                                                                 // 58\n    }                                                                                                                  // 59\n                                                                                                                       // 60\n    if (placeHolders === 2) {                                                                                          // 61\n      tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)                                            // 62\n      push(tmp & 0xFF)                                                                                                 // 63\n    } else if (placeHolders === 1) {                                                                                   // 64\n      tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)        // 65\n      push((tmp >> 8) & 0xFF)                                                                                          // 66\n      push(tmp & 0xFF)                                                                                                 // 67\n    }                                                                                                                  // 68\n                                                                                                                       // 69\n    return arr                                                                                                         // 70\n  }                                                                                                                    // 71\n                                                                                                                       // 72\n  function encode (num) {                                                                                              // 73\n    return lookup[num]                                                                                                 // 74\n  }                                                                                                                    // 75\n                                                                                                                       // 76\n  function tripletToBase64 (num) {                                                                                     // 77\n    return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)          // 78\n  }                                                                                                                    // 79\n                                                                                                                       // 80\n  function encodeChunk (uint8, start, end) {                                                                           // 81\n    var temp                                                                                                           // 82\n    var output = []                                                                                                    // 83\n    for (var i = start; i < end; i += 3) {                                                                             // 84\n      temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])                                                   // 85\n      output.push(tripletToBase64(temp))                                                                               // 86\n    }                                                                                                                  // 87\n    return output.join('')                                                                                             // 88\n  }                                                                                                                    // 89\n                                                                                                                       // 90\n  function uint8ToBase64 (uint8) {                                                                                     // 91\n    var i                                                                                                              // 92\n    var extraBytes = uint8.length % 3 // if we have 1 byte left, pad 2 bytes                                           // 93\n    var output = ''                                                                                                    // 94\n    var parts = []                                                                                                     // 95\n    var temp, length                                                                                                   // 96\n    var maxChunkLength = 16383 // must be multiple of 3                                                                // 97\n                                                                                                                       // 98\n    // go through the array every three bytes, we'll deal with trailing stuff later                                    // 99\n                                                                                                                       // 100\n    for (i = 0, length = uint8.length - extraBytes; i < length; i += maxChunkLength) {                                 // 101\n      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > length ? length : (i + maxChunkLength)))                 // 102\n    }                                                                                                                  // 103\n                                                                                                                       // 104\n    // pad the end with zeros, but make sure to not forget the extra bytes                                             // 105\n    switch (extraBytes) {                                                                                              // 106\n      case 1:                                                                                                          // 107\n        temp = uint8[uint8.length - 1]                                                                                 // 108\n        output += encode(temp >> 2)                                                                                    // 109\n        output += encode((temp << 4) & 0x3F)                                                                           // 110\n        output += '=='                                                                                                 // 111\n        break                                                                                                          // 112\n      case 2:                                                                                                          // 113\n        temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])                                              // 114\n        output += encode(temp >> 10)                                                                                   // 115\n        output += encode((temp >> 4) & 0x3F)                                                                           // 116\n        output += encode((temp << 2) & 0x3F)                                                                           // 117\n        output += '='                                                                                                  // 118\n        break                                                                                                          // 119\n      default:                                                                                                         // 120\n        break                                                                                                          // 121\n    }                                                                                                                  // 122\n                                                                                                                       // 123\n    parts.push(output)                                                                                                 // 124\n                                                                                                                       // 125\n    return parts.join('')                                                                                              // 126\n  }                                                                                                                    // 127\n                                                                                                                       // 128\n  exports.toByteArray = b64ToByteArray                                                                                 // 129\n  exports.fromByteArray = uint8ToBase64                                                                                // 130\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))                                                    // 131\n                                                                                                                       // 132\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},\"ieee754\":{\"package.json\":function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/node_modules/ieee754/package.json                                                    //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nexports.name = \"ieee754\";                                                                                              // 1\nexports.version = \"1.1.6\";                                                                                             // 2\nexports.main = \"index.js\";                                                                                             // 3\n                                                                                                                       // 4\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/node_modules/ieee754/index.js                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {                                                         // 1\n  var e, m                                                                                                             // 2\n  var eLen = nBytes * 8 - mLen - 1                                                                                     // 3\n  var eMax = (1 << eLen) - 1                                                                                           // 4\n  var eBias = eMax >> 1                                                                                                // 5\n  var nBits = -7                                                                                                       // 6\n  var i = isLE ? (nBytes - 1) : 0                                                                                      // 7\n  var d = isLE ? -1 : 1                                                                                                // 8\n  var s = buffer[offset + i]                                                                                           // 9\n                                                                                                                       // 10\n  i += d                                                                                                               // 11\n                                                                                                                       // 12\n  e = s & ((1 << (-nBits)) - 1)                                                                                        // 13\n  s >>= (-nBits)                                                                                                       // 14\n  nBits += eLen                                                                                                        // 15\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}                                           // 16\n                                                                                                                       // 17\n  m = e & ((1 << (-nBits)) - 1)                                                                                        // 18\n  e >>= (-nBits)                                                                                                       // 19\n  nBits += mLen                                                                                                        // 20\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}                                           // 21\n                                                                                                                       // 22\n  if (e === 0) {                                                                                                       // 23\n    e = 1 - eBias                                                                                                      // 24\n  } else if (e === eMax) {                                                                                             // 25\n    return m ? NaN : ((s ? -1 : 1) * Infinity)                                                                         // 26\n  } else {                                                                                                             // 27\n    m = m + Math.pow(2, mLen)                                                                                          // 28\n    e = e - eBias                                                                                                      // 29\n  }                                                                                                                    // 30\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)                                                                      // 31\n}                                                                                                                      // 32\n                                                                                                                       // 33\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {                                                 // 34\n  var e, m, c                                                                                                          // 35\n  var eLen = nBytes * 8 - mLen - 1                                                                                     // 36\n  var eMax = (1 << eLen) - 1                                                                                           // 37\n  var eBias = eMax >> 1                                                                                                // 38\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)                                                     // 39\n  var i = isLE ? 0 : (nBytes - 1)                                                                                      // 40\n  var d = isLE ? 1 : -1                                                                                                // 41\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0                                                          // 42\n                                                                                                                       // 43\n  value = Math.abs(value)                                                                                              // 44\n                                                                                                                       // 45\n  if (isNaN(value) || value === Infinity) {                                                                            // 46\n    m = isNaN(value) ? 1 : 0                                                                                           // 47\n    e = eMax                                                                                                           // 48\n  } else {                                                                                                             // 49\n    e = Math.floor(Math.log(value) / Math.LN2)                                                                         // 50\n    if (value * (c = Math.pow(2, -e)) < 1) {                                                                           // 51\n      e--                                                                                                              // 52\n      c *= 2                                                                                                           // 53\n    }                                                                                                                  // 54\n    if (e + eBias >= 1) {                                                                                              // 55\n      value += rt / c                                                                                                  // 56\n    } else {                                                                                                           // 57\n      value += rt * Math.pow(2, 1 - eBias)                                                                             // 58\n    }                                                                                                                  // 59\n    if (value * c >= 2) {                                                                                              // 60\n      e++                                                                                                              // 61\n      c /= 2                                                                                                           // 62\n    }                                                                                                                  // 63\n                                                                                                                       // 64\n    if (e + eBias >= eMax) {                                                                                           // 65\n      m = 0                                                                                                            // 66\n      e = eMax                                                                                                         // 67\n    } else if (e + eBias >= 1) {                                                                                       // 68\n      m = (value * c - 1) * Math.pow(2, mLen)                                                                          // 69\n      e = e + eBias                                                                                                    // 70\n    } else {                                                                                                           // 71\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)                                                           // 72\n      e = 0                                                                                                            // 73\n    }                                                                                                                  // 74\n  }                                                                                                                    // 75\n                                                                                                                       // 76\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}                                     // 77\n                                                                                                                       // 78\n  e = (e << mLen) | m                                                                                                  // 79\n  eLen += mLen                                                                                                         // 80\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}                                      // 81\n                                                                                                                       // 82\n  buffer[offset + i - d] |= s * 128                                                                                    // 83\n}                                                                                                                      // 84\n                                                                                                                       // 85\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"isarray\":{\"package.json\":function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/node_modules/isarray/package.json                                                    //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nexports.name = \"isarray\";                                                                                              // 1\nexports.version = \"1.0.0\";                                                                                             // 2\nexports.main = \"index.js\";                                                                                             // 3\n                                                                                                                       // 4\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/node_modules/isarray/index.js                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar toString = {}.toString;                                                                                            // 1\n                                                                                                                       // 2\nmodule.exports = Array.isArray || function (arr) {                                                                     // 3\n  return toString.call(arr) == '[object Array]';                                                                       // 4\n};                                                                                                                     // 5\n                                                                                                                       // 6\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"process\":{\"browser.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/node_modules/process/browser.js                                                      //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// shim for using process in browser                                                                                   // 1\n                                                                                                                       // 2\nvar process = module.exports = {};                                                                                     // 3\nvar queue = [];                                                                                                        // 4\nvar draining = false;                                                                                                  // 5\nvar currentQueue;                                                                                                      // 6\nvar queueIndex = -1;                                                                                                   // 7\n                                                                                                                       // 8\nfunction cleanUpNextTick() {                                                                                           // 9\n    draining = false;                                                                                                  // 10\n    if (currentQueue.length) {                                                                                         // 11\n        queue = currentQueue.concat(queue);                                                                            // 12\n    } else {                                                                                                           // 13\n        queueIndex = -1;                                                                                               // 14\n    }                                                                                                                  // 15\n    if (queue.length) {                                                                                                // 16\n        drainQueue();                                                                                                  // 17\n    }                                                                                                                  // 18\n}                                                                                                                      // 19\n                                                                                                                       // 20\nfunction drainQueue() {                                                                                                // 21\n    if (draining) {                                                                                                    // 22\n        return;                                                                                                        // 23\n    }                                                                                                                  // 24\n    var timeout = setTimeout(cleanUpNextTick);                                                                         // 25\n    draining = true;                                                                                                   // 26\n                                                                                                                       // 27\n    var len = queue.length;                                                                                            // 28\n    while(len) {                                                                                                       // 29\n        currentQueue = queue;                                                                                          // 30\n        queue = [];                                                                                                    // 31\n        while (++queueIndex < len) {                                                                                   // 32\n            if (currentQueue) {                                                                                        // 33\n                currentQueue[queueIndex].run();                                                                        // 34\n            }                                                                                                          // 35\n        }                                                                                                              // 36\n        queueIndex = -1;                                                                                               // 37\n        len = queue.length;                                                                                            // 38\n    }                                                                                                                  // 39\n    currentQueue = null;                                                                                               // 40\n    draining = false;                                                                                                  // 41\n    clearTimeout(timeout);                                                                                             // 42\n}                                                                                                                      // 43\n                                                                                                                       // 44\nprocess.nextTick = function (fun) {                                                                                    // 45\n    var args = new Array(arguments.length - 1);                                                                        // 46\n    if (arguments.length > 1) {                                                                                        // 47\n        for (var i = 1; i < arguments.length; i++) {                                                                   // 48\n            args[i - 1] = arguments[i];                                                                                // 49\n        }                                                                                                              // 50\n    }                                                                                                                  // 51\n    queue.push(new Item(fun, args));                                                                                   // 52\n    if (queue.length === 1 && !draining) {                                                                             // 53\n        setTimeout(drainQueue, 0);                                                                                     // 54\n    }                                                                                                                  // 55\n};                                                                                                                     // 56\n                                                                                                                       // 57\n// v8 likes predictible objects                                                                                        // 58\nfunction Item(fun, array) {                                                                                            // 59\n    this.fun = fun;                                                                                                    // 60\n    this.array = array;                                                                                                // 61\n}                                                                                                                      // 62\nItem.prototype.run = function () {                                                                                     // 63\n    this.fun.apply(null, this.array);                                                                                  // 64\n};                                                                                                                     // 65\nprocess.title = 'browser';                                                                                             // 66\nprocess.browser = true;                                                                                                // 67\nprocess.env = {};                                                                                                      // 68\nprocess.argv = [];                                                                                                     // 69\nprocess.version = ''; // empty string to avoid regexp issues                                                           // 70\nprocess.versions = {};                                                                                                 // 71\n                                                                                                                       // 72\nfunction noop() {}                                                                                                     // 73\n                                                                                                                       // 74\nprocess.on = noop;                                                                                                     // 75\nprocess.addListener = noop;                                                                                            // 76\nprocess.once = noop;                                                                                                   // 77\nprocess.off = noop;                                                                                                    // 78\nprocess.removeListener = noop;                                                                                         // 79\nprocess.removeAllListeners = noop;                                                                                     // 80\nprocess.emit = noop;                                                                                                   // 81\n                                                                                                                       // 82\nprocess.binding = function (name) {                                                                                    // 83\n    throw new Error('process.binding is not supported');                                                               // 84\n};                                                                                                                     // 85\n                                                                                                                       // 86\nprocess.cwd = function () { return '/' };                                                                              // 87\nprocess.chdir = function (dir) {                                                                                       // 88\n    throw new Error('process.chdir is not supported');                                                                 // 89\n};                                                                                                                     // 90\nprocess.umask = function() { return 0; };                                                                              // 91\n                                                                                                                       // 92\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"domain-browser\":{\"package.json\":function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/node_modules/domain-browser/package.json                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nexports.name = \"domain-browser\";                                                                                       // 1\nexports.version = \"1.1.7\";                                                                                             // 2\nexports.main = \"./index.js\";                                                                                           // 3\n                                                                                                                       // 4\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"events\",function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/node_modules/domain-browser/index.js                                                 //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// This file should be ES5 compatible                                                                                  // 1\n/* eslint prefer-spread:0, no-var:0, prefer-reflect:0, no-magic-numbers:0 */                                           // 2\n'use strict'                                                                                                           // 3\nmodule.exports = (function () {                                                                                        // 4\n\t// Import Events                                                                                                      // 5\n\tvar events = require('events')                                                                                        // 6\n                                                                                                                       // 7\n\t// Export Domain                                                                                                      // 8\n\tvar domain = {}                                                                                                       // 9\n\tdomain.createDomain = domain.create = function () {                                                                   // 10\n\t\tvar d = new events.EventEmitter()                                                                                    // 11\n                                                                                                                       // 12\n\t\tfunction emitError (e) {                                                                                             // 13\n\t\t\td.emit('error', e)                                                                                                  // 14\n\t\t}                                                                                                                    // 15\n                                                                                                                       // 16\n\t\td.add = function (emitter) {                                                                                         // 17\n\t\t\temitter.on('error', emitError)                                                                                      // 18\n\t\t}                                                                                                                    // 19\n\t\td.remove = function (emitter) {                                                                                      // 20\n\t\t\temitter.removeListener('error', emitError)                                                                          // 21\n\t\t}                                                                                                                    // 22\n\t\td.bind = function (fn) {                                                                                             // 23\n\t\t\treturn function () {                                                                                                // 24\n\t\t\t\tvar args = Array.prototype.slice.call(arguments)                                                                   // 25\n\t\t\t\ttry {                                                                                                              // 26\n\t\t\t\t\tfn.apply(null, args)                                                                                              // 27\n\t\t\t\t}                                                                                                                  // 28\n\t\t\t\tcatch (err) {                                                                                                      // 29\n\t\t\t\t\temitError(err)                                                                                                    // 30\n\t\t\t\t}                                                                                                                  // 31\n\t\t\t}                                                                                                                   // 32\n\t\t}                                                                                                                    // 33\n\t\td.intercept = function (fn) {                                                                                        // 34\n\t\t\treturn function (err) {                                                                                             // 35\n\t\t\t\tif ( err ) {                                                                                                       // 36\n\t\t\t\t\temitError(err)                                                                                                    // 37\n\t\t\t\t}                                                                                                                  // 38\n\t\t\t\telse {                                                                                                             // 39\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments, 1)                                                               // 40\n\t\t\t\t\ttry {                                                                                                             // 41\n\t\t\t\t\t\tfn.apply(null, args)                                                                                             // 42\n\t\t\t\t\t}                                                                                                                 // 43\n\t\t\t\t\tcatch (err) {                                                                                                     // 44\n\t\t\t\t\t\temitError(err)                                                                                                   // 45\n\t\t\t\t\t}                                                                                                                 // 46\n\t\t\t\t}                                                                                                                  // 47\n\t\t\t}                                                                                                                   // 48\n\t\t}                                                                                                                    // 49\n\t\td.run = function (fn) {                                                                                              // 50\n\t\t\ttry {                                                                                                               // 51\n\t\t\t\tfn()                                                                                                               // 52\n\t\t\t}                                                                                                                   // 53\n\t\t\tcatch (err) {                                                                                                       // 54\n\t\t\t\temitError(err)                                                                                                     // 55\n\t\t\t}                                                                                                                   // 56\n\t\t\treturn this                                                                                                         // 57\n\t\t}                                                                                                                    // 58\n\t\td.dispose = function () {                                                                                            // 59\n\t\t\tthis.removeAllListeners()                                                                                           // 60\n\t\t\treturn this                                                                                                         // 61\n\t\t}                                                                                                                    // 62\n\t\td.enter = d.exit = function () {                                                                                     // 63\n\t\t\treturn this                                                                                                         // 64\n\t\t}                                                                                                                    // 65\n\t\treturn d                                                                                                             // 66\n\t}                                                                                                                     // 67\n\treturn domain                                                                                                         // 68\n}).call(this)                                                                                                          // 69\n                                                                                                                       // 70\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"events\":{\"package.json\":function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/node_modules/events/package.json                                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nexports.name = \"events\";                                                                                               // 1\nexports.version = \"1.1.0\";                                                                                             // 2\nexports.main = \"./events.js\";                                                                                          // 3\n                                                                                                                       // 4\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"events.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor-node-stubs/node_modules/events/events.js                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// Copyright Joyent, Inc. and other Node contributors.                                                                 // 1\n//                                                                                                                     // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                             // 3\n// copy of this software and associated documentation files (the                                                       // 4\n// \"Software\"), to deal in the Software without restriction, including                                                 // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                                 // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                           // 7\n// persons to whom the Software is furnished to do so, subject to the                                                  // 8\n// following conditions:                                                                                               // 9\n//                                                                                                                     // 10\n// The above copyright notice and this permission notice shall be included                                             // 11\n// in all copies or substantial portions of the Software.                                                              // 12\n//                                                                                                                     // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                             // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                          // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                           // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                            // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                               // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                           // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                              // 20\n                                                                                                                       // 21\nfunction EventEmitter() {                                                                                              // 22\n  this._events = this._events || {};                                                                                   // 23\n  this._maxListeners = this._maxListeners || undefined;                                                                // 24\n}                                                                                                                      // 25\nmodule.exports = EventEmitter;                                                                                         // 26\n                                                                                                                       // 27\n// Backwards-compat with node 0.10.x                                                                                   // 28\nEventEmitter.EventEmitter = EventEmitter;                                                                              // 29\n                                                                                                                       // 30\nEventEmitter.prototype._events = undefined;                                                                            // 31\nEventEmitter.prototype._maxListeners = undefined;                                                                      // 32\n                                                                                                                       // 33\n// By default EventEmitters will print a warning if more than 10 listeners are                                         // 34\n// added to it. This is a useful default which helps finding memory leaks.                                             // 35\nEventEmitter.defaultMaxListeners = 10;                                                                                 // 36\n                                                                                                                       // 37\n// Obviously not all Emitters should be limited to 10. This function allows                                            // 38\n// that to be increased. Set to zero for unlimited.                                                                    // 39\nEventEmitter.prototype.setMaxListeners = function(n) {                                                                 // 40\n  if (!isNumber(n) || n < 0 || isNaN(n))                                                                               // 41\n    throw TypeError('n must be a positive number');                                                                    // 42\n  this._maxListeners = n;                                                                                              // 43\n  return this;                                                                                                         // 44\n};                                                                                                                     // 45\n                                                                                                                       // 46\nEventEmitter.prototype.emit = function(type) {                                                                         // 47\n  var er, handler, len, args, i, listeners;                                                                            // 48\n                                                                                                                       // 49\n  if (!this._events)                                                                                                   // 50\n    this._events = {};                                                                                                 // 51\n                                                                                                                       // 52\n  // If there is no 'error' event listener then throw.                                                                 // 53\n  if (type === 'error') {                                                                                              // 54\n    if (!this._events.error ||                                                                                         // 55\n        (isObject(this._events.error) && !this._events.error.length)) {                                                // 56\n      er = arguments[1];                                                                                               // 57\n      if (er instanceof Error) {                                                                                       // 58\n        throw er; // Unhandled 'error' event                                                                           // 59\n      }                                                                                                                // 60\n      throw TypeError('Uncaught, unspecified \"error\" event.');                                                         // 61\n    }                                                                                                                  // 62\n  }                                                                                                                    // 63\n                                                                                                                       // 64\n  handler = this._events[type];                                                                                        // 65\n                                                                                                                       // 66\n  if (isUndefined(handler))                                                                                            // 67\n    return false;                                                                                                      // 68\n                                                                                                                       // 69\n  if (isFunction(handler)) {                                                                                           // 70\n    switch (arguments.length) {                                                                                        // 71\n      // fast cases                                                                                                    // 72\n      case 1:                                                                                                          // 73\n        handler.call(this);                                                                                            // 74\n        break;                                                                                                         // 75\n      case 2:                                                                                                          // 76\n        handler.call(this, arguments[1]);                                                                              // 77\n        break;                                                                                                         // 78\n      case 3:                                                                                                          // 79\n        handler.call(this, arguments[1], arguments[2]);                                                                // 80\n        break;                                                                                                         // 81\n      // slower                                                                                                        // 82\n      default:                                                                                                         // 83\n        args = Array.prototype.slice.call(arguments, 1);                                                               // 84\n        handler.apply(this, args);                                                                                     // 85\n    }                                                                                                                  // 86\n  } else if (isObject(handler)) {                                                                                      // 87\n    args = Array.prototype.slice.call(arguments, 1);                                                                   // 88\n    listeners = handler.slice();                                                                                       // 89\n    len = listeners.length;                                                                                            // 90\n    for (i = 0; i < len; i++)                                                                                          // 91\n      listeners[i].apply(this, args);                                                                                  // 92\n  }                                                                                                                    // 93\n                                                                                                                       // 94\n  return true;                                                                                                         // 95\n};                                                                                                                     // 96\n                                                                                                                       // 97\nEventEmitter.prototype.addListener = function(type, listener) {                                                        // 98\n  var m;                                                                                                               // 99\n                                                                                                                       // 100\n  if (!isFunction(listener))                                                                                           // 101\n    throw TypeError('listener must be a function');                                                                    // 102\n                                                                                                                       // 103\n  if (!this._events)                                                                                                   // 104\n    this._events = {};                                                                                                 // 105\n                                                                                                                       // 106\n  // To avoid recursion in the case that type === \"newListener\"! Before                                                // 107\n  // adding it to the listeners, first emit \"newListener\".                                                             // 108\n  if (this._events.newListener)                                                                                        // 109\n    this.emit('newListener', type,                                                                                     // 110\n              isFunction(listener.listener) ?                                                                          // 111\n              listener.listener : listener);                                                                           // 112\n                                                                                                                       // 113\n  if (!this._events[type])                                                                                             // 114\n    // Optimize the case of one listener. Don't need the extra array object.                                           // 115\n    this._events[type] = listener;                                                                                     // 116\n  else if (isObject(this._events[type]))                                                                               // 117\n    // If we've already got an array, just append.                                                                     // 118\n    this._events[type].push(listener);                                                                                 // 119\n  else                                                                                                                 // 120\n    // Adding the second element, need to change to array.                                                             // 121\n    this._events[type] = [this._events[type], listener];                                                               // 122\n                                                                                                                       // 123\n  // Check for listener leak                                                                                           // 124\n  if (isObject(this._events[type]) && !this._events[type].warned) {                                                    // 125\n    if (!isUndefined(this._maxListeners)) {                                                                            // 126\n      m = this._maxListeners;                                                                                          // 127\n    } else {                                                                                                           // 128\n      m = EventEmitter.defaultMaxListeners;                                                                            // 129\n    }                                                                                                                  // 130\n                                                                                                                       // 131\n    if (m && m > 0 && this._events[type].length > m) {                                                                 // 132\n      this._events[type].warned = true;                                                                                // 133\n      console.error('(node) warning: possible EventEmitter memory ' +                                                  // 134\n                    'leak detected. %d listeners added. ' +                                                            // 135\n                    'Use emitter.setMaxListeners() to increase limit.',                                                // 136\n                    this._events[type].length);                                                                        // 137\n      if (typeof console.trace === 'function') {                                                                       // 138\n        // not supported in IE 10                                                                                      // 139\n        console.trace();                                                                                               // 140\n      }                                                                                                                // 141\n    }                                                                                                                  // 142\n  }                                                                                                                    // 143\n                                                                                                                       // 144\n  return this;                                                                                                         // 145\n};                                                                                                                     // 146\n                                                                                                                       // 147\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;                                                        // 148\n                                                                                                                       // 149\nEventEmitter.prototype.once = function(type, listener) {                                                               // 150\n  if (!isFunction(listener))                                                                                           // 151\n    throw TypeError('listener must be a function');                                                                    // 152\n                                                                                                                       // 153\n  var fired = false;                                                                                                   // 154\n                                                                                                                       // 155\n  function g() {                                                                                                       // 156\n    this.removeListener(type, g);                                                                                      // 157\n                                                                                                                       // 158\n    if (!fired) {                                                                                                      // 159\n      fired = true;                                                                                                    // 160\n      listener.apply(this, arguments);                                                                                 // 161\n    }                                                                                                                  // 162\n  }                                                                                                                    // 163\n                                                                                                                       // 164\n  g.listener = listener;                                                                                               // 165\n  this.on(type, g);                                                                                                    // 166\n                                                                                                                       // 167\n  return this;                                                                                                         // 168\n};                                                                                                                     // 169\n                                                                                                                       // 170\n// emits a 'removeListener' event iff the listener was removed                                                         // 171\nEventEmitter.prototype.removeListener = function(type, listener) {                                                     // 172\n  var list, position, length, i;                                                                                       // 173\n                                                                                                                       // 174\n  if (!isFunction(listener))                                                                                           // 175\n    throw TypeError('listener must be a function');                                                                    // 176\n                                                                                                                       // 177\n  if (!this._events || !this._events[type])                                                                            // 178\n    return this;                                                                                                       // 179\n                                                                                                                       // 180\n  list = this._events[type];                                                                                           // 181\n  length = list.length;                                                                                                // 182\n  position = -1;                                                                                                       // 183\n                                                                                                                       // 184\n  if (list === listener ||                                                                                             // 185\n      (isFunction(list.listener) && list.listener === listener)) {                                                     // 186\n    delete this._events[type];                                                                                         // 187\n    if (this._events.removeListener)                                                                                   // 188\n      this.emit('removeListener', type, listener);                                                                     // 189\n                                                                                                                       // 190\n  } else if (isObject(list)) {                                                                                         // 191\n    for (i = length; i-- > 0;) {                                                                                       // 192\n      if (list[i] === listener ||                                                                                      // 193\n          (list[i].listener && list[i].listener === listener)) {                                                       // 194\n        position = i;                                                                                                  // 195\n        break;                                                                                                         // 196\n      }                                                                                                                // 197\n    }                                                                                                                  // 198\n                                                                                                                       // 199\n    if (position < 0)                                                                                                  // 200\n      return this;                                                                                                     // 201\n                                                                                                                       // 202\n    if (list.length === 1) {                                                                                           // 203\n      list.length = 0;                                                                                                 // 204\n      delete this._events[type];                                                                                       // 205\n    } else {                                                                                                           // 206\n      list.splice(position, 1);                                                                                        // 207\n    }                                                                                                                  // 208\n                                                                                                                       // 209\n    if (this._events.removeListener)                                                                                   // 210\n      this.emit('removeListener', type, listener);                                                                     // 211\n  }                                                                                                                    // 212\n                                                                                                                       // 213\n  return this;                                                                                                         // 214\n};                                                                                                                     // 215\n                                                                                                                       // 216\nEventEmitter.prototype.removeAllListeners = function(type) {                                                           // 217\n  var key, listeners;                                                                                                  // 218\n                                                                                                                       // 219\n  if (!this._events)                                                                                                   // 220\n    return this;                                                                                                       // 221\n                                                                                                                       // 222\n  // not listening for removeListener, no need to emit                                                                 // 223\n  if (!this._events.removeListener) {                                                                                  // 224\n    if (arguments.length === 0)                                                                                        // 225\n      this._events = {};                                                                                               // 226\n    else if (this._events[type])                                                                                       // 227\n      delete this._events[type];                                                                                       // 228\n    return this;                                                                                                       // 229\n  }                                                                                                                    // 230\n                                                                                                                       // 231\n  // emit removeListener for all listeners on all events                                                               // 232\n  if (arguments.length === 0) {                                                                                        // 233\n    for (key in this._events) {                                                                                        // 234\n      if (key === 'removeListener') continue;                                                                          // 235\n      this.removeAllListeners(key);                                                                                    // 236\n    }                                                                                                                  // 237\n    this.removeAllListeners('removeListener');                                                                         // 238\n    this._events = {};                                                                                                 // 239\n    return this;                                                                                                       // 240\n  }                                                                                                                    // 241\n                                                                                                                       // 242\n  listeners = this._events[type];                                                                                      // 243\n                                                                                                                       // 244\n  if (isFunction(listeners)) {                                                                                         // 245\n    this.removeListener(type, listeners);                                                                              // 246\n  } else if (listeners) {                                                                                              // 247\n    // LIFO order                                                                                                      // 248\n    while (listeners.length)                                                                                           // 249\n      this.removeListener(type, listeners[listeners.length - 1]);                                                      // 250\n  }                                                                                                                    // 251\n  delete this._events[type];                                                                                           // 252\n                                                                                                                       // 253\n  return this;                                                                                                         // 254\n};                                                                                                                     // 255\n                                                                                                                       // 256\nEventEmitter.prototype.listeners = function(type) {                                                                    // 257\n  var ret;                                                                                                             // 258\n  if (!this._events || !this._events[type])                                                                            // 259\n    ret = [];                                                                                                          // 260\n  else if (isFunction(this._events[type]))                                                                             // 261\n    ret = [this._events[type]];                                                                                        // 262\n  else                                                                                                                 // 263\n    ret = this._events[type].slice();                                                                                  // 264\n  return ret;                                                                                                          // 265\n};                                                                                                                     // 266\n                                                                                                                       // 267\nEventEmitter.prototype.listenerCount = function(type) {                                                                // 268\n  if (this._events) {                                                                                                  // 269\n    var evlistener = this._events[type];                                                                               // 270\n                                                                                                                       // 271\n    if (isFunction(evlistener))                                                                                        // 272\n      return 1;                                                                                                        // 273\n    else if (evlistener)                                                                                               // 274\n      return evlistener.length;                                                                                        // 275\n  }                                                                                                                    // 276\n  return 0;                                                                                                            // 277\n};                                                                                                                     // 278\n                                                                                                                       // 279\nEventEmitter.listenerCount = function(emitter, type) {                                                                 // 280\n  return emitter.listenerCount(type);                                                                                  // 281\n};                                                                                                                     // 282\n                                                                                                                       // 283\nfunction isFunction(arg) {                                                                                             // 284\n  return typeof arg === 'function';                                                                                    // 285\n}                                                                                                                      // 286\n                                                                                                                       // 287\nfunction isNumber(arg) {                                                                                               // 288\n  return typeof arg === 'number';                                                                                      // 289\n}                                                                                                                      // 290\n                                                                                                                       // 291\nfunction isObject(arg) {                                                                                               // 292\n  return typeof arg === 'object' && arg !== null;                                                                      // 293\n}                                                                                                                      // 294\n                                                                                                                       // 295\nfunction isUndefined(arg) {                                                                                            // 296\n  return arg === void 0;                                                                                               // 297\n}                                                                                                                      // 298\n                                                                                                                       // 299\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}},{\"extensions\":[\".js\",\".json\"]});\nvar exports = require(\"./node_modules/meteor/modules/client.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package.modules = exports, {\n  meteorInstall: meteorInstall,\n  Buffer: Buffer,\n  process: process\n});\n\n})();\n","servePath":"/packages/modules.js","sourceMap":{"version":3,"sources":["/packages/modules/client.js","/packages/modules/buffer.js","/packages/modules/css.js","/packages/modules/install-packages.js","/packages/modules/process.js","/packages/modules/stubs.js","node_modules/webcola/package.json","node_modules/webcola/WebCola/index.js","node_modules/meteor-node-stubs/package.json","node_modules/meteor-node-stubs/index.js","node_modules/meteor-node-stubs/map.json","node_modules/meteor-node-stubs/deps/buffer.js","node_modules/meteor-node-stubs/deps/process.js","node_modules/meteor-node-stubs/deps/domain.js","node_modules/meteor-node-stubs/node_modules/buffer/package.json","node_modules/meteor-node-stubs/node_modules/buffer/index.js","node_modules/meteor-node-stubs/node_modules/base64-js/package.json","node_modules/meteor-node-stubs/node_modules/base64-js/lib/b64.js","node_modules/meteor-node-stubs/node_modules/ieee754/package.json","node_modules/meteor-node-stubs/node_modules/ieee754/index.js","node_modules/meteor-node-stubs/node_modules/isarray/package.json","node_modules/meteor-node-stubs/node_modules/isarray/index.js","node_modules/meteor-node-stubs/node_modules/process/browser.js","node_modules/meteor-node-stubs/node_modules/domain-browser/package.json","node_modules/meteor-node-stubs/node_modules/domain-browser/index.js","node_modules/meteor-node-stubs/node_modules/events/package.json","node_modules/meteor-node-stubs/node_modules/events/events.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACNA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACNA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8H;;;;;;;;;;;AClyJA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;ACxCA;AACA,2H;;;;;;;;;;;ACDA;AACA,2H;;;;;;;;;;;ACDA;AACA,2H;;;;;;;;;;;ACDA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8H;;;;;;;;;;;ACt7CA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;ACnIA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;ACpFA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;AC3FA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;ACrEA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H","file":"/packages/modules.js","sourcesContent":["require(\"./install-packages.js\");\nrequire(\"./stubs.js\");\nrequire(\"./buffer.js\");\nrequire(\"./process.js\");\n\nexports.addStyles = require(\"./css\").addStyles;\n","try {\n  Buffer = global.Buffer || require(\"buffer\").Buffer;\n} catch (noBuffer) {}\n","var doc = document;\nvar head = doc.getElementsByTagName(\"head\").item(0);\n\nexports.addStyles = function (css) {\n  var style = doc.createElement(\"style\");\n\n  style.setAttribute(\"type\", \"text/css\");\n\n  // https://msdn.microsoft.com/en-us/library/ms535871(v=vs.85).aspx\n  var internetExplorerSheetObject =\n    style.sheet || // Edge/IE11.\n    style.styleSheet; // Older IEs.\n\n  if (internetExplorerSheetObject) {\n    internetExplorerSheetObject.cssText = css;\n  } else {\n    style.appendChild(doc.createTextNode(css));\n  }\n\n  return head.appendChild(style);\n};\n","function install(name) {\n  var meteorDir = {};\n\n  // Given a package name <name>, install a stub module in the\n  // /node_modules/meteor directory called <name>.js, so that\n  // require.resolve(\"meteor/<name>\") will always return\n  // /node_modules/meteor/<name>.js instead of something like\n  // /node_modules/meteor/<name>/index.js, in the rare but possible event\n  // that the package contains a file called index.js (#6590).\n  meteorDir[name + \".js\"] = function (r, e, module) {\n    module.exports = Package[name];\n  };\n\n  meteorInstall({\n    node_modules: {\n      meteor: meteorDir\n    }\n  });\n}\n\n// This file will be modified during computeJsOutputFilesMap to include\n// install(<name>) calls for every Meteor package.\n\ninstall(\"underscore\");\ninstall(\"meteor\");\ninstall(\"meteor-base\");\ninstall(\"mobile-experience\");\ninstall(\"babel-compiler\");\ninstall(\"ecmascript\");\ninstall(\"base64\");\ninstall(\"ejson\");\ninstall(\"id-map\");\ninstall(\"ordered-dict\");\ninstall(\"tracker\");\ninstall(\"modules-runtime\");\ninstall(\"modules\");\ninstall(\"es5-shim\");\ninstall(\"promise\");\ninstall(\"ecmascript-runtime\");\ninstall(\"babel-runtime\");\ninstall(\"random\");\ninstall(\"mongo-id\");\ninstall(\"diff-sequence\");\ninstall(\"geojson-utils\");\ninstall(\"minimongo\");\ninstall(\"check\");\ninstall(\"retry\");\ninstall(\"ddp-common\");\ninstall(\"reload\");\ninstall(\"ddp-client\");\ninstall(\"ddp\");\ninstall(\"ddp-server\");\ninstall(\"allow-deny\");\ninstall(\"mongo\");\ninstall(\"blaze-html-templates\");\ninstall(\"reactive-dict\");\ninstall(\"session\");\ninstall(\"jquery\");\ninstall(\"url\");\ninstall(\"http\");\ninstall(\"deps\");\ninstall(\"htmljs\");\ninstall(\"observe-sequence\");\ninstall(\"reactive-var\");\ninstall(\"blaze\");\ninstall(\"ui\");\ninstall(\"spacebars\");\ninstall(\"templating\");\ninstall(\"iron:core\");\ninstall(\"iron:dynamic-template\");\ninstall(\"iron:layout\");\ninstall(\"iron:url\");\ninstall(\"iron:middleware-stack\");\ninstall(\"iron:location\");\ninstall(\"iron:controller\");\ninstall(\"iron:router\");\ninstall(\"twbs:bootstrap\");\ninstall(\"d3js:d3\");\ninstall(\"standard-minifier-css\");\ninstall(\"standard-minifier-js\");\ninstall(\"limemakers:three\");\ninstall(\"pcel:loading\");\ninstall(\"spectrum:material-design-lite\");\ninstall(\"timmyg:wow\");\ninstall(\"ddp-rate-limiter\");\ninstall(\"localstorage\");\ninstall(\"callback-hook\");\ninstall(\"accounts-base\");\ninstall(\"service-configuration\");\ninstall(\"npm-bcrypt\");\ninstall(\"sha\");\ninstall(\"srp\");\ninstall(\"accounts-password\");\ninstall(\"less\");\ninstall(\"accounts-ui-unstyled\");\ninstall(\"accounts-ui\");\ninstall(\"coffeescript\");\ninstall(\"zimme:active-route\");\ninstall(\"gwendall:auth-client-callbacks\");\ninstall(\"fortawesome:fontawesome\");\ninstall(\"chrismbeckett:toastr\");\ninstall(\"stolinski:stylus-multi\");\ninstall(\"webapp\");\ninstall(\"livedata\");\ninstall(\"hot-code-push\");\ninstall(\"launch-screen\");\ninstall(\"autoupdate\");\n","try {\n  // The application can run `npm install process` to provide its own\n  // process stub; otherwise this module will provide a partial stub.\n  process = global.process || require(\"process\");\n} catch (noProcess) {\n  process = {};\n}\n\nif (Meteor.isServer) {\n  // Make require(\"process\") work on the server in all versions of Node.\n  meteorInstall({\n    node_modules: {\n      \"process.js\": function (r, e, module) {\n        module.exports = process;\n      }\n    }\n  });\n} else {\n  process.platform = \"browser\";\n  process.nextTick = process.nextTick || Meteor._setImmediate;\n}\n\nif (typeof process.env !== \"object\") {\n  process.env = {};\n}\n\n_.extend(process.env, meteorEnv);\n","try {\n  // When meteor-node-stubs is installed in the application's root\n  // node_modules directory, requiring it here installs aliases for stubs\n  // for all Node built-in modules, such as fs, util, and http.\n  require(\"meteor-node-stubs\");\n} catch (noStubs) {}\n","exports.name = \"webcola\";\nexports.version = \"3.1.3\";\nexports.main = \"WebCola/index.js\";\n","var cola;\r\n(function (cola) {\r\n    var packingOptions = {\r\n        PADDING: 10,\r\n        GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,\r\n        FLOAT_EPSILON: 0.0001,\r\n        MAX_INERATIONS: 100\r\n    };\r\n    // assign x, y to nodes while using box packing algorithm for disconnected graphs\r\n    function applyPacking(graphs, w, h, node_size, desired_ratio) {\r\n        if (desired_ratio === void 0) { desired_ratio = 1; }\r\n        var init_x = 0, init_y = 0, svg_width = w, svg_height = h, desired_ratio = typeof desired_ratio !== 'undefined' ? desired_ratio : 1, node_size = typeof node_size !== 'undefined' ? node_size : 0, real_width = 0, real_height = 0, min_width = 0, global_bottom = 0, line = [];\r\n        if (graphs.length == 0)\r\n            return;\r\n        /// that would take care of single nodes problem\r\n        // graphs.forEach(function (g) {\r\n        //     if (g.array.length == 1) {\r\n        //         g.array[0].x = 0;\r\n        //         g.array[0].y = 0;\r\n        //     }\r\n        // });\r\n        calculate_bb(graphs);\r\n        apply(graphs, desired_ratio);\r\n        put_nodes_to_right_positions(graphs);\r\n        // get bounding boxes for all separate graphs\r\n        function calculate_bb(graphs) {\r\n            graphs.forEach(function (g) {\r\n                calculate_single_bb(g);\r\n            });\r\n            function calculate_single_bb(graph) {\r\n                var min_x = Number.MAX_VALUE, min_y = Number.MAX_VALUE, max_x = 0, max_y = 0;\r\n                graph.array.forEach(function (v) {\r\n                    var w = typeof v.width !== 'undefined' ? v.width : node_size;\r\n                    var h = typeof v.height !== 'undefined' ? v.height : node_size;\r\n                    w /= 2;\r\n                    h /= 2;\r\n                    max_x = Math.max(v.x + w, max_x);\r\n                    min_x = Math.min(v.x - w, min_x);\r\n                    max_y = Math.max(v.y + h, max_y);\r\n                    min_y = Math.min(v.y - h, min_y);\r\n                });\r\n                graph.width = max_x - min_x;\r\n                graph.height = max_y - min_y;\r\n            }\r\n        }\r\n        //function plot(data, left, right, opt_x, opt_y) {\r\n        //    // plot the cost function\r\n        //    var plot_svg = d3.select(\"body\").append(\"svg\")\r\n        //        .attr(\"width\", function () { return 2 * (right - left); })\r\n        //        .attr(\"height\", 200);\r\n        //    var x = d3.time.scale().range([0, 2 * (right - left)]);\r\n        //    var xAxis = d3.svg.axis().scale(x).orient(\"bottom\");\r\n        //    plot_svg.append(\"g\").attr(\"class\", \"x axis\")\r\n        //        .attr(\"transform\", \"translate(0, 199)\")\r\n        //        .call(xAxis);\r\n        //    var lastX = 0;\r\n        //    var lastY = 0;\r\n        //    var value = 0;\r\n        //    for (var r = left; r < right; r += 1) {\r\n        //        value = step(data, r);\r\n        //        // value = 1;\r\n        //        plot_svg.append(\"line\").attr(\"x1\", 2 * (lastX - left))\r\n        //            .attr(\"y1\", 200 - 30 * lastY)\r\n        //            .attr(\"x2\", 2 * r - 2 * left)\r\n        //            .attr(\"y2\", 200 - 30 * value)\r\n        //            .style(\"stroke\", \"rgb(6,120,155)\");\r\n        //        lastX = r;\r\n        //        lastY = value;\r\n        //    }\r\n        //    plot_svg.append(\"circle\").attr(\"cx\", 2 * opt_x - 2 * left).attr(\"cy\", 200 - 30 * opt_y)\r\n        //        .attr(\"r\", 5).style('fill', \"rgba(0,0,0,0.5)\");\r\n        //}\r\n        // actual assigning of position to nodes\r\n        function put_nodes_to_right_positions(graphs) {\r\n            graphs.forEach(function (g) {\r\n                // calculate current graph center:\r\n                var center = { x: 0, y: 0 };\r\n                g.array.forEach(function (node) {\r\n                    center.x += node.x;\r\n                    center.y += node.y;\r\n                });\r\n                center.x /= g.array.length;\r\n                center.y /= g.array.length;\r\n                // calculate current top left corner:\r\n                var corner = { x: center.x - g.width / 2, y: center.y - g.height / 2 };\r\n                var offset = { x: g.x - corner.x + svg_width / 2 - real_width / 2, y: g.y - corner.y + svg_height / 2 - real_height / 2 };\r\n                // put nodes:\r\n                g.array.forEach(function (node) {\r\n                    node.x += offset.x;\r\n                    node.y += offset.y;\r\n                });\r\n            });\r\n        }\r\n        // starts box packing algorithm\r\n        // desired ratio is 1 by default\r\n        function apply(data, desired_ratio) {\r\n            var curr_best_f = Number.POSITIVE_INFINITY;\r\n            var curr_best = 0;\r\n            data.sort(function (a, b) { return b.height - a.height; });\r\n            min_width = data.reduce(function (a, b) {\r\n                return a.width < b.width ? a.width : b.width;\r\n            });\r\n            var left = x1 = min_width;\r\n            var right = x2 = get_entire_width(data);\r\n            var iterationCounter = 0;\r\n            var f_x1 = Number.MAX_VALUE;\r\n            var f_x2 = Number.MAX_VALUE;\r\n            var flag = -1; // determines which among f_x1 and f_x2 to recompute\r\n            var dx = Number.MAX_VALUE;\r\n            var df = Number.MAX_VALUE;\r\n            while ((dx > min_width) || df > packingOptions.FLOAT_EPSILON) {\r\n                if (flag != 1) {\r\n                    var x1 = right - (right - left) / packingOptions.GOLDEN_SECTION;\r\n                    var f_x1 = step(data, x1);\r\n                }\r\n                if (flag != 0) {\r\n                    var x2 = left + (right - left) / packingOptions.GOLDEN_SECTION;\r\n                    var f_x2 = step(data, x2);\r\n                }\r\n                dx = Math.abs(x1 - x2);\r\n                df = Math.abs(f_x1 - f_x2);\r\n                if (f_x1 < curr_best_f) {\r\n                    curr_best_f = f_x1;\r\n                    curr_best = x1;\r\n                }\r\n                if (f_x2 < curr_best_f) {\r\n                    curr_best_f = f_x2;\r\n                    curr_best = x2;\r\n                }\r\n                if (f_x1 > f_x2) {\r\n                    left = x1;\r\n                    x1 = x2;\r\n                    f_x1 = f_x2;\r\n                    flag = 1;\r\n                }\r\n                else {\r\n                    right = x2;\r\n                    x2 = x1;\r\n                    f_x2 = f_x1;\r\n                    flag = 0;\r\n                }\r\n                if (iterationCounter++ > 100) {\r\n                    break;\r\n                }\r\n            }\r\n            // plot(data, min_width, get_entire_width(data), curr_best, curr_best_f);\r\n            step(data, curr_best);\r\n        }\r\n        // one iteration of the optimization method\r\n        // (gives a proper, but not necessarily optimal packing)\r\n        function step(data, max_width) {\r\n            line = [];\r\n            real_width = 0;\r\n            real_height = 0;\r\n            global_bottom = init_y;\r\n            for (var i = 0; i < data.length; i++) {\r\n                var o = data[i];\r\n                put_rect(o, max_width);\r\n            }\r\n            return Math.abs(get_real_ratio() - desired_ratio);\r\n        }\r\n        // looking for a position to one box \r\n        function put_rect(rect, max_width) {\r\n            var parent = undefined;\r\n            for (var i = 0; i < line.length; i++) {\r\n                if ((line[i].space_left >= rect.height) && (line[i].x + line[i].width + rect.width + packingOptions.PADDING - max_width) <= packingOptions.FLOAT_EPSILON) {\r\n                    parent = line[i];\r\n                    break;\r\n                }\r\n            }\r\n            line.push(rect);\r\n            if (parent !== undefined) {\r\n                rect.x = parent.x + parent.width + packingOptions.PADDING;\r\n                rect.y = parent.bottom;\r\n                rect.space_left = rect.height;\r\n                rect.bottom = rect.y;\r\n                parent.space_left -= rect.height + packingOptions.PADDING;\r\n                parent.bottom += rect.height + packingOptions.PADDING;\r\n            }\r\n            else {\r\n                rect.y = global_bottom;\r\n                global_bottom += rect.height + packingOptions.PADDING;\r\n                rect.x = init_x;\r\n                rect.bottom = rect.y;\r\n                rect.space_left = rect.height;\r\n            }\r\n            if (rect.y + rect.height - real_height > -packingOptions.FLOAT_EPSILON)\r\n                real_height = rect.y + rect.height - init_y;\r\n            if (rect.x + rect.width - real_width > -packingOptions.FLOAT_EPSILON)\r\n                real_width = rect.x + rect.width - init_x;\r\n        }\r\n        ;\r\n        function get_entire_width(data) {\r\n            var width = 0;\r\n            data.forEach(function (d) { return width += d.width + packingOptions.PADDING; });\r\n            return width;\r\n        }\r\n        function get_real_ratio() {\r\n            return (real_width / real_height);\r\n        }\r\n    }\r\n    cola.applyPacking = applyPacking;\r\n    /**\r\n     * connected components of graph\r\n     * returns an array of {}\r\n     */\r\n    function separateGraphs(nodes, links) {\r\n        var marks = {};\r\n        var ways = {};\r\n        var graphs = [];\r\n        var clusters = 0;\r\n        for (var i = 0; i < links.length; i++) {\r\n            var link = links[i];\r\n            var n1 = link.source;\r\n            var n2 = link.target;\r\n            if (ways[n1.index])\r\n                ways[n1.index].push(n2);\r\n            else\r\n                ways[n1.index] = [n2];\r\n            if (ways[n2.index])\r\n                ways[n2.index].push(n1);\r\n            else\r\n                ways[n2.index] = [n1];\r\n        }\r\n        for (var i = 0; i < nodes.length; i++) {\r\n            var node = nodes[i];\r\n            if (marks[node.index])\r\n                continue;\r\n            explore_node(node, true);\r\n        }\r\n        function explore_node(n, is_new) {\r\n            if (marks[n.index] !== undefined)\r\n                return;\r\n            if (is_new) {\r\n                clusters++;\r\n                graphs.push({ array: [] });\r\n            }\r\n            marks[n.index] = clusters;\r\n            graphs[clusters - 1].array.push(n);\r\n            var adjacent = ways[n.index];\r\n            if (!adjacent)\r\n                return;\r\n            for (var j = 0; j < adjacent.length; j++) {\r\n                explore_node(adjacent[j], false);\r\n            }\r\n        }\r\n        return graphs;\r\n    }\r\n    cola.separateGraphs = separateGraphs;\r\n})(cola || (cola = {}));\r\nvar cola;\r\n(function (cola) {\r\n    var vpsc;\r\n    (function (vpsc) {\r\n        var PositionStats = (function () {\r\n            function PositionStats(scale) {\r\n                this.scale = scale;\r\n                this.AB = 0;\r\n                this.AD = 0;\r\n                this.A2 = 0;\r\n            }\r\n            PositionStats.prototype.addVariable = function (v) {\r\n                var ai = this.scale / v.scale;\r\n                var bi = v.offset / v.scale;\r\n                var wi = v.weight;\r\n                this.AB += wi * ai * bi;\r\n                this.AD += wi * ai * v.desiredPosition;\r\n                this.A2 += wi * ai * ai;\r\n            };\r\n            PositionStats.prototype.getPosn = function () {\r\n                return (this.AD - this.AB) / this.A2;\r\n            };\r\n            return PositionStats;\r\n        })();\r\n        vpsc.PositionStats = PositionStats;\r\n        var Constraint = (function () {\r\n            function Constraint(left, right, gap, equality) {\r\n                if (equality === void 0) { equality = false; }\r\n                this.left = left;\r\n                this.right = right;\r\n                this.gap = gap;\r\n                this.equality = equality;\r\n                this.active = false;\r\n                this.unsatisfiable = false;\r\n                this.left = left;\r\n                this.right = right;\r\n                this.gap = gap;\r\n                this.equality = equality;\r\n            }\r\n            Constraint.prototype.slack = function () {\r\n                return this.unsatisfiable ? Number.MAX_VALUE\r\n                    : this.right.scale * this.right.position() - this.gap\r\n                        - this.left.scale * this.left.position();\r\n            };\r\n            return Constraint;\r\n        })();\r\n        vpsc.Constraint = Constraint;\r\n        var Variable = (function () {\r\n            function Variable(desiredPosition, weight, scale) {\r\n                if (weight === void 0) { weight = 1; }\r\n                if (scale === void 0) { scale = 1; }\r\n                this.desiredPosition = desiredPosition;\r\n                this.weight = weight;\r\n                this.scale = scale;\r\n                this.offset = 0;\r\n            }\r\n            Variable.prototype.dfdv = function () {\r\n                return 2.0 * this.weight * (this.position() - this.desiredPosition);\r\n            };\r\n            Variable.prototype.position = function () {\r\n                return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;\r\n            };\r\n            // visit neighbours by active constraints within the same block\r\n            Variable.prototype.visitNeighbours = function (prev, f) {\r\n                var ff = function (c, next) { return c.active && prev !== next && f(c, next); };\r\n                this.cOut.forEach(function (c) { return ff(c, c.right); });\r\n                this.cIn.forEach(function (c) { return ff(c, c.left); });\r\n            };\r\n            return Variable;\r\n        })();\r\n        vpsc.Variable = Variable;\r\n        var Block = (function () {\r\n            function Block(v) {\r\n                this.vars = [];\r\n                v.offset = 0;\r\n                this.ps = new PositionStats(v.scale);\r\n                this.addVariable(v);\r\n            }\r\n            Block.prototype.addVariable = function (v) {\r\n                v.block = this;\r\n                this.vars.push(v);\r\n                this.ps.addVariable(v);\r\n                this.posn = this.ps.getPosn();\r\n            };\r\n            // move the block where it needs to be to minimize cost\r\n            Block.prototype.updateWeightedPosition = function () {\r\n                this.ps.AB = this.ps.AD = this.ps.A2 = 0;\r\n                for (var i = 0, n = this.vars.length; i < n; ++i)\r\n                    this.ps.addVariable(this.vars[i]);\r\n                this.posn = this.ps.getPosn();\r\n            };\r\n            Block.prototype.compute_lm = function (v, u, postAction) {\r\n                var _this = this;\r\n                var dfdv = v.dfdv();\r\n                v.visitNeighbours(u, function (c, next) {\r\n                    var _dfdv = _this.compute_lm(next, v, postAction);\r\n                    if (next === c.right) {\r\n                        dfdv += _dfdv * c.left.scale;\r\n                        c.lm = _dfdv;\r\n                    }\r\n                    else {\r\n                        dfdv += _dfdv * c.right.scale;\r\n                        c.lm = -_dfdv;\r\n                    }\r\n                    postAction(c);\r\n                });\r\n                return dfdv / v.scale;\r\n            };\r\n            Block.prototype.populateSplitBlock = function (v, prev) {\r\n                var _this = this;\r\n                v.visitNeighbours(prev, function (c, next) {\r\n                    next.offset = v.offset + (next === c.right ? c.gap : -c.gap);\r\n                    _this.addVariable(next);\r\n                    _this.populateSplitBlock(next, v);\r\n                });\r\n            };\r\n            // traverse the active constraint tree applying visit to each active constraint\r\n            Block.prototype.traverse = function (visit, acc, v, prev) {\r\n                var _this = this;\r\n                if (v === void 0) { v = this.vars[0]; }\r\n                if (prev === void 0) { prev = null; }\r\n                v.visitNeighbours(prev, function (c, next) {\r\n                    acc.push(visit(c));\r\n                    _this.traverse(visit, acc, next, v);\r\n                });\r\n            };\r\n            // calculate lagrangian multipliers on constraints and\r\n            // find the active constraint in this block with the smallest lagrangian.\r\n            // if the lagrangian is negative, then the constraint is a split candidate.  \r\n            Block.prototype.findMinLM = function () {\r\n                var m = null;\r\n                this.compute_lm(this.vars[0], null, function (c) {\r\n                    if (!c.equality && (m === null || c.lm < m.lm))\r\n                        m = c;\r\n                });\r\n                return m;\r\n            };\r\n            Block.prototype.findMinLMBetween = function (lv, rv) {\r\n                this.compute_lm(lv, null, function () { });\r\n                var m = null;\r\n                this.findPath(lv, null, rv, function (c, next) {\r\n                    if (!c.equality && c.right === next && (m === null || c.lm < m.lm))\r\n                        m = c;\r\n                });\r\n                return m;\r\n            };\r\n            Block.prototype.findPath = function (v, prev, to, visit) {\r\n                var _this = this;\r\n                var endFound = false;\r\n                v.visitNeighbours(prev, function (c, next) {\r\n                    if (!endFound && (next === to || _this.findPath(next, v, to, visit))) {\r\n                        endFound = true;\r\n                        visit(c, next);\r\n                    }\r\n                });\r\n                return endFound;\r\n            };\r\n            // Search active constraint tree from u to see if there is a directed path to v.\r\n            // Returns true if path is found.\r\n            Block.prototype.isActiveDirectedPathBetween = function (u, v) {\r\n                if (u === v)\r\n                    return true;\r\n                var i = u.cOut.length;\r\n                while (i--) {\r\n                    var c = u.cOut[i];\r\n                    if (c.active && this.isActiveDirectedPathBetween(c.right, v))\r\n                        return true;\r\n                }\r\n                return false;\r\n            };\r\n            // split the block into two by deactivating the specified constraint\r\n            Block.split = function (c) {\r\n                /* DEBUG\r\n                            console.log(\"split on \" + c);\r\n                            console.assert(c.active, \"attempt to split on inactive constraint\");\r\n                DEBUG */\r\n                c.active = false;\r\n                return [Block.createSplitBlock(c.left), Block.createSplitBlock(c.right)];\r\n            };\r\n            Block.createSplitBlock = function (startVar) {\r\n                var b = new Block(startVar);\r\n                b.populateSplitBlock(startVar, null);\r\n                return b;\r\n            };\r\n            // find a split point somewhere between the specified variables\r\n            Block.prototype.splitBetween = function (vl, vr) {\r\n                /* DEBUG\r\n                            console.assert(vl.block === this);\r\n                            console.assert(vr.block === this);\r\n                DEBUG */\r\n                var c = this.findMinLMBetween(vl, vr);\r\n                if (c !== null) {\r\n                    var bs = Block.split(c);\r\n                    return { constraint: c, lb: bs[0], rb: bs[1] };\r\n                }\r\n                // couldn't find a split point - for example the active path is all equality constraints\r\n                return null;\r\n            };\r\n            Block.prototype.mergeAcross = function (b, c, dist) {\r\n                c.active = true;\r\n                for (var i = 0, n = b.vars.length; i < n; ++i) {\r\n                    var v = b.vars[i];\r\n                    v.offset += dist;\r\n                    this.addVariable(v);\r\n                }\r\n                this.posn = this.ps.getPosn();\r\n            };\r\n            Block.prototype.cost = function () {\r\n                var sum = 0, i = this.vars.length;\r\n                while (i--) {\r\n                    var v = this.vars[i], d = v.position() - v.desiredPosition;\r\n                    sum += d * d * v.weight;\r\n                }\r\n                return sum;\r\n            };\r\n            return Block;\r\n        })();\r\n        vpsc.Block = Block;\r\n        var Blocks = (function () {\r\n            function Blocks(vs) {\r\n                this.vs = vs;\r\n                var n = vs.length;\r\n                this.list = new Array(n);\r\n                while (n--) {\r\n                    var b = new Block(vs[n]);\r\n                    this.list[n] = b;\r\n                    b.blockInd = n;\r\n                }\r\n            }\r\n            Blocks.prototype.cost = function () {\r\n                var sum = 0, i = this.list.length;\r\n                while (i--)\r\n                    sum += this.list[i].cost();\r\n                return sum;\r\n            };\r\n            Blocks.prototype.insert = function (b) {\r\n                /* DEBUG\r\n                            console.assert(!this.contains(b), \"blocks error: tried to reinsert block \" + b.blockInd)\r\n                DEBUG */\r\n                b.blockInd = this.list.length;\r\n                this.list.push(b);\r\n                /* DEBUG\r\n                            console.log(\"insert block: \" + b.blockInd);\r\n                            this.contains(b);\r\n                DEBUG */\r\n            };\r\n            Blocks.prototype.remove = function (b) {\r\n                /* DEBUG\r\n                            console.log(\"remove block: \" + b.blockInd);\r\n                            console.assert(this.contains(b));\r\n                DEBUG */\r\n                var last = this.list.length - 1;\r\n                var swapBlock = this.list[last];\r\n                this.list.length = last;\r\n                if (b !== swapBlock) {\r\n                    this.list[b.blockInd] = swapBlock;\r\n                    swapBlock.blockInd = b.blockInd;\r\n                }\r\n            };\r\n            // merge the blocks on either side of the specified constraint, by copying the smaller block into the larger\r\n            // and deleting the smaller.\r\n            Blocks.prototype.merge = function (c) {\r\n                var l = c.left.block, r = c.right.block;\r\n                /* DEBUG\r\n                            console.assert(l!==r, \"attempt to merge within the same block\");\r\n                DEBUG */\r\n                var dist = c.right.offset - c.left.offset - c.gap;\r\n                if (l.vars.length < r.vars.length) {\r\n                    r.mergeAcross(l, c, dist);\r\n                    this.remove(l);\r\n                }\r\n                else {\r\n                    l.mergeAcross(r, c, -dist);\r\n                    this.remove(r);\r\n                }\r\n                /* DEBUG\r\n                            console.assert(Math.abs(c.slack()) < 1e-6, \"Error: Constraint should be at equality after merge!\");\r\n                            console.log(\"merged on \" + c);\r\n                DEBUG */\r\n            };\r\n            Blocks.prototype.forEach = function (f) {\r\n                this.list.forEach(f);\r\n            };\r\n            // useful, for example, after variable desired positions change.\r\n            Blocks.prototype.updateBlockPositions = function () {\r\n                this.list.forEach(function (b) { return b.updateWeightedPosition(); });\r\n            };\r\n            // split each block across its constraint with the minimum lagrangian \r\n            Blocks.prototype.split = function (inactive) {\r\n                var _this = this;\r\n                this.updateBlockPositions();\r\n                this.list.forEach(function (b) {\r\n                    var v = b.findMinLM();\r\n                    if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {\r\n                        b = v.left.block;\r\n                        Block.split(v).forEach(function (nb) { return _this.insert(nb); });\r\n                        _this.remove(b);\r\n                        inactive.push(v);\r\n                    }\r\n                });\r\n            };\r\n            return Blocks;\r\n        })();\r\n        vpsc.Blocks = Blocks;\r\n        var Solver = (function () {\r\n            function Solver(vs, cs) {\r\n                this.vs = vs;\r\n                this.cs = cs;\r\n                this.vs = vs;\r\n                vs.forEach(function (v) {\r\n                    v.cIn = [], v.cOut = [];\r\n                    /* DEBUG\r\n                                    v.toString = () => \"v\" + vs.indexOf(v);\r\n                    DEBUG */\r\n                });\r\n                this.cs = cs;\r\n                cs.forEach(function (c) {\r\n                    c.left.cOut.push(c);\r\n                    c.right.cIn.push(c);\r\n                    /* DEBUG\r\n                                    c.toString = () => c.left + \"+\" + c.gap + \"<=\" + c.right + \" slack=\" + c.slack() + \" active=\" + c.active;\r\n                    DEBUG */\r\n                });\r\n                this.inactive = cs.map(function (c) { c.active = false; return c; });\r\n                this.bs = null;\r\n            }\r\n            Solver.prototype.cost = function () {\r\n                return this.bs.cost();\r\n            };\r\n            // set starting positions without changing desired positions.\r\n            // Note: it throws away any previous block structure.\r\n            Solver.prototype.setStartingPositions = function (ps) {\r\n                this.inactive = this.cs.map(function (c) { c.active = false; return c; });\r\n                this.bs = new Blocks(this.vs);\r\n                this.bs.forEach(function (b, i) { return b.posn = ps[i]; });\r\n            };\r\n            Solver.prototype.setDesiredPositions = function (ps) {\r\n                this.vs.forEach(function (v, i) { return v.desiredPosition = ps[i]; });\r\n            };\r\n            /* DEBUG\r\n                    private getId(v: Variable): number {\r\n                        return this.vs.indexOf(v);\r\n                    }\r\n            \r\n                    // sanity check of the index integrity of the inactive list\r\n                    checkInactive(): void {\r\n                        var inactiveCount = 0;\r\n                        this.cs.forEach(c=> {\r\n                            var i = this.inactive.indexOf(c);\r\n                            console.assert(!c.active && i >= 0 || c.active && i < 0, \"constraint should be in the inactive list if it is not active: \" + c);\r\n                            if (i >= 0) {\r\n                                inactiveCount++;\r\n                            } else {\r\n                                console.assert(c.active, \"inactive constraint not found in inactive list: \" + c);\r\n                            }\r\n                        });\r\n                        console.assert(inactiveCount === this.inactive.length, inactiveCount + \" inactive constraints found, \" + this.inactive.length + \"in inactive list\");\r\n                    }\r\n                    // after every call to satisfy the following should check should pass\r\n                    checkSatisfied(): void {\r\n                        this.cs.forEach(c=>console.assert(c.slack() >= vpsc.Solver.ZERO_UPPERBOUND, \"Error: Unsatisfied constraint! \"+c));\r\n                    }\r\n            DEBUG */\r\n            Solver.prototype.mostViolated = function () {\r\n                var minSlack = Number.MAX_VALUE, v = null, l = this.inactive, n = l.length, deletePoint = n;\r\n                for (var i = 0; i < n; ++i) {\r\n                    var c = l[i];\r\n                    if (c.unsatisfiable)\r\n                        continue;\r\n                    var slack = c.slack();\r\n                    if (c.equality || slack < minSlack) {\r\n                        minSlack = slack;\r\n                        v = c;\r\n                        deletePoint = i;\r\n                        if (c.equality)\r\n                            break;\r\n                    }\r\n                }\r\n                if (deletePoint !== n &&\r\n                    (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality)) {\r\n                    l[deletePoint] = l[n - 1];\r\n                    l.length = n - 1;\r\n                }\r\n                return v;\r\n            };\r\n            // satisfy constraints by building block structure over violated constraints\r\n            // and moving the blocks to their desired positions\r\n            Solver.prototype.satisfy = function () {\r\n                if (this.bs == null) {\r\n                    this.bs = new Blocks(this.vs);\r\n                }\r\n                /* DEBUG\r\n                            console.log(\"satisfy: \" + this.bs);\r\n                DEBUG */\r\n                this.bs.split(this.inactive);\r\n                var v = null;\r\n                while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {\r\n                    var lb = v.left.block, rb = v.right.block;\r\n                    /* DEBUG\r\n                                    console.log(\"most violated is: \" + v);\r\n                                    this.bs.contains(lb);\r\n                                    this.bs.contains(rb);\r\n                    DEBUG */\r\n                    if (lb !== rb) {\r\n                        this.bs.merge(v);\r\n                    }\r\n                    else {\r\n                        if (lb.isActiveDirectedPathBetween(v.right, v.left)) {\r\n                            // cycle found!\r\n                            v.unsatisfiable = true;\r\n                            continue;\r\n                        }\r\n                        // constraint is within block, need to split first\r\n                        var split = lb.splitBetween(v.left, v.right);\r\n                        if (split !== null) {\r\n                            this.bs.insert(split.lb);\r\n                            this.bs.insert(split.rb);\r\n                            this.bs.remove(lb);\r\n                            this.inactive.push(split.constraint);\r\n                        }\r\n                        else {\r\n                            /* DEBUG\r\n                                                    console.log(\"unsatisfiable constraint found\");\r\n                            DEBUG */\r\n                            v.unsatisfiable = true;\r\n                            continue;\r\n                        }\r\n                        if (v.slack() >= 0) {\r\n                            /* DEBUG\r\n                                                    console.log(\"violated constraint indirectly satisfied: \" + v);\r\n                            DEBUG */\r\n                            // v was satisfied by the above split!\r\n                            this.inactive.push(v);\r\n                        }\r\n                        else {\r\n                            /* DEBUG\r\n                                                    console.log(\"merge after split:\");\r\n                            DEBUG */\r\n                            this.bs.merge(v);\r\n                        }\r\n                    }\r\n                }\r\n                /* DEBUG\r\n                            this.checkSatisfied();\r\n                DEBUG */\r\n            };\r\n            // repeatedly build and split block structure until we converge to an optimal solution\r\n            Solver.prototype.solve = function () {\r\n                this.satisfy();\r\n                var lastcost = Number.MAX_VALUE, cost = this.bs.cost();\r\n                while (Math.abs(lastcost - cost) > 0.0001) {\r\n                    this.satisfy();\r\n                    lastcost = cost;\r\n                    cost = this.bs.cost();\r\n                }\r\n                return cost;\r\n            };\r\n            Solver.LAGRANGIAN_TOLERANCE = -1e-4;\r\n            Solver.ZERO_UPPERBOUND = -1e-10;\r\n            return Solver;\r\n        })();\r\n        vpsc.Solver = Solver;\r\n    })(vpsc = cola.vpsc || (cola.vpsc = {}));\r\n})(cola || (cola = {}));\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar cola;\r\n(function (cola) {\r\n    var vpsc;\r\n    (function (vpsc) {\r\n        //Based on js_es:\r\n        //\r\n        //https://github.com/vadimg/js_bintrees\r\n        //\r\n        //Copyright (C) 2011 by Vadim Graboys\r\n        //\r\n        //Permission is hereby granted, free of charge, to any person obtaining a copy\r\n        //of this software and associated documentation files (the \"Software\"), to deal\r\n        //in the Software without restriction, including without limitation the rights\r\n        //to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n        //copies of the Software, and to permit persons to whom the Software is\r\n        //furnished to do so, subject to the following conditions:\r\n        //\r\n        //The above copyright notice and this permission notice shall be included in\r\n        //all copies or substantial portions of the Software.\r\n        //\r\n        //THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n        //IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n        //FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n        //AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n        //LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n        //OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n        //THE SOFTWARE.\r\n        var TreeBase = (function () {\r\n            function TreeBase() {\r\n                // returns iterator to node if found, null otherwise\r\n                this.findIter = function (data) {\r\n                    var res = this._root;\r\n                    var iter = this.iterator();\r\n                    while (res !== null) {\r\n                        var c = this._comparator(data, res.data);\r\n                        if (c === 0) {\r\n                            iter._cursor = res;\r\n                            return iter;\r\n                        }\r\n                        else {\r\n                            iter._ancestors.push(res);\r\n                            res = res.get_child(c > 0);\r\n                        }\r\n                    }\r\n                    return null;\r\n                };\r\n            }\r\n            // removes all nodes from the tree\r\n            TreeBase.prototype.clear = function () {\r\n                this._root = null;\r\n                this.size = 0;\r\n            };\r\n            ;\r\n            // returns node data if found, null otherwise\r\n            TreeBase.prototype.find = function (data) {\r\n                var res = this._root;\r\n                while (res !== null) {\r\n                    var c = this._comparator(data, res.data);\r\n                    if (c === 0) {\r\n                        return res.data;\r\n                    }\r\n                    else {\r\n                        res = res.get_child(c > 0);\r\n                    }\r\n                }\r\n                return null;\r\n            };\r\n            ;\r\n            // Returns an interator to the tree node immediately before (or at) the element\r\n            TreeBase.prototype.lowerBound = function (data) {\r\n                return this._bound(data, this._comparator);\r\n            };\r\n            ;\r\n            // Returns an interator to the tree node immediately after (or at) the element\r\n            TreeBase.prototype.upperBound = function (data) {\r\n                var cmp = this._comparator;\r\n                function reverse_cmp(a, b) {\r\n                    return cmp(b, a);\r\n                }\r\n                return this._bound(data, reverse_cmp);\r\n            };\r\n            ;\r\n            // returns null if tree is empty\r\n            TreeBase.prototype.min = function () {\r\n                var res = this._root;\r\n                if (res === null) {\r\n                    return null;\r\n                }\r\n                while (res.left !== null) {\r\n                    res = res.left;\r\n                }\r\n                return res.data;\r\n            };\r\n            ;\r\n            // returns null if tree is empty\r\n            TreeBase.prototype.max = function () {\r\n                var res = this._root;\r\n                if (res === null) {\r\n                    return null;\r\n                }\r\n                while (res.right !== null) {\r\n                    res = res.right;\r\n                }\r\n                return res.data;\r\n            };\r\n            ;\r\n            // returns a null iterator\r\n            // call next() or prev() to point to an element\r\n            TreeBase.prototype.iterator = function () {\r\n                return new Iterator(this);\r\n            };\r\n            ;\r\n            // calls cb on each node's data, in order\r\n            TreeBase.prototype.each = function (cb) {\r\n                var it = this.iterator(), data;\r\n                while ((data = it.next()) !== null) {\r\n                    cb(data);\r\n                }\r\n            };\r\n            ;\r\n            // calls cb on each node's data, in reverse order\r\n            TreeBase.prototype.reach = function (cb) {\r\n                var it = this.iterator(), data;\r\n                while ((data = it.prev()) !== null) {\r\n                    cb(data);\r\n                }\r\n            };\r\n            ;\r\n            // used for lowerBound and upperBound\r\n            TreeBase.prototype._bound = function (data, cmp) {\r\n                var cur = this._root;\r\n                var iter = this.iterator();\r\n                while (cur !== null) {\r\n                    var c = this._comparator(data, cur.data);\r\n                    if (c === 0) {\r\n                        iter._cursor = cur;\r\n                        return iter;\r\n                    }\r\n                    iter._ancestors.push(cur);\r\n                    cur = cur.get_child(c > 0);\r\n                }\r\n                for (var i = iter._ancestors.length - 1; i >= 0; --i) {\r\n                    cur = iter._ancestors[i];\r\n                    if (cmp(data, cur.data) > 0) {\r\n                        iter._cursor = cur;\r\n                        iter._ancestors.length = i;\r\n                        return iter;\r\n                    }\r\n                }\r\n                iter._ancestors.length = 0;\r\n                return iter;\r\n            };\r\n            ;\r\n            return TreeBase;\r\n        })();\r\n        vpsc.TreeBase = TreeBase;\r\n        var Iterator = (function () {\r\n            function Iterator(tree) {\r\n                this._tree = tree;\r\n                this._ancestors = [];\r\n                this._cursor = null;\r\n            }\r\n            Iterator.prototype.data = function () {\r\n                return this._cursor !== null ? this._cursor.data : null;\r\n            };\r\n            ;\r\n            // if null-iterator, returns first node\r\n            // otherwise, returns next node\r\n            Iterator.prototype.next = function () {\r\n                if (this._cursor === null) {\r\n                    var root = this._tree._root;\r\n                    if (root !== null) {\r\n                        this._minNode(root);\r\n                    }\r\n                }\r\n                else {\r\n                    if (this._cursor.right === null) {\r\n                        // no greater node in subtree, go up to parent\r\n                        // if coming from a right child, continue up the stack\r\n                        var save;\r\n                        do {\r\n                            save = this._cursor;\r\n                            if (this._ancestors.length) {\r\n                                this._cursor = this._ancestors.pop();\r\n                            }\r\n                            else {\r\n                                this._cursor = null;\r\n                                break;\r\n                            }\r\n                        } while (this._cursor.right === save);\r\n                    }\r\n                    else {\r\n                        // get the next node from the subtree\r\n                        this._ancestors.push(this._cursor);\r\n                        this._minNode(this._cursor.right);\r\n                    }\r\n                }\r\n                return this._cursor !== null ? this._cursor.data : null;\r\n            };\r\n            ;\r\n            // if null-iterator, returns last node\r\n            // otherwise, returns previous node\r\n            Iterator.prototype.prev = function () {\r\n                if (this._cursor === null) {\r\n                    var root = this._tree._root;\r\n                    if (root !== null) {\r\n                        this._maxNode(root);\r\n                    }\r\n                }\r\n                else {\r\n                    if (this._cursor.left === null) {\r\n                        var save;\r\n                        do {\r\n                            save = this._cursor;\r\n                            if (this._ancestors.length) {\r\n                                this._cursor = this._ancestors.pop();\r\n                            }\r\n                            else {\r\n                                this._cursor = null;\r\n                                break;\r\n                            }\r\n                        } while (this._cursor.left === save);\r\n                    }\r\n                    else {\r\n                        this._ancestors.push(this._cursor);\r\n                        this._maxNode(this._cursor.left);\r\n                    }\r\n                }\r\n                return this._cursor !== null ? this._cursor.data : null;\r\n            };\r\n            ;\r\n            Iterator.prototype._minNode = function (start) {\r\n                while (start.left !== null) {\r\n                    this._ancestors.push(start);\r\n                    start = start.left;\r\n                }\r\n                this._cursor = start;\r\n            };\r\n            ;\r\n            Iterator.prototype._maxNode = function (start) {\r\n                while (start.right !== null) {\r\n                    this._ancestors.push(start);\r\n                    start = start.right;\r\n                }\r\n                this._cursor = start;\r\n            };\r\n            ;\r\n            return Iterator;\r\n        })();\r\n        vpsc.Iterator = Iterator;\r\n        var Node = (function () {\r\n            function Node(data) {\r\n                this.data = data;\r\n                this.left = null;\r\n                this.right = null;\r\n                this.red = true;\r\n            }\r\n            Node.prototype.get_child = function (dir) {\r\n                return dir ? this.right : this.left;\r\n            };\r\n            ;\r\n            Node.prototype.set_child = function (dir, val) {\r\n                if (dir) {\r\n                    this.right = val;\r\n                }\r\n                else {\r\n                    this.left = val;\r\n                }\r\n            };\r\n            ;\r\n            return Node;\r\n        })();\r\n        var RBTree = (function (_super) {\r\n            __extends(RBTree, _super);\r\n            function RBTree(comparator) {\r\n                _super.call(this);\r\n                this._root = null;\r\n                this._comparator = comparator;\r\n                this.size = 0;\r\n            }\r\n            // returns true if inserted, false if duplicate\r\n            RBTree.prototype.insert = function (data) {\r\n                var ret = false;\r\n                if (this._root === null) {\r\n                    // empty tree\r\n                    this._root = new Node(data);\r\n                    ret = true;\r\n                    this.size++;\r\n                }\r\n                else {\r\n                    var head = new Node(undefined); // fake tree root\r\n                    var dir = false;\r\n                    var last = false;\r\n                    // setup\r\n                    var gp = null; // grandparent\r\n                    var ggp = head; // grand-grand-parent\r\n                    var p = null; // parent\r\n                    var node = this._root;\r\n                    ggp.right = this._root;\r\n                    // search down\r\n                    while (true) {\r\n                        if (node === null) {\r\n                            // insert new node at the bottom\r\n                            node = new Node(data);\r\n                            p.set_child(dir, node);\r\n                            ret = true;\r\n                            this.size++;\r\n                        }\r\n                        else if (RBTree.is_red(node.left) && RBTree.is_red(node.right)) {\r\n                            // color flip\r\n                            node.red = true;\r\n                            node.left.red = false;\r\n                            node.right.red = false;\r\n                        }\r\n                        // fix red violation\r\n                        if (RBTree.is_red(node) && RBTree.is_red(p)) {\r\n                            var dir2 = ggp.right === gp;\r\n                            if (node === p.get_child(last)) {\r\n                                ggp.set_child(dir2, RBTree.single_rotate(gp, !last));\r\n                            }\r\n                            else {\r\n                                ggp.set_child(dir2, RBTree.double_rotate(gp, !last));\r\n                            }\r\n                        }\r\n                        var cmp = this._comparator(node.data, data);\r\n                        // stop if found\r\n                        if (cmp === 0) {\r\n                            break;\r\n                        }\r\n                        last = dir;\r\n                        dir = cmp < 0;\r\n                        // update helpers\r\n                        if (gp !== null) {\r\n                            ggp = gp;\r\n                        }\r\n                        gp = p;\r\n                        p = node;\r\n                        node = node.get_child(dir);\r\n                    }\r\n                    // update root\r\n                    this._root = head.right;\r\n                }\r\n                // make root black\r\n                this._root.red = false;\r\n                return ret;\r\n            };\r\n            ;\r\n            // returns true if removed, false if not found\r\n            RBTree.prototype.remove = function (data) {\r\n                if (this._root === null) {\r\n                    return false;\r\n                }\r\n                var head = new Node(undefined); // fake tree root\r\n                var node = head;\r\n                node.right = this._root;\r\n                var p = null; // parent\r\n                var gp = null; // grand parent\r\n                var found = null; // found item\r\n                var dir = true;\r\n                while (node.get_child(dir) !== null) {\r\n                    var last = dir;\r\n                    // update helpers\r\n                    gp = p;\r\n                    p = node;\r\n                    node = node.get_child(dir);\r\n                    var cmp = this._comparator(data, node.data);\r\n                    dir = cmp > 0;\r\n                    // save found node\r\n                    if (cmp === 0) {\r\n                        found = node;\r\n                    }\r\n                    // push the red node down\r\n                    if (!RBTree.is_red(node) && !RBTree.is_red(node.get_child(dir))) {\r\n                        if (RBTree.is_red(node.get_child(!dir))) {\r\n                            var sr = RBTree.single_rotate(node, dir);\r\n                            p.set_child(last, sr);\r\n                            p = sr;\r\n                        }\r\n                        else if (!RBTree.is_red(node.get_child(!dir))) {\r\n                            var sibling = p.get_child(!last);\r\n                            if (sibling !== null) {\r\n                                if (!RBTree.is_red(sibling.get_child(!last)) && !RBTree.is_red(sibling.get_child(last))) {\r\n                                    // color flip\r\n                                    p.red = false;\r\n                                    sibling.red = true;\r\n                                    node.red = true;\r\n                                }\r\n                                else {\r\n                                    var dir2 = gp.right === p;\r\n                                    if (RBTree.is_red(sibling.get_child(last))) {\r\n                                        gp.set_child(dir2, RBTree.double_rotate(p, last));\r\n                                    }\r\n                                    else if (RBTree.is_red(sibling.get_child(!last))) {\r\n                                        gp.set_child(dir2, RBTree.single_rotate(p, last));\r\n                                    }\r\n                                    // ensure correct coloring\r\n                                    var gpc = gp.get_child(dir2);\r\n                                    gpc.red = true;\r\n                                    node.red = true;\r\n                                    gpc.left.red = false;\r\n                                    gpc.right.red = false;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // replace and remove if found\r\n                if (found !== null) {\r\n                    found.data = node.data;\r\n                    p.set_child(p.right === node, node.get_child(node.left === null));\r\n                    this.size--;\r\n                }\r\n                // update root and make it black\r\n                this._root = head.right;\r\n                if (this._root !== null) {\r\n                    this._root.red = false;\r\n                }\r\n                return found !== null;\r\n            };\r\n            ;\r\n            RBTree.is_red = function (node) {\r\n                return node !== null && node.red;\r\n            };\r\n            RBTree.single_rotate = function (root, dir) {\r\n                var save = root.get_child(!dir);\r\n                root.set_child(!dir, save.get_child(dir));\r\n                save.set_child(dir, root);\r\n                root.red = true;\r\n                save.red = false;\r\n                return save;\r\n            };\r\n            RBTree.double_rotate = function (root, dir) {\r\n                root.set_child(!dir, RBTree.single_rotate(root.get_child(!dir), !dir));\r\n                return RBTree.single_rotate(root, dir);\r\n            };\r\n            return RBTree;\r\n        })(TreeBase);\r\n        vpsc.RBTree = RBTree;\r\n    })(vpsc = cola.vpsc || (cola.vpsc = {}));\r\n})(cola || (cola = {}));\r\n///<reference path=\"vpsc.ts\"/>\r\n///<reference path=\"rbtree.ts\"/>\r\nvar cola;\r\n(function (cola) {\r\n    var vpsc;\r\n    (function (vpsc) {\r\n        function computeGroupBounds(g) {\r\n            g.bounds = typeof g.leaves !== \"undefined\" ?\r\n                g.leaves.reduce(function (r, c) { return c.bounds.union(r); }, Rectangle.empty()) :\r\n                Rectangle.empty();\r\n            if (typeof g.groups !== \"undefined\")\r\n                g.bounds = g.groups.reduce(function (r, c) { return computeGroupBounds(c).union(r); }, g.bounds);\r\n            g.bounds = g.bounds.inflate(g.padding);\r\n            return g.bounds;\r\n        }\r\n        vpsc.computeGroupBounds = computeGroupBounds;\r\n        var Rectangle = (function () {\r\n            function Rectangle(x, X, y, Y) {\r\n                this.x = x;\r\n                this.X = X;\r\n                this.y = y;\r\n                this.Y = Y;\r\n            }\r\n            Rectangle.empty = function () { return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY); };\r\n            Rectangle.prototype.cx = function () { return (this.x + this.X) / 2; };\r\n            Rectangle.prototype.cy = function () { return (this.y + this.Y) / 2; };\r\n            Rectangle.prototype.overlapX = function (r) {\r\n                var ux = this.cx(), vx = r.cx();\r\n                if (ux <= vx && r.x < this.X)\r\n                    return this.X - r.x;\r\n                if (vx <= ux && this.x < r.X)\r\n                    return r.X - this.x;\r\n                return 0;\r\n            };\r\n            Rectangle.prototype.overlapY = function (r) {\r\n                var uy = this.cy(), vy = r.cy();\r\n                if (uy <= vy && r.y < this.Y)\r\n                    return this.Y - r.y;\r\n                if (vy <= uy && this.y < r.Y)\r\n                    return r.Y - this.y;\r\n                return 0;\r\n            };\r\n            Rectangle.prototype.setXCentre = function (cx) {\r\n                var dx = cx - this.cx();\r\n                this.x += dx;\r\n                this.X += dx;\r\n            };\r\n            Rectangle.prototype.setYCentre = function (cy) {\r\n                var dy = cy - this.cy();\r\n                this.y += dy;\r\n                this.Y += dy;\r\n            };\r\n            Rectangle.prototype.width = function () {\r\n                return this.X - this.x;\r\n            };\r\n            Rectangle.prototype.height = function () {\r\n                return this.Y - this.y;\r\n            };\r\n            Rectangle.prototype.union = function (r) {\r\n                return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));\r\n            };\r\n            /**\r\n             * return any intersection points between the given line and the sides of this rectangle\r\n             * @method lineIntersection\r\n             * @param x1 number first x coord of line\r\n             * @param y1 number first y coord of line\r\n             * @param x2 number second x coord of line\r\n             * @param y2 number second y coord of line\r\n             * @return any intersection points found\r\n             */\r\n            Rectangle.prototype.lineIntersections = function (x1, y1, x2, y2) {\r\n                var sides = [[this.x, this.y, this.X, this.y],\r\n                    [this.X, this.y, this.X, this.Y],\r\n                    [this.X, this.Y, this.x, this.Y],\r\n                    [this.x, this.Y, this.x, this.y]];\r\n                var intersections = [];\r\n                for (var i = 0; i < 4; ++i) {\r\n                    var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);\r\n                    if (r !== null)\r\n                        intersections.push({ x: r.x, y: r.y });\r\n                }\r\n                return intersections;\r\n            };\r\n            /**\r\n             * return any intersection points between a line extending from the centre of this rectangle to the given point,\r\n             *  and the sides of this rectangle\r\n             * @method lineIntersection\r\n             * @param x2 number second x coord of line\r\n             * @param y2 number second y coord of line\r\n             * @return any intersection points found\r\n             */\r\n            Rectangle.prototype.rayIntersection = function (x2, y2) {\r\n                var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);\r\n                return ints.length > 0 ? ints[0] : null;\r\n            };\r\n            Rectangle.prototype.vertices = function () {\r\n                return [\r\n                    { x: this.x, y: this.y },\r\n                    { x: this.X, y: this.y },\r\n                    { x: this.X, y: this.Y },\r\n                    { x: this.x, y: this.Y },\r\n                    { x: this.x, y: this.y }];\r\n            };\r\n            Rectangle.lineIntersection = function (x1, y1, x2, y2, x3, y3, x4, y4) {\r\n                var dx12 = x2 - x1, dx34 = x4 - x3, dy12 = y2 - y1, dy34 = y4 - y3, denominator = dy34 * dx12 - dx34 * dy12;\r\n                if (denominator == 0)\r\n                    return null;\r\n                var dx31 = x1 - x3, dy31 = y1 - y3, numa = dx34 * dy31 - dy34 * dx31, a = numa / denominator, numb = dx12 * dy31 - dy12 * dx31, b = numb / denominator;\r\n                if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {\r\n                    return {\r\n                        x: x1 + a * dx12,\r\n                        y: y1 + a * dy12\r\n                    };\r\n                }\r\n                return null;\r\n            };\r\n            Rectangle.prototype.inflate = function (pad) {\r\n                return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);\r\n            };\r\n            return Rectangle;\r\n        })();\r\n        vpsc.Rectangle = Rectangle;\r\n        function makeEdgeBetween(source, target, ah) {\r\n            var si = source.rayIntersection(target.cx(), target.cy()) || { x: source.cx(), y: source.cy() }, ti = target.rayIntersection(source.cx(), source.cy()) || { x: target.cx(), y: target.cy() }, dx = ti.x - si.x, dy = ti.y - si.y, l = Math.sqrt(dx * dx + dy * dy), al = l - ah;\r\n            return {\r\n                sourceIntersection: si,\r\n                targetIntersection: ti,\r\n                arrowStart: { x: si.x + al * dx / l, y: si.y + al * dy / l }\r\n            };\r\n        }\r\n        vpsc.makeEdgeBetween = makeEdgeBetween;\r\n        function makeEdgeTo(s, target, ah) {\r\n            var ti = target.rayIntersection(s.x, s.y);\r\n            if (!ti)\r\n                ti = { x: target.cx(), y: target.cy() };\r\n            var dx = ti.x - s.x, dy = ti.y - s.y, l = Math.sqrt(dx * dx + dy * dy);\r\n            return { x: ti.x - ah * dx / l, y: ti.y - ah * dy / l };\r\n        }\r\n        vpsc.makeEdgeTo = makeEdgeTo;\r\n        var Node = (function () {\r\n            function Node(v, r, pos) {\r\n                this.v = v;\r\n                this.r = r;\r\n                this.pos = pos;\r\n                this.prev = makeRBTree();\r\n                this.next = makeRBTree();\r\n            }\r\n            return Node;\r\n        })();\r\n        var Event = (function () {\r\n            function Event(isOpen, v, pos) {\r\n                this.isOpen = isOpen;\r\n                this.v = v;\r\n                this.pos = pos;\r\n            }\r\n            return Event;\r\n        })();\r\n        function compareEvents(a, b) {\r\n            if (a.pos > b.pos) {\r\n                return 1;\r\n            }\r\n            if (a.pos < b.pos) {\r\n                return -1;\r\n            }\r\n            if (a.isOpen) {\r\n                // open must come before close\r\n                return -1;\r\n            }\r\n            if (b.isOpen) {\r\n                // open must come before close\r\n                return 1;\r\n            }\r\n            return 0;\r\n        }\r\n        function makeRBTree() {\r\n            return new vpsc.RBTree(function (a, b) { return a.pos - b.pos; });\r\n        }\r\n        var xRect = {\r\n            getCentre: function (r) { return r.cx(); },\r\n            getOpen: function (r) { return r.y; },\r\n            getClose: function (r) { return r.Y; },\r\n            getSize: function (r) { return r.width(); },\r\n            makeRect: function (open, close, center, size) { return new Rectangle(center - size / 2, center + size / 2, open, close); },\r\n            findNeighbours: findXNeighbours\r\n        };\r\n        var yRect = {\r\n            getCentre: function (r) { return r.cy(); },\r\n            getOpen: function (r) { return r.x; },\r\n            getClose: function (r) { return r.X; },\r\n            getSize: function (r) { return r.height(); },\r\n            makeRect: function (open, close, center, size) { return new Rectangle(open, close, center - size / 2, center + size / 2); },\r\n            findNeighbours: findYNeighbours\r\n        };\r\n        function generateGroupConstraints(root, f, minSep, isContained) {\r\n            if (isContained === void 0) { isContained = false; }\r\n            var padding = root.padding, gn = typeof root.groups !== 'undefined' ? root.groups.length : 0, ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0, childConstraints = !gn ? []\r\n                : root.groups.reduce(function (ccs, g) { return ccs.concat(generateGroupConstraints(g, f, minSep, true)); }, []), n = (isContained ? 2 : 0) + ln + gn, vs = new Array(n), rs = new Array(n), i = 0, add = function (r, v) { rs[i] = r; vs[i++] = v; };\r\n            if (isContained) {\r\n                // if this group is contained by another, then we add two dummy vars and rectangles for the borders\r\n                var b = root.bounds, c = f.getCentre(b), s = f.getSize(b) / 2, open = f.getOpen(b), close = f.getClose(b), min = c - s + padding / 2, max = c + s - padding / 2;\r\n                root.minVar.desiredPosition = min;\r\n                add(f.makeRect(open, close, min, padding), root.minVar);\r\n                root.maxVar.desiredPosition = max;\r\n                add(f.makeRect(open, close, max, padding), root.maxVar);\r\n            }\r\n            if (ln)\r\n                root.leaves.forEach(function (l) { return add(l.bounds, l.variable); });\r\n            if (gn)\r\n                root.groups.forEach(function (g) {\r\n                    var b = g.bounds;\r\n                    add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);\r\n                });\r\n            var cs = generateConstraints(rs, vs, f, minSep);\r\n            if (gn) {\r\n                vs.forEach(function (v) { v.cOut = [], v.cIn = []; });\r\n                cs.forEach(function (c) { c.left.cOut.push(c), c.right.cIn.push(c); });\r\n                root.groups.forEach(function (g) {\r\n                    var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;\r\n                    g.minVar.cIn.forEach(function (c) { return c.gap += gapAdjustment; });\r\n                    g.minVar.cOut.forEach(function (c) { c.left = g.maxVar; c.gap += gapAdjustment; });\r\n                });\r\n            }\r\n            return childConstraints.concat(cs);\r\n        }\r\n        function generateConstraints(rs, vars, rect, minSep) {\r\n            var i, n = rs.length;\r\n            var N = 2 * n;\r\n            console.assert(vars.length >= n);\r\n            var events = new Array(N);\r\n            for (i = 0; i < n; ++i) {\r\n                var r = rs[i];\r\n                var v = new Node(vars[i], r, rect.getCentre(r));\r\n                events[i] = new Event(true, v, rect.getOpen(r));\r\n                events[i + n] = new Event(false, v, rect.getClose(r));\r\n            }\r\n            events.sort(compareEvents);\r\n            var cs = new Array();\r\n            var scanline = makeRBTree();\r\n            for (i = 0; i < N; ++i) {\r\n                var e = events[i];\r\n                var v = e.v;\r\n                if (e.isOpen) {\r\n                    scanline.insert(v);\r\n                    rect.findNeighbours(v, scanline);\r\n                }\r\n                else {\r\n                    // close event\r\n                    scanline.remove(v);\r\n                    var makeConstraint = function (l, r) {\r\n                        var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;\r\n                        cs.push(new vpsc.Constraint(l.v, r.v, sep));\r\n                    };\r\n                    var visitNeighbours = function (forward, reverse, mkcon) {\r\n                        var u, it = v[forward].iterator();\r\n                        while ((u = it[forward]()) !== null) {\r\n                            mkcon(u, v);\r\n                            u[reverse].remove(v);\r\n                        }\r\n                    };\r\n                    visitNeighbours(\"prev\", \"next\", function (u, v) { return makeConstraint(u, v); });\r\n                    visitNeighbours(\"next\", \"prev\", function (u, v) { return makeConstraint(v, u); });\r\n                }\r\n            }\r\n            console.assert(scanline.size === 0);\r\n            return cs;\r\n        }\r\n        function findXNeighbours(v, scanline) {\r\n            var f = function (forward, reverse) {\r\n                var it = scanline.findIter(v);\r\n                var u;\r\n                while ((u = it[forward]()) !== null) {\r\n                    var uovervX = u.r.overlapX(v.r);\r\n                    if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {\r\n                        v[forward].insert(u);\r\n                        u[reverse].insert(v);\r\n                    }\r\n                    if (uovervX <= 0) {\r\n                        break;\r\n                    }\r\n                }\r\n            };\r\n            f(\"next\", \"prev\");\r\n            f(\"prev\", \"next\");\r\n        }\r\n        function findYNeighbours(v, scanline) {\r\n            var f = function (forward, reverse) {\r\n                var u = scanline.findIter(v)[forward]();\r\n                if (u !== null && u.r.overlapX(v.r) > 0) {\r\n                    v[forward].insert(u);\r\n                    u[reverse].insert(v);\r\n                }\r\n            };\r\n            f(\"next\", \"prev\");\r\n            f(\"prev\", \"next\");\r\n        }\r\n        function generateXConstraints(rs, vars) {\r\n            return generateConstraints(rs, vars, xRect, 1e-6);\r\n        }\r\n        vpsc.generateXConstraints = generateXConstraints;\r\n        function generateYConstraints(rs, vars) {\r\n            return generateConstraints(rs, vars, yRect, 1e-6);\r\n        }\r\n        vpsc.generateYConstraints = generateYConstraints;\r\n        function generateXGroupConstraints(root) {\r\n            return generateGroupConstraints(root, xRect, 1e-6);\r\n        }\r\n        vpsc.generateXGroupConstraints = generateXGroupConstraints;\r\n        function generateYGroupConstraints(root) {\r\n            return generateGroupConstraints(root, yRect, 1e-6);\r\n        }\r\n        vpsc.generateYGroupConstraints = generateYGroupConstraints;\r\n        function removeOverlaps(rs) {\r\n            var vs = rs.map(function (r) { return new vpsc.Variable(r.cx()); });\r\n            var cs = vpsc.generateXConstraints(rs, vs);\r\n            var solver = new vpsc.Solver(vs, cs);\r\n            solver.solve();\r\n            vs.forEach(function (v, i) { return rs[i].setXCentre(v.position()); });\r\n            vs = rs.map(function (r) { return new vpsc.Variable(r.cy()); });\r\n            cs = vpsc.generateYConstraints(rs, vs);\r\n            solver = new vpsc.Solver(vs, cs);\r\n            solver.solve();\r\n            vs.forEach(function (v, i) { return rs[i].setYCentre(v.position()); });\r\n        }\r\n        vpsc.removeOverlaps = removeOverlaps;\r\n        var IndexedVariable = (function (_super) {\r\n            __extends(IndexedVariable, _super);\r\n            function IndexedVariable(index, w) {\r\n                _super.call(this, 0, w);\r\n                this.index = index;\r\n            }\r\n            return IndexedVariable;\r\n        })(vpsc.Variable);\r\n        vpsc.IndexedVariable = IndexedVariable;\r\n        var Projection = (function () {\r\n            function Projection(nodes, groups, rootGroup, constraints, avoidOverlaps) {\r\n                var _this = this;\r\n                if (rootGroup === void 0) { rootGroup = null; }\r\n                if (constraints === void 0) { constraints = null; }\r\n                if (avoidOverlaps === void 0) { avoidOverlaps = false; }\r\n                this.nodes = nodes;\r\n                this.groups = groups;\r\n                this.rootGroup = rootGroup;\r\n                this.avoidOverlaps = avoidOverlaps;\r\n                this.variables = nodes.map(function (v, i) {\r\n                    return v.variable = new IndexedVariable(i, 1);\r\n                });\r\n                if (constraints)\r\n                    this.createConstraints(constraints);\r\n                if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {\r\n                    nodes.forEach(function (v) {\r\n                        if (!v.width || !v.height) {\r\n                            //If undefined, default to nothing\r\n                            v.bounds = new vpsc.Rectangle(v.x, v.x, v.y, v.y);\r\n                            return;\r\n                        }\r\n                        var w2 = v.width / 2, h2 = v.height / 2;\r\n                        v.bounds = new vpsc.Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);\r\n                    });\r\n                    computeGroupBounds(rootGroup);\r\n                    var i = nodes.length;\r\n                    groups.forEach(function (g) {\r\n                        _this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\r\n                        _this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\r\n                    });\r\n                }\r\n            }\r\n            Projection.prototype.createSeparation = function (c) {\r\n                return new vpsc.Constraint(this.nodes[c.left].variable, this.nodes[c.right].variable, c.gap, typeof c.equality !== \"undefined\" ? c.equality : false);\r\n            };\r\n            Projection.prototype.makeFeasible = function (c) {\r\n                var _this = this;\r\n                if (!this.avoidOverlaps)\r\n                    return;\r\n                var axis = 'x', dim = 'width';\r\n                if (c.axis === 'x')\r\n                    axis = 'y', dim = 'height';\r\n                var vs = c.offsets.map(function (o) { return _this.nodes[o.node]; }).sort(function (a, b) { return a[axis] - b[axis]; });\r\n                var p = null;\r\n                vs.forEach(function (v) {\r\n                    if (p)\r\n                        v[axis] = p[axis] + p[dim] + 1;\r\n                    p = v;\r\n                });\r\n            };\r\n            Projection.prototype.createAlignment = function (c) {\r\n                var _this = this;\r\n                var u = this.nodes[c.offsets[0].node].variable;\r\n                this.makeFeasible(c);\r\n                var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;\r\n                c.offsets.slice(1).forEach(function (o) {\r\n                    var v = _this.nodes[o.node].variable;\r\n                    cs.push(new vpsc.Constraint(u, v, o.offset, true));\r\n                });\r\n            };\r\n            Projection.prototype.createConstraints = function (constraints) {\r\n                var _this = this;\r\n                var isSep = function (c) { return typeof c.type === 'undefined' || c.type === 'separation'; };\r\n                this.xConstraints = constraints\r\n                    .filter(function (c) { return c.axis === \"x\" && isSep(c); })\r\n                    .map(function (c) { return _this.createSeparation(c); });\r\n                this.yConstraints = constraints\r\n                    .filter(function (c) { return c.axis === \"y\" && isSep(c); })\r\n                    .map(function (c) { return _this.createSeparation(c); });\r\n                constraints\r\n                    .filter(function (c) { return c.type === 'alignment'; })\r\n                    .forEach(function (c) { return _this.createAlignment(c); });\r\n            };\r\n            Projection.prototype.setupVariablesAndBounds = function (x0, y0, desired, getDesired) {\r\n                this.nodes.forEach(function (v, i) {\r\n                    if (v.fixed) {\r\n                        v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;\r\n                        desired[i] = getDesired(v);\r\n                    }\r\n                    else {\r\n                        v.variable.weight = 1;\r\n                    }\r\n                    var w = (v.width || 0) / 2, h = (v.height || 0) / 2;\r\n                    var ix = x0[i], iy = y0[i];\r\n                    v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);\r\n                });\r\n            };\r\n            Projection.prototype.xProject = function (x0, y0, x) {\r\n                if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints))\r\n                    return;\r\n                this.project(x0, y0, x0, x, function (v) { return v.px; }, this.xConstraints, generateXGroupConstraints, function (v) { return v.bounds.setXCentre(x[v.variable.index] = v.variable.position()); }, function (g) {\r\n                    var xmin = x[g.minVar.index] = g.minVar.position();\r\n                    var xmax = x[g.maxVar.index] = g.maxVar.position();\r\n                    var p2 = g.padding / 2;\r\n                    g.bounds.x = xmin - p2;\r\n                    g.bounds.X = xmax + p2;\r\n                });\r\n            };\r\n            Projection.prototype.yProject = function (x0, y0, y) {\r\n                if (!this.rootGroup && !this.yConstraints)\r\n                    return;\r\n                this.project(x0, y0, y0, y, function (v) { return v.py; }, this.yConstraints, generateYGroupConstraints, function (v) { return v.bounds.setYCentre(y[v.variable.index] = v.variable.position()); }, function (g) {\r\n                    var ymin = y[g.minVar.index] = g.minVar.position();\r\n                    var ymax = y[g.maxVar.index] = g.maxVar.position();\r\n                    var p2 = g.padding / 2;\r\n                    g.bounds.y = ymin - p2;\r\n                    ;\r\n                    g.bounds.Y = ymax + p2;\r\n                });\r\n            };\r\n            Projection.prototype.projectFunctions = function () {\r\n                var _this = this;\r\n                return [\r\n                    function (x0, y0, x) { return _this.xProject(x0, y0, x); },\r\n                    function (x0, y0, y) { return _this.yProject(x0, y0, y); }\r\n                ];\r\n            };\r\n            Projection.prototype.project = function (x0, y0, start, desired, getDesired, cs, generateConstraints, updateNodeBounds, updateGroupBounds) {\r\n                this.setupVariablesAndBounds(x0, y0, desired, getDesired);\r\n                if (this.rootGroup && this.avoidOverlaps) {\r\n                    computeGroupBounds(this.rootGroup);\r\n                    cs = cs.concat(generateConstraints(this.rootGroup));\r\n                }\r\n                this.solve(this.variables, cs, start, desired);\r\n                this.nodes.forEach(updateNodeBounds);\r\n                if (this.rootGroup && this.avoidOverlaps) {\r\n                    this.groups.forEach(updateGroupBounds);\r\n                    computeGroupBounds(this.rootGroup);\r\n                }\r\n            };\r\n            Projection.prototype.solve = function (vs, cs, starting, desired) {\r\n                var solver = new vpsc.Solver(vs, cs);\r\n                solver.setStartingPositions(starting);\r\n                solver.setDesiredPositions(desired);\r\n                solver.solve();\r\n            };\r\n            return Projection;\r\n        })();\r\n        vpsc.Projection = Projection;\r\n    })(vpsc = cola.vpsc || (cola.vpsc = {}));\r\n})(cola || (cola = {}));\r\n///<reference path=\"vpsc.ts\"/>\r\n///<reference path=\"rectangle.ts\"/>\r\nvar cola;\r\n(function (cola) {\r\n    var geom;\r\n    (function (geom) {\r\n        var Point = (function () {\r\n            function Point() {\r\n            }\r\n            return Point;\r\n        })();\r\n        geom.Point = Point;\r\n        var LineSegment = (function () {\r\n            function LineSegment(x1, y1, x2, y2) {\r\n                this.x1 = x1;\r\n                this.y1 = y1;\r\n                this.x2 = x2;\r\n                this.y2 = y2;\r\n            }\r\n            return LineSegment;\r\n        })();\r\n        geom.LineSegment = LineSegment;\r\n        var PolyPoint = (function (_super) {\r\n            __extends(PolyPoint, _super);\r\n            function PolyPoint() {\r\n                _super.apply(this, arguments);\r\n            }\r\n            return PolyPoint;\r\n        })(Point);\r\n        geom.PolyPoint = PolyPoint;\r\n        /** tests if a point is Left|On|Right of an infinite line.\r\n         * @param points P0, P1, and P2\r\n         * @return >0 for P2 left of the line through P0 and P1\r\n         *            =0 for P2 on the line\r\n         *            <0 for P2 right of the line\r\n         */\r\n        function isLeft(P0, P1, P2) {\r\n            return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);\r\n        }\r\n        geom.isLeft = isLeft;\r\n        function above(p, vi, vj) {\r\n            return isLeft(p, vi, vj) > 0;\r\n        }\r\n        function below(p, vi, vj) {\r\n            return isLeft(p, vi, vj) < 0;\r\n        }\r\n        /**\r\n         * returns the convex hull of a set of points using Andrew's monotone chain algorithm\r\n         * see: http://geomalgorithms.com/a10-_hull-1.html#Monotone%20Chain\r\n         * @param S array of points\r\n         * @return the convex hull as an array of points\r\n         */\r\n        function ConvexHull(S) {\r\n            var P = S.slice(0).sort(function (a, b) { return a.x !== b.x ? b.x - a.x : b.y - a.y; });\r\n            var n = S.length, i;\r\n            var minmin = 0;\r\n            var xmin = P[0].x;\r\n            for (i = 1; i < n; ++i) {\r\n                if (P[i].x !== xmin)\r\n                    break;\r\n            }\r\n            var minmax = i - 1;\r\n            var H = [];\r\n            H.push(P[minmin]); // push minmin point onto stack\r\n            if (minmax === n - 1) {\r\n                if (P[minmax].y !== P[minmin].y)\r\n                    H.push(P[minmax]);\r\n            }\r\n            else {\r\n                // Get the indices of points with max x-coord and min|max y-coord\r\n                var maxmin, maxmax = n - 1;\r\n                var xmax = P[n - 1].x;\r\n                for (i = n - 2; i >= 0; i--)\r\n                    if (P[i].x !== xmax)\r\n                        break;\r\n                maxmin = i + 1;\r\n                // Compute the lower hull on the stack H\r\n                i = minmax;\r\n                while (++i <= maxmin) {\r\n                    // the lower line joins P[minmin]  with P[maxmin]\r\n                    if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin)\r\n                        continue; // ignore P[i] above or on the lower line\r\n                    while (H.length > 1) {\r\n                        // test if  P[i] is left of the line at the stack top\r\n                        if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\r\n                            break; // P[i] is a new hull  vertex\r\n                        else\r\n                            H.length -= 1; // pop top point off  stack\r\n                    }\r\n                    if (i != minmin)\r\n                        H.push(P[i]);\r\n                }\r\n                // Next, compute the upper hull on the stack H above the bottom hull\r\n                if (maxmax != maxmin)\r\n                    H.push(P[maxmax]); // push maxmax point onto stack\r\n                var bot = H.length; // the bottom point of the upper hull stack\r\n                i = maxmin;\r\n                while (--i >= minmax) {\r\n                    // the upper line joins P[maxmax]  with P[minmax]\r\n                    if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax)\r\n                        continue; // ignore P[i] below or on the upper line\r\n                    while (H.length > bot) {\r\n                        // test if  P[i] is left of the line at the stack top\r\n                        if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\r\n                            break; // P[i] is a new hull  vertex\r\n                        else\r\n                            H.length -= 1; // pop top point off  stack\r\n                    }\r\n                    if (i != minmin)\r\n                        H.push(P[i]); // push P[i] onto stack\r\n                }\r\n            }\r\n            return H;\r\n        }\r\n        geom.ConvexHull = ConvexHull;\r\n        // apply f to the points in P in clockwise order around the point p\r\n        function clockwiseRadialSweep(p, P, f) {\r\n            P.slice(0).sort(function (a, b) { return Math.atan2(a.y - p.y, a.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x); }).forEach(f);\r\n        }\r\n        geom.clockwiseRadialSweep = clockwiseRadialSweep;\r\n        function nextPolyPoint(p, ps) {\r\n            if (p.polyIndex === ps.length - 1)\r\n                return ps[0];\r\n            return ps[p.polyIndex + 1];\r\n        }\r\n        function prevPolyPoint(p, ps) {\r\n            if (p.polyIndex === 0)\r\n                return ps[ps.length - 1];\r\n            return ps[p.polyIndex - 1];\r\n        }\r\n        // tangent_PointPolyC(): fast binary search for tangents to a convex polygon\r\n        //    Input:  P = a 2D point (exterior to the polygon)\r\n        //            n = number of polygon vertices\r\n        //            V = array of vertices for a 2D convex polygon with V[n] = V[0]\r\n        //    Output: rtan = index of rightmost tangent point V[rtan]\r\n        //            ltan = index of leftmost tangent point V[ltan]\r\n        function tangent_PointPolyC(P, V) {\r\n            return { rtan: Rtangent_PointPolyC(P, V), ltan: Ltangent_PointPolyC(P, V) };\r\n        }\r\n        // Rtangent_PointPolyC(): binary search for convex polygon right tangent\r\n        //    Input:  P = a 2D point (exterior to the polygon)\r\n        //            n = number of polygon vertices\r\n        //            V = array of vertices for a 2D convex polygon with V[n] = V[0]\r\n        //    Return: index \"i\" of rightmost tangent point V[i]\r\n        function Rtangent_PointPolyC(P, V) {\r\n            var n = V.length - 1;\r\n            // use binary search for large convex polygons\r\n            var a, b, c; // indices for edge chain endpoints\r\n            var upA, dnC; // test for up direction of edges a and c\r\n            // rightmost tangent = maximum for the isLeft() ordering\r\n            // test if V[0] is a local maximum\r\n            if (below(P, V[1], V[0]) && !above(P, V[n - 1], V[0]))\r\n                return 0; // V[0] is the maximum tangent point\r\n            for (a = 0, b = n;;) {\r\n                if (b - a === 1)\r\n                    if (above(P, V[a], V[b]))\r\n                        return a;\r\n                    else\r\n                        return b;\r\n                c = Math.floor((a + b) / 2); // midpoint of [a,b], and 0<c<n\r\n                dnC = below(P, V[c + 1], V[c]);\r\n                if (dnC && !above(P, V[c - 1], V[c]))\r\n                    return c; // V[c] is the maximum tangent point\r\n                // no max yet, so continue with the binary search\r\n                // pick one of the two subchains [a,c] or [c,b]\r\n                upA = above(P, V[a + 1], V[a]);\r\n                if (upA) {\r\n                    if (dnC)\r\n                        b = c; // select [a,c]\r\n                    else {\r\n                        if (above(P, V[a], V[c]))\r\n                            b = c; // select [a,c]\r\n                        else\r\n                            a = c; // select [c,b]\r\n                    }\r\n                }\r\n                else {\r\n                    if (!dnC)\r\n                        a = c; // select [c,b]\r\n                    else {\r\n                        if (below(P, V[a], V[c]))\r\n                            b = c; // select [a,c]\r\n                        else\r\n                            a = c; // select [c,b]\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Ltangent_PointPolyC(): binary search for convex polygon left tangent\r\n        //    Input:  P = a 2D point (exterior to the polygon)\r\n        //            n = number of polygon vertices\r\n        //            V = array of vertices for a 2D convex polygon with V[n]=V[0]\r\n        //    Return: index \"i\" of leftmost tangent point V[i]\r\n        function Ltangent_PointPolyC(P, V) {\r\n            var n = V.length - 1;\r\n            // use binary search for large convex polygons\r\n            var a, b, c; // indices for edge chain endpoints\r\n            var dnA, dnC; // test for down direction of edges a and c\r\n            // leftmost tangent = minimum for the isLeft() ordering\r\n            // test if V[0] is a local minimum\r\n            if (above(P, V[n - 1], V[0]) && !below(P, V[1], V[0]))\r\n                return 0; // V[0] is the minimum tangent point\r\n            for (a = 0, b = n;;) {\r\n                if (b - a === 1)\r\n                    if (below(P, V[a], V[b]))\r\n                        return a;\r\n                    else\r\n                        return b;\r\n                c = Math.floor((a + b) / 2); // midpoint of [a,b], and 0<c<n\r\n                dnC = below(P, V[c + 1], V[c]);\r\n                if (above(P, V[c - 1], V[c]) && !dnC)\r\n                    return c; // V[c] is the minimum tangent point\r\n                // no min yet, so continue with the binary search\r\n                // pick one of the two subchains [a,c] or [c,b]\r\n                dnA = below(P, V[a + 1], V[a]);\r\n                if (dnA) {\r\n                    if (!dnC)\r\n                        b = c; // select [a,c]\r\n                    else {\r\n                        if (below(P, V[a], V[c]))\r\n                            b = c; // select [a,c]\r\n                        else\r\n                            a = c; // select [c,b]\r\n                    }\r\n                }\r\n                else {\r\n                    if (dnC)\r\n                        a = c; // select [c,b]\r\n                    else {\r\n                        if (above(P, V[a], V[c]))\r\n                            b = c; // select [a,c]\r\n                        else\r\n                            a = c; // select [c,b]\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // RLtangent_PolyPolyC(): get the RL tangent between two convex polygons\r\n        //    Input:  m = number of vertices in polygon 1\r\n        //            V = array of vertices for convex polygon 1 with V[m]=V[0]\r\n        //            n = number of vertices in polygon 2\r\n        //            W = array of vertices for convex polygon 2 with W[n]=W[0]\r\n        //    Output: *t1 = index of tangent point V[t1] for polygon 1\r\n        //            *t2 = index of tangent point W[t2] for polygon 2\r\n        function tangent_PolyPolyC(V, W, t1, t2, cmp1, cmp2) {\r\n            var ix1, ix2; // search indices for polygons 1 and 2\r\n            // first get the initial vertex on each polygon\r\n            ix1 = t1(W[0], V); // right tangent from W[0] to V\r\n            ix2 = t2(V[ix1], W); // left tangent from V[ix1] to W\r\n            // ping-pong linear search until it stabilizes\r\n            var done = false; // flag when done\r\n            while (!done) {\r\n                done = true; // assume done until...\r\n                while (true) {\r\n                    if (ix1 === V.length - 1)\r\n                        ix1 = 0;\r\n                    if (cmp1(W[ix2], V[ix1], V[ix1 + 1]))\r\n                        break;\r\n                    ++ix1; // get Rtangent from W[ix2] to V\r\n                }\r\n                while (true) {\r\n                    if (ix2 === 0)\r\n                        ix2 = W.length - 1;\r\n                    if (cmp2(V[ix1], W[ix2], W[ix2 - 1]))\r\n                        break;\r\n                    --ix2; // get Ltangent from V[ix1] to W\r\n                    done = false; // not done if had to adjust this\r\n                }\r\n            }\r\n            return { t1: ix1, t2: ix2 };\r\n        }\r\n        geom.tangent_PolyPolyC = tangent_PolyPolyC;\r\n        function LRtangent_PolyPolyC(V, W) {\r\n            var rl = RLtangent_PolyPolyC(W, V);\r\n            return { t1: rl.t2, t2: rl.t1 };\r\n        }\r\n        geom.LRtangent_PolyPolyC = LRtangent_PolyPolyC;\r\n        function RLtangent_PolyPolyC(V, W) {\r\n            return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above, below);\r\n        }\r\n        geom.RLtangent_PolyPolyC = RLtangent_PolyPolyC;\r\n        function LLtangent_PolyPolyC(V, W) {\r\n            return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);\r\n        }\r\n        geom.LLtangent_PolyPolyC = LLtangent_PolyPolyC;\r\n        function RRtangent_PolyPolyC(V, W) {\r\n            return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above, above);\r\n        }\r\n        geom.RRtangent_PolyPolyC = RRtangent_PolyPolyC;\r\n        var BiTangent = (function () {\r\n            function BiTangent(t1, t2) {\r\n                this.t1 = t1;\r\n                this.t2 = t2;\r\n            }\r\n            return BiTangent;\r\n        })();\r\n        geom.BiTangent = BiTangent;\r\n        var BiTangents = (function () {\r\n            function BiTangents() {\r\n            }\r\n            return BiTangents;\r\n        })();\r\n        geom.BiTangents = BiTangents;\r\n        var TVGPoint = (function (_super) {\r\n            __extends(TVGPoint, _super);\r\n            function TVGPoint() {\r\n                _super.apply(this, arguments);\r\n            }\r\n            return TVGPoint;\r\n        })(Point);\r\n        geom.TVGPoint = TVGPoint;\r\n        var VisibilityVertex = (function () {\r\n            function VisibilityVertex(id, polyid, polyvertid, p) {\r\n                this.id = id;\r\n                this.polyid = polyid;\r\n                this.polyvertid = polyvertid;\r\n                this.p = p;\r\n                p.vv = this;\r\n            }\r\n            return VisibilityVertex;\r\n        })();\r\n        geom.VisibilityVertex = VisibilityVertex;\r\n        var VisibilityEdge = (function () {\r\n            function VisibilityEdge(source, target) {\r\n                this.source = source;\r\n                this.target = target;\r\n            }\r\n            VisibilityEdge.prototype.length = function () {\r\n                var dx = this.source.p.x - this.target.p.x;\r\n                var dy = this.source.p.y - this.target.p.y;\r\n                return Math.sqrt(dx * dx + dy * dy);\r\n            };\r\n            return VisibilityEdge;\r\n        })();\r\n        geom.VisibilityEdge = VisibilityEdge;\r\n        var TangentVisibilityGraph = (function () {\r\n            function TangentVisibilityGraph(P, g0) {\r\n                this.P = P;\r\n                this.V = [];\r\n                this.E = [];\r\n                if (!g0) {\r\n                    var n = P.length;\r\n                    for (var i = 0; i < n; i++) {\r\n                        var p = P[i];\r\n                        for (var j = 0; j < p.length; ++j) {\r\n                            var pj = p[j], vv = new VisibilityVertex(this.V.length, i, j, pj);\r\n                            this.V.push(vv);\r\n                            if (j > 0)\r\n                                this.E.push(new VisibilityEdge(p[j - 1].vv, vv));\r\n                        }\r\n                    }\r\n                    for (var i = 0; i < n - 1; i++) {\r\n                        var Pi = P[i];\r\n                        for (var j = i + 1; j < n; j++) {\r\n                            var Pj = P[j], t = geom.tangents(Pi, Pj);\r\n                            for (var q in t) {\r\n                                var c = t[q], source = Pi[c.t1], target = Pj[c.t2];\r\n                                this.addEdgeIfVisible(source, target, i, j);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    this.V = g0.V.slice(0);\r\n                    this.E = g0.E.slice(0);\r\n                }\r\n            }\r\n            TangentVisibilityGraph.prototype.addEdgeIfVisible = function (u, v, i1, i2) {\r\n                if (!this.intersectsPolys(new LineSegment(u.x, u.y, v.x, v.y), i1, i2)) {\r\n                    this.E.push(new VisibilityEdge(u.vv, v.vv));\r\n                }\r\n            };\r\n            TangentVisibilityGraph.prototype.addPoint = function (p, i1) {\r\n                var n = this.P.length;\r\n                this.V.push(new VisibilityVertex(this.V.length, n, 0, p));\r\n                for (var i = 0; i < n; ++i) {\r\n                    if (i === i1)\r\n                        continue;\r\n                    var poly = this.P[i], t = tangent_PointPolyC(p, poly);\r\n                    this.addEdgeIfVisible(p, poly[t.ltan], i1, i);\r\n                    this.addEdgeIfVisible(p, poly[t.rtan], i1, i);\r\n                }\r\n                return p.vv;\r\n            };\r\n            TangentVisibilityGraph.prototype.intersectsPolys = function (l, i1, i2) {\r\n                for (var i = 0, n = this.P.length; i < n; ++i) {\r\n                    if (i != i1 && i != i2 && intersects(l, this.P[i]).length > 0) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            };\r\n            return TangentVisibilityGraph;\r\n        })();\r\n        geom.TangentVisibilityGraph = TangentVisibilityGraph;\r\n        function intersects(l, P) {\r\n            var ints = [];\r\n            for (var i = 1, n = P.length; i < n; ++i) {\r\n                var int = cola.vpsc.Rectangle.lineIntersection(l.x1, l.y1, l.x2, l.y2, P[i - 1].x, P[i - 1].y, P[i].x, P[i].y);\r\n                if (int)\r\n                    ints.push(int);\r\n            }\r\n            return ints;\r\n        }\r\n        function tangents(V, W) {\r\n            var m = V.length - 1, n = W.length - 1;\r\n            var bt = new BiTangents();\r\n            for (var i = 0; i < m; ++i) {\r\n                for (var j = 0; j < n; ++j) {\r\n                    var v1 = V[i == 0 ? m - 1 : i - 1];\r\n                    var v2 = V[i];\r\n                    var v3 = V[i + 1];\r\n                    var w1 = W[j == 0 ? n - 1 : j - 1];\r\n                    var w2 = W[j];\r\n                    var w3 = W[j + 1];\r\n                    var v1v2w2 = isLeft(v1, v2, w2);\r\n                    var v2w1w2 = isLeft(v2, w1, w2);\r\n                    var v2w2w3 = isLeft(v2, w2, w3);\r\n                    var w1w2v2 = isLeft(w1, w2, v2);\r\n                    var w2v1v2 = isLeft(w2, v1, v2);\r\n                    var w2v2v3 = isLeft(w2, v2, v3);\r\n                    if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0\r\n                        && w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {\r\n                        bt.ll = new BiTangent(i, j);\r\n                    }\r\n                    else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0\r\n                        && w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {\r\n                        bt.rr = new BiTangent(i, j);\r\n                    }\r\n                    else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0\r\n                        && w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {\r\n                        bt.rl = new BiTangent(i, j);\r\n                    }\r\n                    else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0\r\n                        && w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {\r\n                        bt.lr = new BiTangent(i, j);\r\n                    }\r\n                }\r\n            }\r\n            return bt;\r\n        }\r\n        geom.tangents = tangents;\r\n        function isPointInsidePoly(p, poly) {\r\n            for (var i = 1, n = poly.length; i < n; ++i)\r\n                if (below(poly[i - 1], poly[i], p))\r\n                    return false;\r\n            return true;\r\n        }\r\n        function isAnyPInQ(p, q) {\r\n            return !p.every(function (v) { return !isPointInsidePoly(v, q); });\r\n        }\r\n        function polysOverlap(p, q) {\r\n            if (isAnyPInQ(p, q))\r\n                return true;\r\n            if (isAnyPInQ(q, p))\r\n                return true;\r\n            for (var i = 1, n = p.length; i < n; ++i) {\r\n                var v = p[i], u = p[i - 1];\r\n                if (intersects(new LineSegment(u.x, u.y, v.x, v.y), q).length > 0)\r\n                    return true;\r\n            }\r\n            return false;\r\n        }\r\n        geom.polysOverlap = polysOverlap;\r\n    })(geom = cola.geom || (cola.geom = {}));\r\n})(cola || (cola = {}));\r\n/**\r\n * @module cola\r\n */\r\nvar cola;\r\n(function (cola) {\r\n    /**\r\n     * Descent respects a collection of locks over nodes that should not move\r\n     * @class Locks\r\n     */\r\n    var Locks = (function () {\r\n        function Locks() {\r\n            this.locks = {};\r\n        }\r\n        /**\r\n         * add a lock on the node at index id\r\n         * @method add\r\n         * @param id index of node to be locked\r\n         * @param x required position for node\r\n         */\r\n        Locks.prototype.add = function (id, x) {\r\n            /* DEBUG\r\n                        if (isNaN(x[0]) || isNaN(x[1])) debugger;\r\n            DEBUG */\r\n            this.locks[id] = x;\r\n        };\r\n        /**\r\n         * @method clear clear all locks\r\n         */\r\n        Locks.prototype.clear = function () {\r\n            this.locks = {};\r\n        };\r\n        /**\r\n         * @isEmpty\r\n         * @returns false if no locks exist\r\n         */\r\n        Locks.prototype.isEmpty = function () {\r\n            for (var l in this.locks)\r\n                return false;\r\n            return true;\r\n        };\r\n        /**\r\n         * perform an operation on each lock\r\n         * @apply\r\n         */\r\n        Locks.prototype.apply = function (f) {\r\n            for (var l in this.locks) {\r\n                f(l, this.locks[l]);\r\n            }\r\n        };\r\n        return Locks;\r\n    })();\r\n    cola.Locks = Locks;\r\n    /**\r\n     * Uses a gradient descent approach to reduce a stress or p-stress goal function over a graph with specified ideal edge lengths or a square matrix of dissimilarities.\r\n     * The standard stress function over a graph nodes with position vectors x,y,z is (mathematica input):\r\n     *   stress[x_,y_,z_,D_,w_]:=Sum[w[[i,j]] (length[x[[i]],y[[i]],z[[i]],x[[j]],y[[j]],z[[j]]]-d[[i,j]])^2,{i,Length[x]-1},{j,i+1,Length[x]}]\r\n     * where: D is a square matrix of ideal separations between nodes, w is matrix of weights for those separations\r\n     *        length[x1_, y1_, z1_, x2_, y2_, z2_] = Sqrt[(x1 - x2)^2 + (y1 - y2)^2 + (z1 - z2)^2]\r\n     * below, we use wij = 1/(Dij^2)\r\n     *\r\n     * @class Descent\r\n     */\r\n    var Descent = (function () {\r\n        /**\r\n         * @method constructor\r\n         * @param x {number[][]} initial coordinates for nodes\r\n         * @param D {number[][]} matrix of desired distances between pairs of nodes\r\n         * @param G {number[][]} [default=null] if specified, G is a matrix of weights for goal terms between pairs of nodes.\r\n         * If G[i][j] > 1 and the separation between nodes i and j is greater than their ideal distance, then there is no contribution for this pair to the goal\r\n         * If G[i][j] <= 1 then it is used as a weighting on the contribution of the variance between ideal and actual separation between i and j to the goal function\r\n         */\r\n        function Descent(x, D, G) {\r\n            if (G === void 0) { G = null; }\r\n            this.D = D;\r\n            this.G = G;\r\n            this.threshold = 0.0001;\r\n            // Parameters for grid snap stress.\r\n            // TODO: Make a pluggable \"StressTerm\" class instead of this\r\n            // mess.\r\n            this.numGridSnapNodes = 0;\r\n            this.snapGridSize = 100;\r\n            this.snapStrength = 1000;\r\n            this.scaleSnapByMaxH = false;\r\n            this.random = new PseudoRandom();\r\n            this.project = null;\r\n            this.x = x;\r\n            this.k = x.length; // dimensionality\r\n            var n = this.n = x[0].length; // number of nodes\r\n            this.H = new Array(this.k);\r\n            this.g = new Array(this.k);\r\n            this.Hd = new Array(this.k);\r\n            this.a = new Array(this.k);\r\n            this.b = new Array(this.k);\r\n            this.c = new Array(this.k);\r\n            this.d = new Array(this.k);\r\n            this.e = new Array(this.k);\r\n            this.ia = new Array(this.k);\r\n            this.ib = new Array(this.k);\r\n            this.xtmp = new Array(this.k);\r\n            this.locks = new Locks();\r\n            this.minD = Number.MAX_VALUE;\r\n            var i = n, j;\r\n            while (i--) {\r\n                j = n;\r\n                while (--j > i) {\r\n                    var d = D[i][j];\r\n                    if (d > 0 && d < this.minD) {\r\n                        this.minD = d;\r\n                    }\r\n                }\r\n            }\r\n            if (this.minD === Number.MAX_VALUE)\r\n                this.minD = 1;\r\n            i = this.k;\r\n            while (i--) {\r\n                this.g[i] = new Array(n);\r\n                this.H[i] = new Array(n);\r\n                j = n;\r\n                while (j--) {\r\n                    this.H[i][j] = new Array(n);\r\n                }\r\n                this.Hd[i] = new Array(n);\r\n                this.a[i] = new Array(n);\r\n                this.b[i] = new Array(n);\r\n                this.c[i] = new Array(n);\r\n                this.d[i] = new Array(n);\r\n                this.e[i] = new Array(n);\r\n                this.ia[i] = new Array(n);\r\n                this.ib[i] = new Array(n);\r\n                this.xtmp[i] = new Array(n);\r\n            }\r\n        }\r\n        Descent.createSquareMatrix = function (n, f) {\r\n            var M = new Array(n);\r\n            for (var i = 0; i < n; ++i) {\r\n                M[i] = new Array(n);\r\n                for (var j = 0; j < n; ++j) {\r\n                    M[i][j] = f(i, j);\r\n                }\r\n            }\r\n            return M;\r\n        };\r\n        Descent.prototype.offsetDir = function () {\r\n            var _this = this;\r\n            var u = new Array(this.k);\r\n            var l = 0;\r\n            for (var i = 0; i < this.k; ++i) {\r\n                var x = u[i] = this.random.getNextBetween(0.01, 1) - 0.5;\r\n                l += x * x;\r\n            }\r\n            l = Math.sqrt(l);\r\n            return u.map(function (x) { return x *= _this.minD / l; });\r\n        };\r\n        // compute first and second derivative information storing results in this.g and this.H\r\n        Descent.prototype.computeDerivatives = function (x) {\r\n            var _this = this;\r\n            var n = this.n;\r\n            if (n < 1)\r\n                return;\r\n            var i;\r\n            /* DEBUG\r\n                        for (var u: number = 0; u < n; ++u)\r\n                            for (i = 0; i < this.k; ++i)\r\n                                if (isNaN(x[i][u])) debugger;\r\n            DEBUG */\r\n            var d = new Array(this.k);\r\n            var d2 = new Array(this.k);\r\n            var Huu = new Array(this.k);\r\n            var maxH = 0;\r\n            for (var u = 0; u < n; ++u) {\r\n                for (i = 0; i < this.k; ++i)\r\n                    Huu[i] = this.g[i][u] = 0;\r\n                for (var v = 0; v < n; ++v) {\r\n                    if (u === v)\r\n                        continue;\r\n                    // The following loop randomly displaces nodes that are at identical positions\r\n                    var maxDisplaces = n; // avoid infinite loop in the case of numerical issues, such as huge values\r\n                    while (maxDisplaces--) {\r\n                        var sd2 = 0;\r\n                        for (i = 0; i < this.k; ++i) {\r\n                            var dx = d[i] = x[i][u] - x[i][v];\r\n                            sd2 += d2[i] = dx * dx;\r\n                        }\r\n                        if (sd2 > 1e-9)\r\n                            break;\r\n                        var rd = this.offsetDir();\r\n                        for (i = 0; i < this.k; ++i)\r\n                            x[i][v] += rd[i];\r\n                    }\r\n                    var l = Math.sqrt(sd2);\r\n                    var D = this.D[u][v];\r\n                    var weight = this.G != null ? this.G[u][v] : 1;\r\n                    if (weight > 1 && l > D || !isFinite(D)) {\r\n                        for (i = 0; i < this.k; ++i)\r\n                            this.H[i][u][v] = 0;\r\n                        continue;\r\n                    }\r\n                    if (weight > 1) {\r\n                        weight = 1;\r\n                    }\r\n                    var D2 = D * D;\r\n                    var gs = 2 * weight * (l - D) / (D2 * l);\r\n                    var l3 = l * l * l;\r\n                    var hs = 2 * -weight / (D2 * l3);\r\n                    if (!isFinite(gs))\r\n                        console.log(gs);\r\n                    for (i = 0; i < this.k; ++i) {\r\n                        this.g[i][u] += d[i] * gs;\r\n                        Huu[i] -= this.H[i][u][v] = hs * (l3 + D * (d2[i] - sd2) + l * sd2);\r\n                    }\r\n                }\r\n                for (i = 0; i < this.k; ++i)\r\n                    maxH = Math.max(maxH, this.H[i][u][u] = Huu[i]);\r\n            }\r\n            // Grid snap forces\r\n            var r = this.snapGridSize / 2;\r\n            var g = this.snapGridSize;\r\n            var w = this.snapStrength;\r\n            var k = w / (r * r);\r\n            var numNodes = this.numGridSnapNodes;\r\n            //var numNodes = n;\r\n            for (var u = 0; u < numNodes; ++u) {\r\n                for (i = 0; i < this.k; ++i) {\r\n                    var xiu = this.x[i][u];\r\n                    var m = xiu / g;\r\n                    var f = m % 1;\r\n                    var q = m - f;\r\n                    var a = Math.abs(f);\r\n                    var dx = (a <= 0.5) ? xiu - q * g :\r\n                        (xiu > 0) ? xiu - (q + 1) * g : xiu - (q - 1) * g;\r\n                    if (-r < dx && dx <= r) {\r\n                        if (this.scaleSnapByMaxH) {\r\n                            this.g[i][u] += maxH * k * dx;\r\n                            this.H[i][u][u] += maxH * k;\r\n                        }\r\n                        else {\r\n                            this.g[i][u] += k * dx;\r\n                            this.H[i][u][u] += k;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!this.locks.isEmpty()) {\r\n                this.locks.apply(function (u, p) {\r\n                    for (i = 0; i < _this.k; ++i) {\r\n                        _this.H[i][u][u] += maxH;\r\n                        _this.g[i][u] -= maxH * (p[i] - x[i][u]);\r\n                    }\r\n                });\r\n            }\r\n            /* DEBUG\r\n                        for (var u: number = 0; u < n; ++u)\r\n                            for (i = 0; i < this.k; ++i) {\r\n                                if (isNaN(this.g[i][u])) debugger;\r\n                                for (var v: number = 0; v < n; ++v)\r\n                                    if (isNaN(this.H[i][u][v])) debugger;\r\n                            }\r\n            DEBUG */\r\n        };\r\n        Descent.dotProd = function (a, b) {\r\n            var x = 0, i = a.length;\r\n            while (i--)\r\n                x += a[i] * b[i];\r\n            return x;\r\n        };\r\n        // result r = matrix m * vector v\r\n        Descent.rightMultiply = function (m, v, r) {\r\n            var i = m.length;\r\n            while (i--)\r\n                r[i] = Descent.dotProd(m[i], v);\r\n        };\r\n        // computes the optimal step size to take in direction d using the\r\n        // derivative information in this.g and this.H\r\n        // returns the scalar multiplier to apply to d to get the optimal step\r\n        Descent.prototype.computeStepSize = function (d) {\r\n            var numerator = 0, denominator = 0;\r\n            for (var i = 0; i < this.k; ++i) {\r\n                numerator += Descent.dotProd(this.g[i], d[i]);\r\n                Descent.rightMultiply(this.H[i], d[i], this.Hd[i]);\r\n                denominator += Descent.dotProd(d[i], this.Hd[i]);\r\n            }\r\n            if (denominator === 0 || !isFinite(denominator))\r\n                return 0;\r\n            return 1 * numerator / denominator;\r\n        };\r\n        Descent.prototype.reduceStress = function () {\r\n            this.computeDerivatives(this.x);\r\n            var alpha = this.computeStepSize(this.g);\r\n            for (var i = 0; i < this.k; ++i) {\r\n                this.takeDescentStep(this.x[i], this.g[i], alpha);\r\n            }\r\n            return this.computeStress();\r\n        };\r\n        Descent.copy = function (a, b) {\r\n            var m = a.length, n = b[0].length;\r\n            for (var i = 0; i < m; ++i) {\r\n                for (var j = 0; j < n; ++j) {\r\n                    b[i][j] = a[i][j];\r\n                }\r\n            }\r\n        };\r\n        // takes a step of stepSize * d from x0, and then project against any constraints.\r\n        // result is returned in r.\r\n        // x0: starting positions\r\n        // r: result positions will be returned here\r\n        // d: unconstrained descent vector\r\n        // stepSize: amount to step along d\r\n        Descent.prototype.stepAndProject = function (x0, r, d, stepSize) {\r\n            Descent.copy(x0, r);\r\n            this.takeDescentStep(r[0], d[0], stepSize);\r\n            if (this.project)\r\n                this.project[0](x0[0], x0[1], r[0]);\r\n            this.takeDescentStep(r[1], d[1], stepSize);\r\n            if (this.project)\r\n                this.project[1](r[0], x0[1], r[1]);\r\n            // todo: allow projection against constraints in higher dimensions\r\n            for (var i = 2; i < this.k; i++)\r\n                this.takeDescentStep(r[i], d[i], stepSize);\r\n            // the following makes locks extra sticky... but hides the result of the projection from the consumer\r\n            //if (!this.locks.isEmpty()) {\r\n            //    this.locks.apply((u, p) => {\r\n            //        for (var i = 0; i < this.k; i++) {\r\n            //            r[i][u] = p[i];\r\n            //        }\r\n            //    });\r\n            //}\r\n        };\r\n        Descent.mApply = function (m, n, f) {\r\n            var i = m;\r\n            while (i-- > 0) {\r\n                var j = n;\r\n                while (j-- > 0)\r\n                    f(i, j);\r\n            }\r\n        };\r\n        Descent.prototype.matrixApply = function (f) {\r\n            Descent.mApply(this.k, this.n, f);\r\n        };\r\n        Descent.prototype.computeNextPosition = function (x0, r) {\r\n            var _this = this;\r\n            this.computeDerivatives(x0);\r\n            var alpha = this.computeStepSize(this.g);\r\n            this.stepAndProject(x0, r, this.g, alpha);\r\n            /* DEBUG\r\n                        for (var u: number = 0; u < this.n; ++u)\r\n                            for (var i = 0; i < this.k; ++i)\r\n                                if (isNaN(r[i][u])) debugger;\r\n            DEBUG */\r\n            if (this.project) {\r\n                this.matrixApply(function (i, j) { return _this.e[i][j] = x0[i][j] - r[i][j]; });\r\n                var beta = this.computeStepSize(this.e);\r\n                beta = Math.max(0.2, Math.min(beta, 1));\r\n                this.stepAndProject(x0, r, this.e, beta);\r\n            }\r\n        };\r\n        Descent.prototype.run = function (iterations) {\r\n            var stress = Number.MAX_VALUE, converged = false;\r\n            while (!converged && iterations-- > 0) {\r\n                var s = this.rungeKutta();\r\n                converged = Math.abs(stress / s - 1) < this.threshold;\r\n                stress = s;\r\n            }\r\n            return stress;\r\n        };\r\n        Descent.prototype.rungeKutta = function () {\r\n            var _this = this;\r\n            this.computeNextPosition(this.x, this.a);\r\n            Descent.mid(this.x, this.a, this.ia);\r\n            this.computeNextPosition(this.ia, this.b);\r\n            Descent.mid(this.x, this.b, this.ib);\r\n            this.computeNextPosition(this.ib, this.c);\r\n            this.computeNextPosition(this.c, this.d);\r\n            var disp = 0;\r\n            this.matrixApply(function (i, j) {\r\n                var x = (_this.a[i][j] + 2.0 * _this.b[i][j] + 2.0 * _this.c[i][j] + _this.d[i][j]) / 6.0, d = _this.x[i][j] - x;\r\n                disp += d * d;\r\n                _this.x[i][j] = x;\r\n            });\r\n            return disp;\r\n        };\r\n        Descent.mid = function (a, b, m) {\r\n            Descent.mApply(a.length, a[0].length, function (i, j) {\r\n                return m[i][j] = a[i][j] + (b[i][j] - a[i][j]) / 2.0;\r\n            });\r\n        };\r\n        Descent.prototype.takeDescentStep = function (x, d, stepSize) {\r\n            for (var i = 0; i < this.n; ++i) {\r\n                x[i] = x[i] - stepSize * d[i];\r\n            }\r\n        };\r\n        Descent.prototype.computeStress = function () {\r\n            var stress = 0;\r\n            for (var u = 0, nMinus1 = this.n - 1; u < nMinus1; ++u) {\r\n                for (var v = u + 1, n = this.n; v < n; ++v) {\r\n                    var l = 0;\r\n                    for (var i = 0; i < this.k; ++i) {\r\n                        var dx = this.x[i][u] - this.x[i][v];\r\n                        l += dx * dx;\r\n                    }\r\n                    l = Math.sqrt(l);\r\n                    var d = this.D[u][v];\r\n                    if (!isFinite(d))\r\n                        continue;\r\n                    var rl = d - l;\r\n                    var d2 = d * d;\r\n                    stress += rl * rl / d2;\r\n                }\r\n            }\r\n            return stress;\r\n        };\r\n        Descent.zeroDistance = 1e-10;\r\n        return Descent;\r\n    })();\r\n    cola.Descent = Descent;\r\n    // Linear congruential pseudo random number generator\r\n    var PseudoRandom = (function () {\r\n        function PseudoRandom(seed) {\r\n            if (seed === void 0) { seed = 1; }\r\n            this.seed = seed;\r\n            this.a = 214013;\r\n            this.c = 2531011;\r\n            this.m = 2147483648;\r\n            this.range = 32767;\r\n        }\r\n        // random real between 0 and 1\r\n        PseudoRandom.prototype.getNext = function () {\r\n            this.seed = (this.seed * this.a + this.c) % this.m;\r\n            return (this.seed >> 16) / this.range;\r\n        };\r\n        // random real between min and max\r\n        PseudoRandom.prototype.getNextBetween = function (min, max) {\r\n            return min + this.getNext() * (max - min);\r\n        };\r\n        return PseudoRandom;\r\n    })();\r\n    cola.PseudoRandom = PseudoRandom;\r\n})(cola || (cola = {}));\r\nvar cola;\r\n(function (cola) {\r\n    var powergraph;\r\n    (function (powergraph) {\r\n        var PowerEdge = (function () {\r\n            function PowerEdge(source, target, type) {\r\n                this.source = source;\r\n                this.target = target;\r\n                this.type = type;\r\n            }\r\n            return PowerEdge;\r\n        })();\r\n        powergraph.PowerEdge = PowerEdge;\r\n        var Configuration = (function () {\r\n            function Configuration(n, edges, linkAccessor, rootGroup) {\r\n                var _this = this;\r\n                this.linkAccessor = linkAccessor;\r\n                this.modules = new Array(n);\r\n                this.roots = [];\r\n                if (rootGroup) {\r\n                    this.initModulesFromGroup(rootGroup);\r\n                }\r\n                else {\r\n                    this.roots.push(new ModuleSet());\r\n                    for (var i = 0; i < n; ++i)\r\n                        this.roots[0].add(this.modules[i] = new Module(i));\r\n                }\r\n                this.R = edges.length;\r\n                edges.forEach(function (e) {\r\n                    var s = _this.modules[linkAccessor.getSourceIndex(e)], t = _this.modules[linkAccessor.getTargetIndex(e)], type = linkAccessor.getType(e);\r\n                    s.outgoing.add(type, t);\r\n                    t.incoming.add(type, s);\r\n                });\r\n            }\r\n            Configuration.prototype.initModulesFromGroup = function (group) {\r\n                var moduleSet = new ModuleSet();\r\n                this.roots.push(moduleSet);\r\n                for (var i = 0; i < group.leaves.length; ++i) {\r\n                    var node = group.leaves[i];\r\n                    var module = new Module(node.id);\r\n                    this.modules[node.id] = module;\r\n                    moduleSet.add(module);\r\n                }\r\n                if (group.groups) {\r\n                    for (var j = 0; j < group.groups.length; ++j) {\r\n                        var child = group.groups[j];\r\n                        // Propagate group properties (like padding, stiffness, ...) as module definition so that the generated power graph group will inherit it\r\n                        var definition = {};\r\n                        for (var prop in child)\r\n                            if (prop !== \"leaves\" && prop !== \"groups\" && child.hasOwnProperty(prop))\r\n                                definition[prop] = child[prop];\r\n                        // Use negative module id to avoid clashes between predefined and generated modules\r\n                        moduleSet.add(new Module(-1 - j, new LinkSets(), new LinkSets(), this.initModulesFromGroup(child), definition));\r\n                    }\r\n                }\r\n                return moduleSet;\r\n            };\r\n            // merge modules a and b keeping track of their power edges and removing the from roots\r\n            Configuration.prototype.merge = function (a, b, k) {\r\n                if (k === void 0) { k = 0; }\r\n                var inInt = a.incoming.intersection(b.incoming), outInt = a.outgoing.intersection(b.outgoing);\r\n                var children = new ModuleSet();\r\n                children.add(a);\r\n                children.add(b);\r\n                var m = new Module(this.modules.length, outInt, inInt, children);\r\n                this.modules.push(m);\r\n                var update = function (s, i, o) {\r\n                    s.forAll(function (ms, linktype) {\r\n                        ms.forAll(function (n) {\r\n                            var nls = n[i];\r\n                            nls.add(linktype, m);\r\n                            nls.remove(linktype, a);\r\n                            nls.remove(linktype, b);\r\n                            a[o].remove(linktype, n);\r\n                            b[o].remove(linktype, n);\r\n                        });\r\n                    });\r\n                };\r\n                update(outInt, \"incoming\", \"outgoing\");\r\n                update(inInt, \"outgoing\", \"incoming\");\r\n                this.R -= inInt.count() + outInt.count();\r\n                this.roots[k].remove(a);\r\n                this.roots[k].remove(b);\r\n                this.roots[k].add(m);\r\n                return m;\r\n            };\r\n            Configuration.prototype.rootMerges = function (k) {\r\n                if (k === void 0) { k = 0; }\r\n                var rs = this.roots[k].modules();\r\n                var n = rs.length;\r\n                var merges = new Array(n * (n - 1));\r\n                var ctr = 0;\r\n                for (var i = 0, i_ = n - 1; i < i_; ++i) {\r\n                    for (var j = i + 1; j < n; ++j) {\r\n                        var a = rs[i], b = rs[j];\r\n                        merges[ctr] = { id: ctr, nEdges: this.nEdges(a, b), a: a, b: b };\r\n                        ctr++;\r\n                    }\r\n                }\r\n                return merges;\r\n            };\r\n            Configuration.prototype.greedyMerge = function () {\r\n                for (var i = 0; i < this.roots.length; ++i) {\r\n                    // Handle single nested module case\r\n                    if (this.roots[i].modules().length < 2)\r\n                        continue;\r\n                    // find the merge that allows for the most edges to be removed.  secondary ordering based on arbitrary id (for predictability)\r\n                    var ms = this.rootMerges(i).sort(function (a, b) { return a.nEdges == b.nEdges ? a.id - b.id : a.nEdges - b.nEdges; });\r\n                    var m = ms[0];\r\n                    if (m.nEdges >= this.R)\r\n                        continue;\r\n                    this.merge(m.a, m.b, i);\r\n                    return true;\r\n                }\r\n            };\r\n            Configuration.prototype.nEdges = function (a, b) {\r\n                var inInt = a.incoming.intersection(b.incoming), outInt = a.outgoing.intersection(b.outgoing);\r\n                return this.R - inInt.count() - outInt.count();\r\n            };\r\n            Configuration.prototype.getGroupHierarchy = function (retargetedEdges) {\r\n                var _this = this;\r\n                var groups = [];\r\n                var root = {};\r\n                toGroups(this.roots[0], root, groups);\r\n                var es = this.allEdges();\r\n                es.forEach(function (e) {\r\n                    var a = _this.modules[e.source];\r\n                    var b = _this.modules[e.target];\r\n                    retargetedEdges.push(new PowerEdge(typeof a.gid === \"undefined\" ? e.source : groups[a.gid], typeof b.gid === \"undefined\" ? e.target : groups[b.gid], e.type));\r\n                });\r\n                return groups;\r\n            };\r\n            Configuration.prototype.allEdges = function () {\r\n                var es = [];\r\n                Configuration.getEdges(this.roots[0], es);\r\n                return es;\r\n            };\r\n            Configuration.getEdges = function (modules, es) {\r\n                modules.forAll(function (m) {\r\n                    m.getEdges(es);\r\n                    Configuration.getEdges(m.children, es);\r\n                });\r\n            };\r\n            return Configuration;\r\n        })();\r\n        powergraph.Configuration = Configuration;\r\n        function toGroups(modules, group, groups) {\r\n            modules.forAll(function (m) {\r\n                if (m.isLeaf()) {\r\n                    if (!group.leaves)\r\n                        group.leaves = [];\r\n                    group.leaves.push(m.id);\r\n                }\r\n                else {\r\n                    var g = group;\r\n                    m.gid = groups.length;\r\n                    if (!m.isIsland() || m.isPredefined()) {\r\n                        g = { id: m.gid };\r\n                        if (m.isPredefined())\r\n                            // Apply original group properties\r\n                            for (var prop in m.definition)\r\n                                g[prop] = m.definition[prop];\r\n                        if (!group.groups)\r\n                            group.groups = [];\r\n                        group.groups.push(m.gid);\r\n                        groups.push(g);\r\n                    }\r\n                    toGroups(m.children, g, groups);\r\n                }\r\n            });\r\n        }\r\n        var Module = (function () {\r\n            function Module(id, outgoing, incoming, children, definition) {\r\n                if (outgoing === void 0) { outgoing = new LinkSets(); }\r\n                if (incoming === void 0) { incoming = new LinkSets(); }\r\n                if (children === void 0) { children = new ModuleSet(); }\r\n                this.id = id;\r\n                this.outgoing = outgoing;\r\n                this.incoming = incoming;\r\n                this.children = children;\r\n                this.definition = definition;\r\n            }\r\n            Module.prototype.getEdges = function (es) {\r\n                var _this = this;\r\n                this.outgoing.forAll(function (ms, edgetype) {\r\n                    ms.forAll(function (target) {\r\n                        es.push(new PowerEdge(_this.id, target.id, edgetype));\r\n                    });\r\n                });\r\n            };\r\n            Module.prototype.isLeaf = function () {\r\n                return this.children.count() === 0;\r\n            };\r\n            Module.prototype.isIsland = function () {\r\n                return this.outgoing.count() === 0 && this.incoming.count() === 0;\r\n            };\r\n            Module.prototype.isPredefined = function () {\r\n                return typeof this.definition !== \"undefined\";\r\n            };\r\n            return Module;\r\n        })();\r\n        powergraph.Module = Module;\r\n        function intersection(m, n) {\r\n            var i = {};\r\n            for (var v in m)\r\n                if (v in n)\r\n                    i[v] = m[v];\r\n            return i;\r\n        }\r\n        var ModuleSet = (function () {\r\n            function ModuleSet() {\r\n                this.table = {};\r\n            }\r\n            ModuleSet.prototype.count = function () {\r\n                return Object.keys(this.table).length;\r\n            };\r\n            ModuleSet.prototype.intersection = function (other) {\r\n                var result = new ModuleSet();\r\n                result.table = intersection(this.table, other.table);\r\n                return result;\r\n            };\r\n            ModuleSet.prototype.intersectionCount = function (other) {\r\n                return this.intersection(other).count();\r\n            };\r\n            ModuleSet.prototype.contains = function (id) {\r\n                return id in this.table;\r\n            };\r\n            ModuleSet.prototype.add = function (m) {\r\n                this.table[m.id] = m;\r\n            };\r\n            ModuleSet.prototype.remove = function (m) {\r\n                delete this.table[m.id];\r\n            };\r\n            ModuleSet.prototype.forAll = function (f) {\r\n                for (var mid in this.table) {\r\n                    f(this.table[mid]);\r\n                }\r\n            };\r\n            ModuleSet.prototype.modules = function () {\r\n                var vs = [];\r\n                this.forAll(function (m) {\r\n                    if (!m.isPredefined())\r\n                        vs.push(m);\r\n                });\r\n                return vs;\r\n            };\r\n            return ModuleSet;\r\n        })();\r\n        powergraph.ModuleSet = ModuleSet;\r\n        var LinkSets = (function () {\r\n            function LinkSets() {\r\n                this.sets = {};\r\n                this.n = 0;\r\n            }\r\n            LinkSets.prototype.count = function () {\r\n                return this.n;\r\n            };\r\n            LinkSets.prototype.contains = function (id) {\r\n                var result = false;\r\n                this.forAllModules(function (m) {\r\n                    if (!result && m.id == id) {\r\n                        result = true;\r\n                    }\r\n                });\r\n                return result;\r\n            };\r\n            LinkSets.prototype.add = function (linktype, m) {\r\n                var s = linktype in this.sets ? this.sets[linktype] : this.sets[linktype] = new ModuleSet();\r\n                s.add(m);\r\n                ++this.n;\r\n            };\r\n            LinkSets.prototype.remove = function (linktype, m) {\r\n                var ms = this.sets[linktype];\r\n                ms.remove(m);\r\n                if (ms.count() === 0) {\r\n                    delete this.sets[linktype];\r\n                }\r\n                --this.n;\r\n            };\r\n            LinkSets.prototype.forAll = function (f) {\r\n                for (var linktype in this.sets) {\r\n                    f(this.sets[linktype], linktype);\r\n                }\r\n            };\r\n            LinkSets.prototype.forAllModules = function (f) {\r\n                this.forAll(function (ms, lt) { return ms.forAll(f); });\r\n            };\r\n            LinkSets.prototype.intersection = function (other) {\r\n                var result = new LinkSets();\r\n                this.forAll(function (ms, lt) {\r\n                    if (lt in other.sets) {\r\n                        var i = ms.intersection(other.sets[lt]), n = i.count();\r\n                        if (n > 0) {\r\n                            result.sets[lt] = i;\r\n                            result.n += n;\r\n                        }\r\n                    }\r\n                });\r\n                return result;\r\n            };\r\n            return LinkSets;\r\n        })();\r\n        powergraph.LinkSets = LinkSets;\r\n        function intersectionCount(m, n) {\r\n            return Object.keys(intersection(m, n)).length;\r\n        }\r\n        function getGroups(nodes, links, la, rootGroup) {\r\n            var n = nodes.length, c = new powergraph.Configuration(n, links, la, rootGroup);\r\n            while (c.greedyMerge())\r\n                ;\r\n            var powerEdges = [];\r\n            var g = c.getGroupHierarchy(powerEdges);\r\n            powerEdges.forEach(function (e) {\r\n                var f = function (end) {\r\n                    var g = e[end];\r\n                    if (typeof g == \"number\")\r\n                        e[end] = nodes[g];\r\n                };\r\n                f(\"source\");\r\n                f(\"target\");\r\n            });\r\n            return { groups: g, powerEdges: powerEdges };\r\n        }\r\n        powergraph.getGroups = getGroups;\r\n    })(powergraph = cola.powergraph || (cola.powergraph = {}));\r\n})(cola || (cola = {}));\r\n/**\r\n * @module cola\r\n */\r\nvar cola;\r\n(function (cola) {\r\n    // compute the size of the union of two sets a and b\r\n    function unionCount(a, b) {\r\n        var u = {};\r\n        for (var i in a)\r\n            u[i] = {};\r\n        for (var i in b)\r\n            u[i] = {};\r\n        return Object.keys(u).length;\r\n    }\r\n    // compute the size of the intersection of two sets a and b\r\n    function intersectionCount(a, b) {\r\n        var n = 0;\r\n        for (var i in a)\r\n            if (typeof b[i] !== 'undefined')\r\n                ++n;\r\n        return n;\r\n    }\r\n    function getNeighbours(links, la) {\r\n        var neighbours = {};\r\n        var addNeighbours = function (u, v) {\r\n            if (typeof neighbours[u] === 'undefined')\r\n                neighbours[u] = {};\r\n            neighbours[u][v] = {};\r\n        };\r\n        links.forEach(function (e) {\r\n            var u = la.getSourceIndex(e), v = la.getTargetIndex(e);\r\n            addNeighbours(u, v);\r\n            addNeighbours(v, u);\r\n        });\r\n        return neighbours;\r\n    }\r\n    // modify the lengths of the specified links by the result of function f weighted by w\r\n    function computeLinkLengths(links, w, f, la) {\r\n        var neighbours = getNeighbours(links, la);\r\n        links.forEach(function (l) {\r\n            var a = neighbours[la.getSourceIndex(l)];\r\n            var b = neighbours[la.getTargetIndex(l)];\r\n            la.setLength(l, 1 + w * f(a, b));\r\n        });\r\n    }\r\n    /** modify the specified link lengths based on the symmetric difference of their neighbours\r\n     * @class symmetricDiffLinkLengths\r\n     */\r\n    function symmetricDiffLinkLengths(links, la, w) {\r\n        if (w === void 0) { w = 1; }\r\n        computeLinkLengths(links, w, function (a, b) { return Math.sqrt(unionCount(a, b) - intersectionCount(a, b)); }, la);\r\n    }\r\n    cola.symmetricDiffLinkLengths = symmetricDiffLinkLengths;\r\n    /** modify the specified links lengths based on the jaccard difference between their neighbours\r\n     * @class jaccardLinkLengths\r\n     */\r\n    function jaccardLinkLengths(links, la, w) {\r\n        if (w === void 0) { w = 1; }\r\n        computeLinkLengths(links, w, function (a, b) {\r\n            return Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b);\r\n        }, la);\r\n    }\r\n    cola.jaccardLinkLengths = jaccardLinkLengths;\r\n    /** generate separation constraints for all edges unless both their source and sink are in the same strongly connected component\r\n     * @class generateDirectedEdgeConstraints\r\n     */\r\n    function generateDirectedEdgeConstraints(n, links, axis, la) {\r\n        var components = stronglyConnectedComponents(n, links, la);\r\n        var nodes = {};\r\n        components.forEach(function (c, i) {\r\n            return c.forEach(function (v) { return nodes[v] = i; });\r\n        });\r\n        var constraints = [];\r\n        links.forEach(function (l) {\r\n            var ui = la.getSourceIndex(l), vi = la.getTargetIndex(l), u = nodes[ui], v = nodes[vi];\r\n            if (u !== v) {\r\n                constraints.push({\r\n                    axis: axis,\r\n                    left: ui,\r\n                    right: vi,\r\n                    gap: la.getMinSeparation(l)\r\n                });\r\n            }\r\n        });\r\n        return constraints;\r\n    }\r\n    cola.generateDirectedEdgeConstraints = generateDirectedEdgeConstraints;\r\n    /**\r\n     * Tarjan's strongly connected components algorithm for directed graphs\r\n     * returns an array of arrays of node indicies in each of the strongly connected components.\r\n     * a vertex not in a SCC of two or more nodes is it's own SCC.\r\n     * adaptation of https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\r\n     */\r\n    function stronglyConnectedComponents(numVertices, edges, la) {\r\n        var nodes = [];\r\n        var index = 0;\r\n        var stack = [];\r\n        var components = [];\r\n        function strongConnect(v) {\r\n            // Set the depth index for v to the smallest unused index\r\n            v.index = v.lowlink = index++;\r\n            stack.push(v);\r\n            v.onStack = true;\r\n            // Consider successors of v\r\n            for (var _i = 0, _a = v.out; _i < _a.length; _i++) {\r\n                var w = _a[_i];\r\n                if (typeof w.index === 'undefined') {\r\n                    // Successor w has not yet been visited; recurse on it\r\n                    strongConnect(w);\r\n                    v.lowlink = Math.min(v.lowlink, w.lowlink);\r\n                }\r\n                else if (w.onStack) {\r\n                    // Successor w is in stack S and hence in the current SCC\r\n                    v.lowlink = Math.min(v.lowlink, w.index);\r\n                }\r\n            }\r\n            // If v is a root node, pop the stack and generate an SCC\r\n            if (v.lowlink === v.index) {\r\n                // start a new strongly connected component\r\n                var component = [];\r\n                while (stack.length) {\r\n                    w = stack.pop();\r\n                    w.onStack = false;\r\n                    //add w to current strongly connected component\r\n                    component.push(w);\r\n                    if (w === v)\r\n                        break;\r\n                }\r\n                // output the current strongly connected component\r\n                components.push(component.map(function (v) { return v.id; }));\r\n            }\r\n        }\r\n        for (var i = 0; i < numVertices; i++) {\r\n            nodes.push({ id: i, out: [] });\r\n        }\r\n        for (var _i = 0; _i < edges.length; _i++) {\r\n            var e = edges[_i];\r\n            var v_1 = nodes[la.getSourceIndex(e)], w = nodes[la.getTargetIndex(e)];\r\n            v_1.out.push(w);\r\n        }\r\n        for (var _a = 0; _a < nodes.length; _a++) {\r\n            var v = nodes[_a];\r\n            if (typeof v.index === 'undefined')\r\n                strongConnect(v);\r\n        }\r\n        return components;\r\n    }\r\n    cola.stronglyConnectedComponents = stronglyConnectedComponents;\r\n})(cola || (cola = {}));\r\nvar PairingHeap = (function () {\r\n    // from: https://gist.github.com/nervoussystem\r\n    //{elem:object, subheaps:[array of heaps]}\r\n    function PairingHeap(elem) {\r\n        this.elem = elem;\r\n        this.subheaps = [];\r\n    }\r\n    PairingHeap.prototype.toString = function (selector) {\r\n        var str = \"\", needComma = false;\r\n        for (var i = 0; i < this.subheaps.length; ++i) {\r\n            var subheap = this.subheaps[i];\r\n            if (!subheap.elem) {\r\n                needComma = false;\r\n                continue;\r\n            }\r\n            if (needComma) {\r\n                str = str + \",\";\r\n            }\r\n            str = str + subheap.toString(selector);\r\n            needComma = true;\r\n        }\r\n        if (str !== \"\") {\r\n            str = \"(\" + str + \")\";\r\n        }\r\n        return (this.elem ? selector(this.elem) : \"\") + str;\r\n    };\r\n    PairingHeap.prototype.forEach = function (f) {\r\n        if (!this.empty()) {\r\n            f(this.elem, this);\r\n            this.subheaps.forEach(function (s) { return s.forEach(f); });\r\n        }\r\n    };\r\n    PairingHeap.prototype.count = function () {\r\n        return this.empty() ? 0 : 1 + this.subheaps.reduce(function (n, h) {\r\n            return n + h.count();\r\n        }, 0);\r\n    };\r\n    PairingHeap.prototype.min = function () {\r\n        return this.elem;\r\n    };\r\n    PairingHeap.prototype.empty = function () {\r\n        return this.elem == null;\r\n    };\r\n    PairingHeap.prototype.contains = function (h) {\r\n        if (this === h)\r\n            return true;\r\n        for (var i = 0; i < this.subheaps.length; i++) {\r\n            if (this.subheaps[i].contains(h))\r\n                return true;\r\n        }\r\n        return false;\r\n    };\r\n    PairingHeap.prototype.isHeap = function (lessThan) {\r\n        var _this = this;\r\n        return this.subheaps.every(function (h) { return lessThan(_this.elem, h.elem) && h.isHeap(lessThan); });\r\n    };\r\n    PairingHeap.prototype.insert = function (obj, lessThan) {\r\n        return this.merge(new PairingHeap(obj), lessThan);\r\n    };\r\n    PairingHeap.prototype.merge = function (heap2, lessThan) {\r\n        if (this.empty())\r\n            return heap2;\r\n        else if (heap2.empty())\r\n            return this;\r\n        else if (lessThan(this.elem, heap2.elem)) {\r\n            this.subheaps.push(heap2);\r\n            return this;\r\n        }\r\n        else {\r\n            heap2.subheaps.push(this);\r\n            return heap2;\r\n        }\r\n    };\r\n    PairingHeap.prototype.removeMin = function (lessThan) {\r\n        if (this.empty())\r\n            return null;\r\n        else\r\n            return this.mergePairs(lessThan);\r\n    };\r\n    PairingHeap.prototype.mergePairs = function (lessThan) {\r\n        if (this.subheaps.length == 0)\r\n            return new PairingHeap(null);\r\n        else if (this.subheaps.length == 1) {\r\n            return this.subheaps[0];\r\n        }\r\n        else {\r\n            var firstPair = this.subheaps.pop().merge(this.subheaps.pop(), lessThan);\r\n            var remaining = this.mergePairs(lessThan);\r\n            return firstPair.merge(remaining, lessThan);\r\n        }\r\n    };\r\n    PairingHeap.prototype.decreaseKey = function (subheap, newValue, setHeapNode, lessThan) {\r\n        var newHeap = subheap.removeMin(lessThan);\r\n        //reassign subheap values to preserve tree\r\n        subheap.elem = newHeap.elem;\r\n        subheap.subheaps = newHeap.subheaps;\r\n        if (setHeapNode !== null && newHeap.elem !== null) {\r\n            setHeapNode(subheap.elem, subheap);\r\n        }\r\n        var pairingNode = new PairingHeap(newValue);\r\n        if (setHeapNode !== null) {\r\n            setHeapNode(newValue, pairingNode);\r\n        }\r\n        return this.merge(pairingNode, lessThan);\r\n    };\r\n    return PairingHeap;\r\n})();\r\n/**\r\n * @class PriorityQueue a min priority queue backed by a pairing heap\r\n */\r\nvar PriorityQueue = (function () {\r\n    function PriorityQueue(lessThan) {\r\n        this.lessThan = lessThan;\r\n    }\r\n    /**\r\n     * @method top\r\n     * @return the top element (the min element as defined by lessThan)\r\n     */\r\n    PriorityQueue.prototype.top = function () {\r\n        if (this.empty()) {\r\n            return null;\r\n        }\r\n        return this.root.elem;\r\n    };\r\n    /**\r\n     * @method push\r\n     * put things on the heap\r\n     */\r\n    PriorityQueue.prototype.push = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i - 0] = arguments[_i];\r\n        }\r\n        var pairingNode;\r\n        for (var i = 0, arg; arg = args[i]; ++i) {\r\n            pairingNode = new PairingHeap(arg);\r\n            this.root = this.empty() ?\r\n                pairingNode : this.root.merge(pairingNode, this.lessThan);\r\n        }\r\n        return pairingNode;\r\n    };\r\n    /**\r\n     * @method empty\r\n     * @return true if no more elements in queue\r\n     */\r\n    PriorityQueue.prototype.empty = function () {\r\n        return !this.root || !this.root.elem;\r\n    };\r\n    /**\r\n     * @method isHeap check heap condition (for testing)\r\n     * @return true if queue is in valid state\r\n     */\r\n    PriorityQueue.prototype.isHeap = function () {\r\n        return this.root.isHeap(this.lessThan);\r\n    };\r\n    /**\r\n     * @method forEach apply f to each element of the queue\r\n     * @param f function to apply\r\n     */\r\n    PriorityQueue.prototype.forEach = function (f) {\r\n        this.root.forEach(f);\r\n    };\r\n    /**\r\n     * @method pop remove and return the min element from the queue\r\n     */\r\n    PriorityQueue.prototype.pop = function () {\r\n        if (this.empty()) {\r\n            return null;\r\n        }\r\n        var obj = this.root.min();\r\n        this.root = this.root.removeMin(this.lessThan);\r\n        return obj;\r\n    };\r\n    /**\r\n     * @method reduceKey reduce the key value of the specified heap node\r\n     */\r\n    PriorityQueue.prototype.reduceKey = function (heapNode, newKey, setHeapNode) {\r\n        if (setHeapNode === void 0) { setHeapNode = null; }\r\n        this.root = this.root.decreaseKey(heapNode, newKey, setHeapNode, this.lessThan);\r\n    };\r\n    PriorityQueue.prototype.toString = function (selector) {\r\n        return this.root.toString(selector);\r\n    };\r\n    /**\r\n     * @method count\r\n     * @return number of elements in queue\r\n     */\r\n    PriorityQueue.prototype.count = function () {\r\n        return this.root.count();\r\n    };\r\n    return PriorityQueue;\r\n})();\r\n///<reference path=\"pqueue.ts\"/>\r\n/**\r\n * @module shortestpaths\r\n */\r\nvar cola;\r\n(function (cola) {\r\n    var shortestpaths;\r\n    (function (shortestpaths) {\r\n        var Neighbour = (function () {\r\n            function Neighbour(id, distance) {\r\n                this.id = id;\r\n                this.distance = distance;\r\n            }\r\n            return Neighbour;\r\n        })();\r\n        var Node = (function () {\r\n            function Node(id) {\r\n                this.id = id;\r\n                this.neighbours = [];\r\n            }\r\n            return Node;\r\n        })();\r\n        var QueueEntry = (function () {\r\n            function QueueEntry(node, prev, d) {\r\n                this.node = node;\r\n                this.prev = prev;\r\n                this.d = d;\r\n            }\r\n            return QueueEntry;\r\n        })();\r\n        /**\r\n         * calculates all-pairs shortest paths or shortest paths from a single node\r\n         * @class Calculator\r\n         * @constructor\r\n         * @param n {number} number of nodes\r\n         * @param es {Edge[]} array of edges\r\n         */\r\n        var Calculator = (function () {\r\n            function Calculator(n, es, getSourceIndex, getTargetIndex, getLength) {\r\n                this.n = n;\r\n                this.es = es;\r\n                this.neighbours = new Array(this.n);\r\n                var i = this.n;\r\n                while (i--)\r\n                    this.neighbours[i] = new Node(i);\r\n                i = this.es.length;\r\n                while (i--) {\r\n                    var e = this.es[i];\r\n                    var u = getSourceIndex(e), v = getTargetIndex(e);\r\n                    var d = getLength(e);\r\n                    this.neighbours[u].neighbours.push(new Neighbour(v, d));\r\n                    this.neighbours[v].neighbours.push(new Neighbour(u, d));\r\n                }\r\n            }\r\n            /**\r\n             * compute shortest paths for graph over n nodes with edges an array of source/target pairs\r\n             * edges may optionally have a length attribute.  1 is the default.\r\n             * Uses Johnson's algorithm.\r\n             *\r\n             * @method DistanceMatrix\r\n             * @return the distance matrix\r\n             */\r\n            Calculator.prototype.DistanceMatrix = function () {\r\n                var D = new Array(this.n);\r\n                for (var i = 0; i < this.n; ++i) {\r\n                    D[i] = this.dijkstraNeighbours(i);\r\n                }\r\n                return D;\r\n            };\r\n            /**\r\n             * get shortest paths from a specified start node\r\n             * @method DistancesFromNode\r\n             * @param start node index\r\n             * @return array of path lengths\r\n             */\r\n            Calculator.prototype.DistancesFromNode = function (start) {\r\n                return this.dijkstraNeighbours(start);\r\n            };\r\n            Calculator.prototype.PathFromNodeToNode = function (start, end) {\r\n                return this.dijkstraNeighbours(start, end);\r\n            };\r\n            // find shortest path from start to end, with the opportunity at \r\n            // each edge traversal to compute a custom cost based on the \r\n            // previous edge.  For example, to penalise bends.\r\n            Calculator.prototype.PathFromNodeToNodeWithPrevCost = function (start, end, prevCost) {\r\n                var q = new PriorityQueue(function (a, b) { return a.d <= b.d; }), u = this.neighbours[start], qu = new QueueEntry(u, null, 0), visitedFrom = {};\r\n                q.push(qu);\r\n                while (!q.empty()) {\r\n                    qu = q.pop();\r\n                    u = qu.node;\r\n                    if (u.id === end) {\r\n                        break;\r\n                    }\r\n                    var i = u.neighbours.length;\r\n                    while (i--) {\r\n                        var neighbour = u.neighbours[i], v = this.neighbours[neighbour.id];\r\n                        // don't double back\r\n                        if (qu.prev && v.id === qu.prev.node.id)\r\n                            continue;\r\n                        // don't retraverse an edge if it has already been explored\r\n                        // from a lower cost route\r\n                        var viduid = v.id + ',' + u.id;\r\n                        if (viduid in visitedFrom && visitedFrom[viduid] <= qu.d)\r\n                            continue;\r\n                        var cc = qu.prev ? prevCost(qu.prev.node.id, u.id, v.id) : 0, t = qu.d + neighbour.distance + cc;\r\n                        // store cost of this traversal\r\n                        visitedFrom[viduid] = t;\r\n                        q.push(new QueueEntry(v, qu, t));\r\n                    }\r\n                }\r\n                var path = [];\r\n                while (qu.prev) {\r\n                    qu = qu.prev;\r\n                    path.push(qu.node.id);\r\n                }\r\n                return path;\r\n            };\r\n            Calculator.prototype.dijkstraNeighbours = function (start, dest) {\r\n                if (dest === void 0) { dest = -1; }\r\n                var q = new PriorityQueue(function (a, b) { return a.d <= b.d; }), i = this.neighbours.length, d = new Array(i);\r\n                while (i--) {\r\n                    var node = this.neighbours[i];\r\n                    node.d = i === start ? 0 : Number.POSITIVE_INFINITY;\r\n                    node.q = q.push(node);\r\n                }\r\n                while (!q.empty()) {\r\n                    // console.log(q.toString(function (u) { return u.id + \"=\" + (u.d === Number.POSITIVE_INFINITY ? \"\\u221E\" : u.d.toFixed(2) )}));\r\n                    var u = q.pop();\r\n                    d[u.id] = u.d;\r\n                    if (u.id === dest) {\r\n                        var path = [];\r\n                        var v = u;\r\n                        while (typeof v.prev !== 'undefined') {\r\n                            path.push(v.prev.id);\r\n                            v = v.prev;\r\n                        }\r\n                        return path;\r\n                    }\r\n                    i = u.neighbours.length;\r\n                    while (i--) {\r\n                        var neighbour = u.neighbours[i];\r\n                        var v = this.neighbours[neighbour.id];\r\n                        var t = u.d + neighbour.distance;\r\n                        if (u.d !== Number.MAX_VALUE && v.d > t) {\r\n                            v.d = t;\r\n                            v.prev = u;\r\n                            q.reduceKey(v.q, v, function (e, q) { return e.q = q; });\r\n                        }\r\n                    }\r\n                }\r\n                return d;\r\n            };\r\n            return Calculator;\r\n        })();\r\n        shortestpaths.Calculator = Calculator;\r\n    })(shortestpaths = cola.shortestpaths || (cola.shortestpaths = {}));\r\n})(cola || (cola = {}));\r\n///<reference path=\"handledisconnected.ts\"/>\r\n///<reference path=\"geom.ts\"/>\r\n///<reference path=\"descent.ts\"/>\r\n///<reference path=\"powergraph.ts\"/>\r\n///<reference path=\"linklengths.ts\"/>\r\n///<reference path=\"shortestpaths.ts\"/>\r\n/**\r\n * @module cola\r\n */\r\nvar cola;\r\n(function (cola) {\r\n    /**\r\n     * The layout process fires three events:\r\n     *  - start: layout iterations started\r\n     *  - tick: fired once per iteration, listen to this to animate\r\n     *  - end: layout converged, you might like to zoom-to-fit or something at notification of this event\r\n     */\r\n    (function (EventType) {\r\n        EventType[EventType[\"start\"] = 0] = \"start\";\r\n        EventType[EventType[\"tick\"] = 1] = \"tick\";\r\n        EventType[EventType[\"end\"] = 2] = \"end\";\r\n    })(cola.EventType || (cola.EventType = {}));\r\n    var EventType = cola.EventType;\r\n    ;\r\n    function isGroup(g) {\r\n        return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';\r\n    }\r\n    /**\r\n     * Main interface to cola layout.\r\n     * @class Layout\r\n     */\r\n    var Layout = (function () {\r\n        function Layout() {\r\n            var _this = this;\r\n            this._canvasSize = [1, 1];\r\n            this._linkDistance = 20;\r\n            this._defaultNodeSize = 10;\r\n            this._linkLengthCalculator = null;\r\n            this._linkType = null;\r\n            this._avoidOverlaps = false;\r\n            this._handleDisconnected = true;\r\n            this._running = false;\r\n            this._nodes = [];\r\n            this._groups = [];\r\n            this._rootGroup = null;\r\n            this._links = [];\r\n            this._constraints = [];\r\n            this._distanceMatrix = null;\r\n            this._descent = null;\r\n            this._directedLinkConstraints = null;\r\n            this._threshold = 0.01;\r\n            this._visibilityGraph = null;\r\n            this._groupCompactness = 1e-6;\r\n            // sub-class and override this property to replace with a more sophisticated eventing mechanism\r\n            this.event = null;\r\n            this.linkAccessor = {\r\n                getSourceIndex: Layout.getSourceIndex,\r\n                getTargetIndex: Layout.getTargetIndex,\r\n                setLength: Layout.setLinkLength,\r\n                getType: function (l) { return typeof _this._linkType === \"function\" ? _this._linkType(l) : 0; }\r\n            };\r\n        }\r\n        // subscribe a listener to an event\r\n        // sub-class and override this method to replace with a more sophisticated eventing mechanism\r\n        Layout.prototype.on = function (e, listener) {\r\n            // override me!\r\n            if (!this.event)\r\n                this.event = {};\r\n            if (typeof e === 'string') {\r\n                this.event[EventType[e]] = listener;\r\n            }\r\n            else {\r\n                this.event[e] = listener;\r\n            }\r\n            return this;\r\n        };\r\n        // a function that is notified of events like \"tick\"\r\n        // sub-class and override this method to replace with a more sophisticated eventing mechanism\r\n        Layout.prototype.trigger = function (e) {\r\n            if (this.event && typeof this.event[e.type] !== 'undefined') {\r\n                this.event[e.type](e);\r\n            }\r\n        };\r\n        // a function that kicks off the iteration tick loop\r\n        // it calls tick() repeatedly until tick returns true (is converged)\r\n        // subclass and override it with something fancier (e.g. dispatch tick on a timer)\r\n        Layout.prototype.kick = function () {\r\n            while (!this.tick())\r\n                ;\r\n        };\r\n        /**\r\n         * iterate the layout.  Returns true when layout converged.\r\n         */\r\n        Layout.prototype.tick = function () {\r\n            if (this._alpha < this._threshold) {\r\n                this._running = false;\r\n                this.trigger({ type: EventType.end, alpha: this._alpha = 0, stress: this._lastStress });\r\n                return true;\r\n            }\r\n            var n = this._nodes.length, m = this._links.length;\r\n            var o, i;\r\n            this._descent.locks.clear();\r\n            for (i = 0; i < n; ++i) {\r\n                o = this._nodes[i];\r\n                if (o.fixed) {\r\n                    if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {\r\n                        o.px = o.x;\r\n                        o.py = o.y;\r\n                    }\r\n                    var p = [o.px, o.py];\r\n                    this._descent.locks.add(i, p);\r\n                }\r\n            }\r\n            var s1 = this._descent.rungeKutta();\r\n            //var s1 = descent.reduceStress();\r\n            if (s1 === 0) {\r\n                this._alpha = 0;\r\n            }\r\n            else if (typeof this._lastStress !== 'undefined') {\r\n                this._alpha = s1; //Math.abs(Math.abs(this._lastStress / s1) - 1);\r\n            }\r\n            this._lastStress = s1;\r\n            this.updateNodePositions();\r\n            this.trigger({ type: EventType.tick, alpha: this._alpha, stress: this._lastStress });\r\n            return false;\r\n        };\r\n        // copy positions out of descent instance into each of the nodes' center coords\r\n        Layout.prototype.updateNodePositions = function () {\r\n            var x = this._descent.x[0], y = this._descent.x[1];\r\n            var o, i = this._nodes.length;\r\n            while (i--) {\r\n                o = this._nodes[i];\r\n                o.x = x[i];\r\n                o.y = y[i];\r\n            }\r\n        };\r\n        Layout.prototype.nodes = function (v) {\r\n            if (!v) {\r\n                if (this._nodes.length === 0 && this._links.length > 0) {\r\n                    // if we have links but no nodes, create the nodes array now with empty objects for the links to point at.\r\n                    // in this case the links are expected to be numeric indices for nodes in the range 0..n-1 where n is the number of nodes\r\n                    var n = 0;\r\n                    this._links.forEach(function (l) {\r\n                        n = Math.max(n, l.source, l.target);\r\n                    });\r\n                    this._nodes = new Array(++n);\r\n                    for (var i = 0; i < n; ++i) {\r\n                        this._nodes[i] = {};\r\n                    }\r\n                }\r\n                return this._nodes;\r\n            }\r\n            this._nodes = v;\r\n            return this;\r\n        };\r\n        Layout.prototype.groups = function (x) {\r\n            var _this = this;\r\n            if (!x)\r\n                return this._groups;\r\n            this._groups = x;\r\n            this._rootGroup = {};\r\n            this._groups.forEach(function (g) {\r\n                if (typeof g.padding === \"undefined\")\r\n                    g.padding = 1;\r\n                if (typeof g.leaves !== \"undefined\")\r\n                    g.leaves.forEach(function (v, i) { (g.leaves[i] = _this._nodes[v]).parent = g; });\r\n                if (typeof g.groups !== \"undefined\")\r\n                    g.groups.forEach(function (gi, i) { (g.groups[i] = _this._groups[gi]).parent = g; });\r\n            });\r\n            this._rootGroup.leaves = this._nodes.filter(function (v) { return typeof v.parent === 'undefined'; });\r\n            this._rootGroup.groups = this._groups.filter(function (g) { return typeof g.parent === 'undefined'; });\r\n            return this;\r\n        };\r\n        Layout.prototype.powerGraphGroups = function (f) {\r\n            var g = cola.powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);\r\n            this.groups(g.groups);\r\n            f(g);\r\n            return this;\r\n        };\r\n        Layout.prototype.avoidOverlaps = function (v) {\r\n            if (!arguments.length)\r\n                return this._avoidOverlaps;\r\n            this._avoidOverlaps = v;\r\n            return this;\r\n        };\r\n        Layout.prototype.handleDisconnected = function (v) {\r\n            if (!arguments.length)\r\n                return this._handleDisconnected;\r\n            this._handleDisconnected = v;\r\n            return this;\r\n        };\r\n        /**\r\n         * causes constraints to be generated such that directed graphs are laid out either from left-to-right or top-to-bottom.\r\n         * a separation constraint is generated in the selected axis for each edge that is not involved in a cycle (part of a strongly connected component)\r\n         * @param axis {string} 'x' for left-to-right, 'y' for top-to-bottom\r\n         * @param minSeparation {number|link=>number} either a number specifying a minimum spacing required across all links or a function to return the minimum spacing for each link\r\n         */\r\n        Layout.prototype.flowLayout = function (axis, minSeparation) {\r\n            if (!arguments.length)\r\n                axis = 'y';\r\n            this._directedLinkConstraints = {\r\n                axis: axis,\r\n                getMinSeparation: typeof minSeparation === 'number' ? function () { return minSeparation; } : minSeparation\r\n            };\r\n            return this;\r\n        };\r\n        Layout.prototype.links = function (x) {\r\n            if (!arguments.length)\r\n                return this._links;\r\n            this._links = x;\r\n            return this;\r\n        };\r\n        Layout.prototype.constraints = function (c) {\r\n            if (!arguments.length)\r\n                return this._constraints;\r\n            this._constraints = c;\r\n            return this;\r\n        };\r\n        Layout.prototype.distanceMatrix = function (d) {\r\n            if (!arguments.length)\r\n                return this._distanceMatrix;\r\n            this._distanceMatrix = d;\r\n            return this;\r\n        };\r\n        Layout.prototype.size = function (x) {\r\n            if (!x)\r\n                return this._canvasSize;\r\n            this._canvasSize = x;\r\n            return this;\r\n        };\r\n        Layout.prototype.defaultNodeSize = function (x) {\r\n            if (!x)\r\n                return this._defaultNodeSize;\r\n            this._defaultNodeSize = x;\r\n            return this;\r\n        };\r\n        Layout.prototype.groupCompactness = function (x) {\r\n            if (!x)\r\n                return this._groupCompactness;\r\n            this._groupCompactness = x;\r\n            return this;\r\n        };\r\n        Layout.prototype.linkDistance = function (x) {\r\n            if (!x) {\r\n                return this._linkDistance;\r\n            }\r\n            this._linkDistance = typeof x === \"function\" ? x : +x;\r\n            this._linkLengthCalculator = null;\r\n            return this;\r\n        };\r\n        Layout.prototype.linkType = function (f) {\r\n            this._linkType = f;\r\n            return this;\r\n        };\r\n        Layout.prototype.convergenceThreshold = function (x) {\r\n            if (!x)\r\n                return this._threshold;\r\n            this._threshold = typeof x === \"function\" ? x : +x;\r\n            return this;\r\n        };\r\n        Layout.prototype.alpha = function (x) {\r\n            if (!arguments.length)\r\n                return this._alpha;\r\n            else {\r\n                x = +x;\r\n                if (this._alpha) {\r\n                    if (x > 0)\r\n                        this._alpha = x; // we might keep it hot\r\n                    else\r\n                        this._alpha = 0; // or, next tick will dispatch \"end\"\r\n                }\r\n                else if (x > 0) {\r\n                    if (!this._running) {\r\n                        this._running = true;\r\n                        this.trigger({ type: EventType.start, alpha: this._alpha = x });\r\n                        this.kick();\r\n                    }\r\n                }\r\n                return this;\r\n            }\r\n        };\r\n        Layout.prototype.getLinkLength = function (link) {\r\n            return typeof this._linkDistance === \"function\" ? +(this._linkDistance(link)) : this._linkDistance;\r\n        };\r\n        Layout.setLinkLength = function (link, length) {\r\n            link.length = length;\r\n        };\r\n        Layout.prototype.getLinkType = function (link) {\r\n            return typeof this._linkType === \"function\" ? this._linkType(link) : 0;\r\n        };\r\n        /**\r\n         * compute an ideal length for each link based on the graph structure around that link.\r\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\r\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\r\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: sqrt(|a union b| - |a intersection b|)\r\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\r\n         * don't have to have been assigned before invoking this function.\r\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\r\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\r\n         */\r\n        Layout.prototype.symmetricDiffLinkLengths = function (idealLength, w) {\r\n            var _this = this;\r\n            if (w === void 0) { w = 1; }\r\n            this.linkDistance(function (l) { return idealLength * l.length; });\r\n            this._linkLengthCalculator = function () { return cola.symmetricDiffLinkLengths(_this._links, _this.linkAccessor, w); };\r\n            return this;\r\n        };\r\n        /**\r\n         * compute an ideal length for each link based on the graph structure around that link.\r\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\r\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\r\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: |a intersection b|/|a union b|\r\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\r\n         * don't have to have been assigned before invoking this function.\r\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\r\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\r\n         */\r\n        Layout.prototype.jaccardLinkLengths = function (idealLength, w) {\r\n            var _this = this;\r\n            if (w === void 0) { w = 1; }\r\n            this.linkDistance(function (l) { return idealLength * l.length; });\r\n            this._linkLengthCalculator = function () { return cola.jaccardLinkLengths(_this._links, _this.linkAccessor, w); };\r\n            return this;\r\n        };\r\n        /**\r\n         * start the layout process\r\n         * @method start\r\n         * @param {number} [initialUnconstrainedIterations=0] unconstrained initial layout iterations\r\n         * @param {number} [initialUserConstraintIterations=0] initial layout iterations with user-specified constraints\r\n         * @param {number} [initialAllConstraintsIterations=0] initial layout iterations with all constraints including non-overlap\r\n         * @param {number} [gridSnapIterations=0] iterations of \"grid snap\", which pulls nodes towards grid cell centers - grid of size node[0].width - only really makes sense if all nodes have the same width and height\r\n         * @param [keepRunning=true] keep iterating asynchronously via the tick method\r\n         */\r\n        Layout.prototype.start = function (initialUnconstrainedIterations, initialUserConstraintIterations, initialAllConstraintsIterations, gridSnapIterations, keepRunning) {\r\n            var _this = this;\r\n            if (initialUnconstrainedIterations === void 0) { initialUnconstrainedIterations = 0; }\r\n            if (initialUserConstraintIterations === void 0) { initialUserConstraintIterations = 0; }\r\n            if (initialAllConstraintsIterations === void 0) { initialAllConstraintsIterations = 0; }\r\n            if (gridSnapIterations === void 0) { gridSnapIterations = 0; }\r\n            if (keepRunning === void 0) { keepRunning = true; }\r\n            var i, j, n = this.nodes().length, N = n + 2 * this._groups.length, m = this._links.length, w = this._canvasSize[0], h = this._canvasSize[1];\r\n            if (this._linkLengthCalculator)\r\n                this._linkLengthCalculator();\r\n            var x = new Array(N), y = new Array(N);\r\n            var G = null;\r\n            var ao = this._avoidOverlaps;\r\n            this._nodes.forEach(function (v, i) {\r\n                v.index = i;\r\n                if (typeof v.x === 'undefined') {\r\n                    v.x = w / 2, v.y = h / 2;\r\n                }\r\n                x[i] = v.x, y[i] = v.y;\r\n            });\r\n            //should we do this to clearly label groups?\r\n            //this._groups.forEach((g, i) => g.groupIndex = i);\r\n            var distances;\r\n            if (this._distanceMatrix) {\r\n                // use the user specified distanceMatrix\r\n                distances = this._distanceMatrix;\r\n            }\r\n            else {\r\n                // construct an n X n distance matrix based on shortest paths through graph (with respect to edge.length).\r\n                distances = (new cola.shortestpaths.Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, function (l) { return _this.getLinkLength(l); })).DistanceMatrix();\r\n                // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\r\n                // otherwise 2. (\r\n                G = cola.Descent.createSquareMatrix(N, function () { return 2; });\r\n                this._links.forEach(function (l) {\r\n                    if (typeof l.source == \"number\")\r\n                        l.source = _this._nodes[l.source];\r\n                    if (typeof l.target == \"number\")\r\n                        l.target = _this._nodes[l.target];\r\n                });\r\n                this._links.forEach(function (e) {\r\n                    var u = Layout.getSourceIndex(e), v = Layout.getTargetIndex(e);\r\n                    G[u][v] = G[v][u] = e.weight || 1;\r\n                });\r\n            }\r\n            var D = cola.Descent.createSquareMatrix(N, function (i, j) {\r\n                return distances[i][j];\r\n            });\r\n            if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {\r\n                var i = n;\r\n                var addAttraction = function (i, j, strength, idealDistance) {\r\n                    G[i][j] = G[j][i] = strength;\r\n                    D[i][j] = D[j][i] = idealDistance;\r\n                };\r\n                this._groups.forEach(function (g) {\r\n                    addAttraction(i, i + 1, _this._groupCompactness, 0.1);\r\n                    // todo: add terms here attracting children of the group to the group dummy nodes\r\n                    //if (typeof g.leaves !== 'undefined')\r\n                    //    g.leaves.forEach(l => {\r\n                    //        addAttraction(l.index, i, 1e-4, 0.1);\r\n                    //        addAttraction(l.index, i + 1, 1e-4, 0.1);\r\n                    //    });\r\n                    //if (typeof g.groups !== 'undefined')\r\n                    //    g.groups.forEach(g => {\r\n                    //        var gid = n + g.groupIndex * 2;\r\n                    //        addAttraction(gid, i, 0.1, 0.1);\r\n                    //        addAttraction(gid + 1, i, 0.1, 0.1);\r\n                    //        addAttraction(gid, i + 1, 0.1, 0.1);\r\n                    //        addAttraction(gid + 1, i + 1, 0.1, 0.1);\r\n                    //    });\r\n                    x[i] = 0, y[i++] = 0;\r\n                    x[i] = 0, y[i++] = 0;\r\n                });\r\n            }\r\n            else\r\n                this._rootGroup = { leaves: this._nodes, groups: [] };\r\n            var curConstraints = this._constraints || [];\r\n            if (this._directedLinkConstraints) {\r\n                this.linkAccessor.getMinSeparation = this._directedLinkConstraints.getMinSeparation;\r\n                curConstraints = curConstraints.concat(cola.generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, (this.linkAccessor)));\r\n            }\r\n            this.avoidOverlaps(false);\r\n            this._descent = new cola.Descent([x, y], D);\r\n            this._descent.locks.clear();\r\n            for (var i = 0; i < n; ++i) {\r\n                var o = this._nodes[i];\r\n                if (o.fixed) {\r\n                    o.px = o.x;\r\n                    o.py = o.y;\r\n                    var p = [o.x, o.y];\r\n                    this._descent.locks.add(i, p);\r\n                }\r\n            }\r\n            this._descent.threshold = this._threshold;\r\n            // apply initialIterations without user constraints or nonoverlap constraints\r\n            // if groups are specified, dummy nodes and edges will be added to untangle\r\n            // with respect to group connectivity\r\n            this.initialLayout(initialUnconstrainedIterations, x, y);\r\n            // apply initialIterations with user constraints but no nonoverlap constraints\r\n            if (curConstraints.length > 0)\r\n                this._descent.project = new cola.vpsc.Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();\r\n            this._descent.run(initialUserConstraintIterations);\r\n            this.separateOverlappingComponents(w, h);\r\n            // subsequent iterations will apply all constraints\r\n            this.avoidOverlaps(ao);\r\n            if (ao) {\r\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\r\n                this._descent.project = new cola.vpsc.Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();\r\n                this._nodes.forEach(function (v, i) { x[i] = v.x, y[i] = v.y; });\r\n            }\r\n            // allow not immediately connected nodes to relax apart (p-stress)\r\n            this._descent.G = G;\r\n            this._descent.run(initialAllConstraintsIterations);\r\n            if (gridSnapIterations) {\r\n                this._descent.snapStrength = 1000;\r\n                this._descent.snapGridSize = this._nodes[0].width;\r\n                this._descent.numGridSnapNodes = n;\r\n                this._descent.scaleSnapByMaxH = n != N; // if we have groups then need to scale hessian so grid forces still apply\r\n                var G0 = cola.Descent.createSquareMatrix(N, function (i, j) {\r\n                    if (i >= n || j >= n)\r\n                        return G[i][j];\r\n                    return 0;\r\n                });\r\n                this._descent.G = G0;\r\n                this._descent.run(gridSnapIterations);\r\n            }\r\n            this.updateNodePositions();\r\n            this.separateOverlappingComponents(w, h);\r\n            return keepRunning ? this.resume() : this;\r\n        };\r\n        Layout.prototype.initialLayout = function (iterations, x, y) {\r\n            if (this._groups.length > 0 && iterations > 0) {\r\n                // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children\r\n                // todo: edges attached to groups are replaced with edges connected to the corresponding group dummy node\r\n                var n = this._nodes.length;\r\n                var edges = this._links.map(function (e) { return { source: e.source.index, target: e.target.index }; });\r\n                var vs = this._nodes.map(function (v) { return { index: v.index }; });\r\n                this._groups.forEach(function (g, i) {\r\n                    vs.push({ index: g.index = n + i });\r\n                });\r\n                this._groups.forEach(function (g, i) {\r\n                    if (typeof g.leaves !== 'undefined')\r\n                        g.leaves.forEach(function (v) { return edges.push({ source: g.index, target: v.index }); });\r\n                    if (typeof g.groups !== 'undefined')\r\n                        g.groups.forEach(function (gg) { return edges.push({ source: g.index, target: gg.index }); });\r\n                });\r\n                // layout the flat graph with dummy nodes and edges\r\n                new cola.Layout()\r\n                    .size(this.size())\r\n                    .nodes(vs)\r\n                    .links(edges)\r\n                    .avoidOverlaps(false)\r\n                    .linkDistance(this.linkDistance())\r\n                    .symmetricDiffLinkLengths(5)\r\n                    .convergenceThreshold(1e-4)\r\n                    .start(iterations, 0, 0, 0, false);\r\n                this._nodes.forEach(function (v) {\r\n                    x[v.index] = vs[v.index].x;\r\n                    y[v.index] = vs[v.index].y;\r\n                });\r\n            }\r\n            else {\r\n                this._descent.run(iterations);\r\n            }\r\n        };\r\n        // recalculate nodes position for disconnected graphs\r\n        Layout.prototype.separateOverlappingComponents = function (width, height) {\r\n            var _this = this;\r\n            // recalculate nodes position for disconnected graphs\r\n            if (!this._distanceMatrix && this._handleDisconnected) {\r\n                var x = this._descent.x[0], y = this._descent.x[1];\r\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\r\n                var graphs = cola.separateGraphs(this._nodes, this._links);\r\n                cola.applyPacking(graphs, width, height, this._defaultNodeSize);\r\n                this._nodes.forEach(function (v, i) {\r\n                    _this._descent.x[0][i] = v.x, _this._descent.x[1][i] = v.y;\r\n                    if (v.bounds) {\r\n                        v.bounds.setXCentre(v.x);\r\n                        v.bounds.setYCentre(v.y);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        Layout.prototype.resume = function () {\r\n            return this.alpha(0.1);\r\n        };\r\n        Layout.prototype.stop = function () {\r\n            return this.alpha(0);\r\n        };\r\n        /// find a visibility graph over the set of nodes.  assumes all nodes have a\r\n        /// bounds property (a rectangle) and that no pair of bounds overlaps.\r\n        Layout.prototype.prepareEdgeRouting = function (nodeMargin) {\r\n            if (nodeMargin === void 0) { nodeMargin = 0; }\r\n            this._visibilityGraph = new cola.geom.TangentVisibilityGraph(this._nodes.map(function (v) {\r\n                return v.bounds.inflate(-nodeMargin).vertices();\r\n            }));\r\n        };\r\n        /// find a route avoiding node bounds for the given edge.\r\n        /// assumes the visibility graph has been created (by prepareEdgeRouting method)\r\n        /// and also assumes that nodes have an index property giving their position in the\r\n        /// node array.  This index property is created by the start() method.\r\n        Layout.prototype.routeEdge = function (edge, draw) {\r\n            var lineData = [];\r\n            //if (d.source.id === 10 && d.target.id === 11) {\r\n            //    debugger;\r\n            //}\r\n            var vg2 = new cola.geom.TangentVisibilityGraph(this._visibilityGraph.P, { V: this._visibilityGraph.V, E: this._visibilityGraph.E }), port1 = { x: edge.source.x, y: edge.source.y }, port2 = { x: edge.target.x, y: edge.target.y }, start = vg2.addPoint(port1, edge.source.index), end = vg2.addPoint(port2, edge.target.index);\r\n            vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);\r\n            if (typeof draw !== 'undefined') {\r\n                draw(vg2);\r\n            }\r\n            var sourceInd = function (e) { return e.source.id; }, targetInd = function (e) { return e.target.id; }, length = function (e) { return e.length(); }, spCalc = new cola.shortestpaths.Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length), shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);\r\n            if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {\r\n                var route = cola.vpsc.makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, 5);\r\n                lineData = [route.sourceIntersection, route.arrowStart];\r\n            }\r\n            else {\r\n                var n = shortestPath.length - 2, p = vg2.V[shortestPath[n]].p, q = vg2.V[shortestPath[0]].p, lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];\r\n                for (var i = n; i >= 0; --i)\r\n                    lineData.push(vg2.V[shortestPath[i]].p);\r\n                lineData.push(cola.vpsc.makeEdgeTo(q, edge.target.innerBounds, 5));\r\n            }\r\n            //lineData.forEach((v, i) => {\r\n            //    if (i > 0) {\r\n            //        var u = lineData[i - 1];\r\n            //        this._nodes.forEach(function (node) {\r\n            //            if (node.id === getSourceIndex(d) || node.id === getTargetIndex(d)) return;\r\n            //            var ints = node.innerBounds.lineIntersections(u.x, u.y, v.x, v.y);\r\n            //            if (ints.length > 0) {\r\n            //                debugger;\r\n            //            }\r\n            //        })\r\n            //    }\r\n            //})\r\n            return lineData;\r\n        };\r\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\r\n        Layout.getSourceIndex = function (e) {\r\n            return typeof e.source === 'number' ? e.source : e.source.index;\r\n        };\r\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\r\n        Layout.getTargetIndex = function (e) {\r\n            return typeof e.target === 'number' ? e.target : e.target.index;\r\n        };\r\n        // Get a string ID for a given link.\r\n        Layout.linkId = function (e) {\r\n            return Layout.getSourceIndex(e) + \"-\" + Layout.getTargetIndex(e);\r\n        };\r\n        // The fixed property has three bits:\r\n        // Bit 1 can be set externally (e.g., d.fixed = true) and show persist.\r\n        // Bit 2 stores the dragging state, from mousedown to mouseup.\r\n        // Bit 3 stores the hover state, from mouseover to mouseout.\r\n        Layout.dragStart = function (d) {\r\n            if (isGroup(d)) {\r\n                Layout.storeOffset(d, Layout.dragOrigin(d));\r\n            }\r\n            else {\r\n                Layout.stopNode(d);\r\n                d.fixed |= 2; // set bit 2\r\n            }\r\n        };\r\n        // we clobber any existing desired positions for nodes\r\n        // in case another tick event occurs before the drag\r\n        Layout.stopNode = function (v) {\r\n            v.px = v.x;\r\n            v.py = v.y;\r\n        };\r\n        // we store offsets for each node relative to the centre of the ancestor group \r\n        // being dragged in a pair of properties on the node\r\n        Layout.storeOffset = function (d, origin) {\r\n            if (typeof d.leaves !== 'undefined') {\r\n                d.leaves.forEach(function (v) {\r\n                    v.fixed |= 2;\r\n                    Layout.stopNode(v);\r\n                    v._dragGroupOffsetX = v.x - origin.x;\r\n                    v._dragGroupOffsetY = v.y - origin.y;\r\n                });\r\n            }\r\n            if (typeof d.groups !== 'undefined') {\r\n                d.groups.forEach(function (g) { return Layout.storeOffset(g, origin); });\r\n            }\r\n        };\r\n        // the drag origin is taken as the centre of the node or group\r\n        Layout.dragOrigin = function (d) {\r\n            if (isGroup(d)) {\r\n                return {\r\n                    x: d.bounds.cx(),\r\n                    y: d.bounds.cy()\r\n                };\r\n            }\r\n            else {\r\n                return d;\r\n            }\r\n        };\r\n        // for groups, the drag translation is propagated down to all of the children of\r\n        // the group.\r\n        Layout.drag = function (d, position) {\r\n            if (isGroup(d)) {\r\n                if (typeof d.leaves !== 'undefined') {\r\n                    d.leaves.forEach(function (v) {\r\n                        d.bounds.setXCentre(position.x);\r\n                        d.bounds.setYCentre(position.y);\r\n                        v.px = v._dragGroupOffsetX + position.x;\r\n                        v.py = v._dragGroupOffsetY + position.y;\r\n                    });\r\n                }\r\n                if (typeof d.groups !== 'undefined') {\r\n                    d.groups.forEach(function (g) { return Layout.drag(g, position); });\r\n                }\r\n            }\r\n            else {\r\n                d.px = position.x;\r\n                d.py = position.y;\r\n            }\r\n        };\r\n        // we unset only bits 2 and 3 so that the user can fix nodes with another a different\r\n        // bit such that the lock persists between drags \r\n        Layout.dragEnd = function (d) {\r\n            if (isGroup(d)) {\r\n                if (typeof d.leaves !== 'undefined') {\r\n                    d.leaves.forEach(function (v) {\r\n                        Layout.dragEnd(v);\r\n                        delete v._dragGroupOffsetX;\r\n                        delete v._dragGroupOffsetY;\r\n                    });\r\n                }\r\n                if (typeof d.groups !== 'undefined') {\r\n                    d.groups.forEach(Layout.dragEnd);\r\n                }\r\n            }\r\n            else {\r\n                d.fixed &= ~6; // unset bits 2 and 3\r\n            }\r\n        };\r\n        // in d3 hover temporarily locks nodes, currently not used in cola\r\n        Layout.mouseOver = function (d) {\r\n            d.fixed |= 4; // set bit 3\r\n            d.px = d.x, d.py = d.y; // set velocity to zero\r\n        };\r\n        // in d3 hover temporarily locks nodes, currently not used in cola\r\n        Layout.mouseOut = function (d) {\r\n            d.fixed &= ~4; // unset bit 3\r\n        };\r\n        return Layout;\r\n    })();\r\n    cola.Layout = Layout;\r\n})(cola || (cola = {}));\r\n///<reference path=\"../extern/d3.d.ts\"/>\r\n///<reference path=\"layout.ts\"/>\r\nvar cola;\r\n(function (cola) {\r\n    var D3StyleLayoutAdaptor = (function (_super) {\r\n        __extends(D3StyleLayoutAdaptor, _super);\r\n        function D3StyleLayoutAdaptor() {\r\n            _super.call(this);\r\n            this.event = d3.dispatch(cola.EventType[cola.EventType.start], cola.EventType[cola.EventType.tick], cola.EventType[cola.EventType.end]);\r\n            // bit of trickyness remapping 'this' so we can reference it in the function body.\r\n            var d3layout = this;\r\n            var drag;\r\n            this.drag = function () {\r\n                if (!drag) {\r\n                    var drag = d3.behavior.drag()\r\n                        .origin(cola.Layout.dragOrigin)\r\n                        .on(\"dragstart.d3adaptor\", cola.Layout.dragStart)\r\n                        .on(\"drag.d3adaptor\", function (d) {\r\n                        cola.Layout.drag(d, d3.event);\r\n                        d3layout.resume(); // restart annealing\r\n                    })\r\n                        .on(\"dragend.d3adaptor\", cola.Layout.dragEnd);\r\n                }\r\n                if (!arguments.length)\r\n                    return drag;\r\n                // this is the context of the function, i.e. the d3 selection\r\n                this //.on(\"mouseover.adaptor\", colaMouseover)\r\n                    .call(drag);\r\n            };\r\n        }\r\n        D3StyleLayoutAdaptor.prototype.trigger = function (e) {\r\n            var d3event = { type: cola.EventType[e.type], alpha: e.alpha, stress: e.stress };\r\n            this.event[d3event.type](d3event); // via d3 dispatcher, e.g. event.start(e);\r\n        };\r\n        // iterate layout using a d3.timer, which queues calls to tick repeatedly until tick returns true\r\n        D3StyleLayoutAdaptor.prototype.kick = function () {\r\n            var _this = this;\r\n            d3.timer(function () { return _super.prototype.tick.call(_this); });\r\n        };\r\n        // a function for binding to events on the adapter\r\n        D3StyleLayoutAdaptor.prototype.on = function (eventType, listener) {\r\n            if (typeof eventType === 'string') {\r\n                this.event.on(eventType, listener);\r\n            }\r\n            else {\r\n                this.event.on(cola.EventType[eventType], listener);\r\n            }\r\n            return this;\r\n        };\r\n        return D3StyleLayoutAdaptor;\r\n    })(cola.Layout);\r\n    cola.D3StyleLayoutAdaptor = D3StyleLayoutAdaptor;\r\n    /**\r\n     * provides an interface for use with d3:\r\n     * - uses the d3 event system to dispatch layout events such as:\r\n     *   o \"start\" (start layout process)\r\n     *   o \"tick\" (after each layout iteration)\r\n     *   o \"end\" (layout converged and complete).\r\n     * - uses the d3 timer to queue layout iterations.\r\n     * - sets up d3.behavior.drag to drag nodes\r\n     *   o use `node.call(<the returned instance of Layout>.drag)` to make nodes draggable\r\n     * returns an instance of the cola.Layout itself with which the user\r\n     * can interact directly.\r\n     */\r\n    function d3adaptor() {\r\n        return new D3StyleLayoutAdaptor();\r\n    }\r\n    cola.d3adaptor = d3adaptor;\r\n})(cola || (cola = {}));\r\n/// <reference path=\"rectangle.ts\"/>\r\n/// <reference path=\"shortestpaths.ts\"/>\r\n/// <reference path=\"geom.ts\"/>\r\n/// <reference path=\"vpsc.ts\"/>\r\nvar cola;\r\n(function (cola) {\r\n    var NodeWrapper = (function () {\r\n        function NodeWrapper(id, rect, children) {\r\n            this.id = id;\r\n            this.rect = rect;\r\n            this.children = children;\r\n            this.leaf = typeof children === 'undefined' || children.length === 0;\r\n        }\r\n        return NodeWrapper;\r\n    })();\r\n    cola.NodeWrapper = NodeWrapper;\r\n    var Vert = (function () {\r\n        function Vert(id, x, y, node, line) {\r\n            if (node === void 0) { node = null; }\r\n            if (line === void 0) { line = null; }\r\n            this.id = id;\r\n            this.x = x;\r\n            this.y = y;\r\n            this.node = node;\r\n            this.line = line;\r\n        }\r\n        return Vert;\r\n    })();\r\n    cola.Vert = Vert;\r\n    var LongestCommonSubsequence = (function () {\r\n        function LongestCommonSubsequence(s, t) {\r\n            this.s = s;\r\n            this.t = t;\r\n            var mf = LongestCommonSubsequence.findMatch(s, t);\r\n            var tr = t.slice(0).reverse();\r\n            var mr = LongestCommonSubsequence.findMatch(s, tr);\r\n            if (mf.length >= mr.length) {\r\n                this.length = mf.length;\r\n                this.si = mf.si;\r\n                this.ti = mf.ti;\r\n                this.reversed = false;\r\n            }\r\n            else {\r\n                this.length = mr.length;\r\n                this.si = mr.si;\r\n                this.ti = t.length - mr.ti - mr.length;\r\n                this.reversed = true;\r\n            }\r\n        }\r\n        LongestCommonSubsequence.findMatch = function (s, t) {\r\n            var m = s.length;\r\n            var n = t.length;\r\n            var match = { length: 0, si: -1, ti: -1 };\r\n            var l = new Array(m);\r\n            for (var i = 0; i < m; i++) {\r\n                l[i] = new Array(n);\r\n                for (var j = 0; j < n; j++)\r\n                    if (s[i] === t[j]) {\r\n                        var v = l[i][j] = (i === 0 || j === 0) ? 1 : l[i - 1][j - 1] + 1;\r\n                        if (v > match.length) {\r\n                            match.length = v;\r\n                            match.si = i - v + 1;\r\n                            match.ti = j - v + 1;\r\n                        }\r\n                        ;\r\n                    }\r\n                    else\r\n                        l[i][j] = 0;\r\n            }\r\n            return match;\r\n        };\r\n        LongestCommonSubsequence.prototype.getSequence = function () {\r\n            return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];\r\n        };\r\n        return LongestCommonSubsequence;\r\n    })();\r\n    cola.LongestCommonSubsequence = LongestCommonSubsequence;\r\n    var GridRouter = (function () {\r\n        function GridRouter(originalnodes, accessor, groupPadding) {\r\n            var _this = this;\r\n            if (groupPadding === void 0) { groupPadding = 12; }\r\n            this.originalnodes = originalnodes;\r\n            this.groupPadding = groupPadding;\r\n            this.leaves = null;\r\n            this.nodes = originalnodes.map(function (v, i) { return new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v)); });\r\n            this.leaves = this.nodes.filter(function (v) { return v.leaf; });\r\n            this.groups = this.nodes.filter(function (g) { return !g.leaf; });\r\n            this.cols = this.getGridLines('x');\r\n            this.rows = this.getGridLines('y');\r\n            // create parents for each node or group that is a member of another's children \r\n            this.groups.forEach(function (v) {\r\n                return v.children.forEach(function (c) { return _this.nodes[c].parent = v; });\r\n            });\r\n            // root claims the remaining orphans\r\n            this.root = { children: [] };\r\n            this.nodes.forEach(function (v) {\r\n                if (typeof v.parent === 'undefined') {\r\n                    v.parent = _this.root;\r\n                    _this.root.children.push(v.id);\r\n                }\r\n                // each node will have grid vertices associated with it,\r\n                // some inside the node and some on the boundary\r\n                // leaf nodes will have exactly one internal node at the center\r\n                // and four boundary nodes\r\n                // groups will have potentially many of each\r\n                v.ports = [];\r\n            });\r\n            // nodes ordered by their position in the group hierarchy\r\n            this.backToFront = this.nodes.slice(0);\r\n            this.backToFront.sort(function (x, y) { return _this.getDepth(x) - _this.getDepth(y); });\r\n            // compute boundary rectangles for each group\r\n            // has to be done from front to back, i.e. inside groups to outside groups\r\n            // such that each can be made large enough to enclose its interior\r\n            var frontToBackGroups = this.backToFront.slice(0).reverse().filter(function (g) { return !g.leaf; });\r\n            frontToBackGroups.forEach(function (v) {\r\n                var r = cola.vpsc.Rectangle.empty();\r\n                v.children.forEach(function (c) { return r = r.union(_this.nodes[c].rect); });\r\n                v.rect = r.inflate(_this.groupPadding);\r\n            });\r\n            var colMids = this.midPoints(this.cols.map(function (r) { return r.pos; }));\r\n            var rowMids = this.midPoints(this.rows.map(function (r) { return r.pos; }));\r\n            // setup extents of lines\r\n            var rowx = colMids[0], rowX = colMids[colMids.length - 1];\r\n            var coly = rowMids[0], colY = rowMids[rowMids.length - 1];\r\n            // horizontal lines\r\n            var hlines = this.rows.map(function (r) { return { x1: rowx, x2: rowX, y1: r.pos, y2: r.pos }; })\r\n                .concat(rowMids.map(function (m) { return { x1: rowx, x2: rowX, y1: m, y2: m }; }));\r\n            // vertical lines\r\n            var vlines = this.cols.map(function (c) { return { x1: c.pos, x2: c.pos, y1: coly, y2: colY }; })\r\n                .concat(colMids.map(function (m) { return { x1: m, x2: m, y1: coly, y2: colY }; }));\r\n            // the full set of lines\r\n            var lines = hlines.concat(vlines);\r\n            // we record the vertices associated with each line\r\n            lines.forEach(function (l) { return l.verts = []; });\r\n            // the routing graph\r\n            this.verts = [];\r\n            this.edges = [];\r\n            // create vertices at the crossings of horizontal and vertical grid-lines\r\n            hlines.forEach(function (h) {\r\n                return vlines.forEach(function (v) {\r\n                    var p = new Vert(_this.verts.length, v.x1, h.y1);\r\n                    h.verts.push(p);\r\n                    v.verts.push(p);\r\n                    _this.verts.push(p);\r\n                    // assign vertices to the nodes immediately under them\r\n                    var i = _this.backToFront.length;\r\n                    while (i-- > 0) {\r\n                        var node = _this.backToFront[i], r = node.rect;\r\n                        var dx = Math.abs(p.x - r.cx()), dy = Math.abs(p.y - r.cy());\r\n                        if (dx < r.width() / 2 && dy < r.height() / 2) {\r\n                            p.node = node;\r\n                            break;\r\n                        }\r\n                    }\r\n                });\r\n            });\r\n            lines.forEach(function (l, li) {\r\n                // create vertices at the intersections of nodes and lines\r\n                _this.nodes.forEach(function (v, i) {\r\n                    v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach(function (intersect, j) {\r\n                        //console.log(li+','+i+','+j+':'+intersect.x + ',' + intersect.y);\r\n                        var p = new Vert(_this.verts.length, intersect.x, intersect.y, v, l);\r\n                        _this.verts.push(p);\r\n                        l.verts.push(p);\r\n                        v.ports.push(p);\r\n                    });\r\n                });\r\n                // split lines into edges joining vertices\r\n                var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;\r\n                var delta = function (a, b) { return isHoriz ? b.x - a.x : b.y - a.y; };\r\n                l.verts.sort(delta);\r\n                for (var i = 1; i < l.verts.length; i++) {\r\n                    var u = l.verts[i - 1], v = l.verts[i];\r\n                    if (u.node && u.node === v.node && u.node.leaf)\r\n                        continue;\r\n                    _this.edges.push({ source: u.id, target: v.id, length: Math.abs(delta(u, v)) });\r\n                }\r\n            });\r\n        }\r\n        GridRouter.prototype.avg = function (a) { return a.reduce(function (x, y) { return x + y; }) / a.length; };\r\n        // in the given axis, find sets of leaves overlapping in that axis\r\n        // center of each GridLine is average of all nodes in column\r\n        GridRouter.prototype.getGridLines = function (axis) {\r\n            var columns = [];\r\n            var ls = this.leaves.slice(0, this.leaves.length);\r\n            while (ls.length > 0) {\r\n                // find a column of all leaves overlapping in axis with the first leaf\r\n                var overlapping = ls.filter(function (v) { return v.rect['overlap' + axis.toUpperCase()](ls[0].rect); });\r\n                var col = {\r\n                    nodes: overlapping,\r\n                    pos: this.avg(overlapping.map(function (v) { return v.rect['c' + axis](); }))\r\n                };\r\n                columns.push(col);\r\n                col.nodes.forEach(function (v) { return ls.splice(ls.indexOf(v), 1); });\r\n            }\r\n            columns.sort(function (a, b) { return a.pos - b.pos; });\r\n            return columns;\r\n        };\r\n        // get the depth of the given node in the group hierarchy\r\n        GridRouter.prototype.getDepth = function (v) {\r\n            var depth = 0;\r\n            while (v.parent !== this.root) {\r\n                depth++;\r\n                v = v.parent;\r\n            }\r\n            return depth;\r\n        };\r\n        // medial axes between node centres and also boundary lines for the grid\r\n        GridRouter.prototype.midPoints = function (a) {\r\n            var gap = a[1] - a[0];\r\n            var mids = [a[0] - gap / 2];\r\n            for (var i = 1; i < a.length; i++) {\r\n                mids.push((a[i] + a[i - 1]) / 2);\r\n            }\r\n            mids.push(a[a.length - 1] + gap / 2);\r\n            return mids;\r\n        };\r\n        // find path from v to root including both v and root\r\n        GridRouter.prototype.findLineage = function (v) {\r\n            var lineage = [v];\r\n            do {\r\n                v = v.parent;\r\n                lineage.push(v);\r\n            } while (v !== this.root);\r\n            return lineage.reverse();\r\n        };\r\n        // find path connecting a and b through their lowest common ancestor\r\n        GridRouter.prototype.findAncestorPathBetween = function (a, b) {\r\n            var aa = this.findLineage(a), ba = this.findLineage(b), i = 0;\r\n            while (aa[i] === ba[i])\r\n                i++;\r\n            // i-1 to include common ancestor only once (as first element)\r\n            return { commonAncestor: aa[i - 1], lineages: aa.slice(i).concat(ba.slice(i)) };\r\n        };\r\n        // when finding a path between two nodes a and b, siblings of a and b on the\r\n        // paths from a and b to their least common ancestor are obstacles\r\n        GridRouter.prototype.siblingObstacles = function (a, b) {\r\n            var _this = this;\r\n            var path = this.findAncestorPathBetween(a, b);\r\n            var lineageLookup = {};\r\n            path.lineages.forEach(function (v) { return lineageLookup[v.id] = {}; });\r\n            var obstacles = path.commonAncestor.children.filter(function (v) { return !(v in lineageLookup); });\r\n            path.lineages\r\n                .filter(function (v) { return v.parent !== path.commonAncestor; })\r\n                .forEach(function (v) { return obstacles = obstacles.concat(v.parent.children.filter(function (c) { return c !== v.id; })); });\r\n            return obstacles.map(function (v) { return _this.nodes[v]; });\r\n        };\r\n        // for the given routes, extract all the segments orthogonal to the axis x\r\n        // and return all them grouped by x position\r\n        GridRouter.getSegmentSets = function (routes, x, y) {\r\n            // vsegments is a list of vertical segments sorted by x position\r\n            var vsegments = [];\r\n            for (var ei = 0; ei < routes.length; ei++) {\r\n                var route = routes[ei];\r\n                for (var si = 0; si < route.length; si++) {\r\n                    var s = route[si];\r\n                    s.edgeid = ei;\r\n                    s.i = si;\r\n                    var sdx = s[1][x] - s[0][x];\r\n                    if (Math.abs(sdx) < 0.1) {\r\n                        vsegments.push(s);\r\n                    }\r\n                }\r\n            }\r\n            vsegments.sort(function (a, b) { return a[0][x] - b[0][x]; });\r\n            // vsegmentsets is a set of sets of segments grouped by x position\r\n            var vsegmentsets = [];\r\n            var segmentset = null;\r\n            for (var i = 0; i < vsegments.length; i++) {\r\n                var s = vsegments[i];\r\n                if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {\r\n                    segmentset = { pos: s[0][x], segments: [] };\r\n                    vsegmentsets.push(segmentset);\r\n                }\r\n                segmentset.segments.push(s);\r\n            }\r\n            return vsegmentsets;\r\n        };\r\n        // for all segments in this bundle create a vpsc problem such that\r\n        // each segment's x position is a variable and separation constraints \r\n        // are given by the partial order over the edges to which the segments belong\r\n        // for each pair s1,s2 of segments in the open set:\r\n        //   e1 = edge of s1, e2 = edge of s2\r\n        //   if leftOf(e1,e2) create constraint s1.x + gap <= s2.x\r\n        //   else if leftOf(e2,e1) create cons. s2.x + gap <= s1.x\r\n        GridRouter.nudgeSegs = function (x, y, routes, segments, leftOf, gap) {\r\n            var n = segments.length;\r\n            if (n <= 1)\r\n                return;\r\n            var vs = segments.map(function (s) { return new cola.vpsc.Variable(s[0][x]); });\r\n            var cs = [];\r\n            for (var i = 0; i < n; i++) {\r\n                for (var j = 0; j < n; j++) {\r\n                    if (i === j)\r\n                        continue;\r\n                    var s1 = segments[i], s2 = segments[j], e1 = s1.edgeid, e2 = s2.edgeid, lind = -1, rind = -1;\r\n                    // in page coordinates (not cartesian) the notion of 'leftof' is flipped in the horizontal axis from the vertical axis\r\n                    // that is, when nudging vertical segments, if they increase in the y(conj) direction the segment belonging to the\r\n                    // 'left' edge actually needs to be nudged to the right\r\n                    // when nudging horizontal segments, if the segments increase in the x direction\r\n                    // then the 'left' segment needs to go higher, i.e. to have y pos less than that of the right\r\n                    if (x == 'x') {\r\n                        if (leftOf(e1, e2)) {\r\n                            //console.log('s1: ' + s1[0][x] + ',' + s1[0][y] + '-' + s1[1][x] + ',' + s1[1][y]);\r\n                            if (s1[0][y] < s1[1][y]) {\r\n                                lind = j, rind = i;\r\n                            }\r\n                            else {\r\n                                lind = i, rind = j;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (leftOf(e1, e2)) {\r\n                            if (s1[0][y] < s1[1][y]) {\r\n                                lind = i, rind = j;\r\n                            }\r\n                            else {\r\n                                lind = j, rind = i;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (lind >= 0) {\r\n                        //console.log(x+' constraint: ' + lind + '<' + rind);\r\n                        cs.push(new cola.vpsc.Constraint(vs[lind], vs[rind], gap));\r\n                    }\r\n                }\r\n            }\r\n            var solver = new cola.vpsc.Solver(vs, cs);\r\n            solver.solve();\r\n            vs.forEach(function (v, i) {\r\n                var s = segments[i];\r\n                var pos = v.position();\r\n                s[0][x] = s[1][x] = pos;\r\n                var route = routes[s.edgeid];\r\n                if (s.i > 0)\r\n                    route[s.i - 1][1][x] = pos;\r\n                if (s.i < route.length - 1)\r\n                    route[s.i + 1][0][x] = pos;\r\n            });\r\n        };\r\n        GridRouter.nudgeSegments = function (routes, x, y, leftOf, gap) {\r\n            var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);\r\n            // scan the grouped (by x) segment sets to find co-linear bundles\r\n            for (var i = 0; i < vsegmentsets.length; i++) {\r\n                var ss = vsegmentsets[i];\r\n                var events = [];\r\n                for (var j = 0; j < ss.segments.length; j++) {\r\n                    var s = ss.segments[j];\r\n                    events.push({ type: 0, s: s, pos: Math.min(s[0][y], s[1][y]) });\r\n                    events.push({ type: 1, s: s, pos: Math.max(s[0][y], s[1][y]) });\r\n                }\r\n                events.sort(function (a, b) { return a.pos - b.pos + a.type - b.type; });\r\n                var open = [];\r\n                var openCount = 0;\r\n                events.forEach(function (e) {\r\n                    if (e.type === 0) {\r\n                        open.push(e.s);\r\n                        openCount++;\r\n                    }\r\n                    else {\r\n                        openCount--;\r\n                    }\r\n                    if (openCount == 0) {\r\n                        GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);\r\n                        open = [];\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        // obtain routes for the specified edges, nicely nudged apart\r\n        // warning: edge paths may be reversed such that common paths are ordered consistently within bundles!\r\n        // @param edges list of edges\r\n        // @param nudgeGap how much to space parallel edge segements\r\n        // @param source function to retrieve the index of the source node for a given edge\r\n        // @param target function to retrieve the index of the target node for a given edge\r\n        // @returns an array giving, for each edge, an array of segments, each segment a pair of points in an array\r\n        GridRouter.prototype.routeEdges = function (edges, nudgeGap, source, target) {\r\n            var _this = this;\r\n            var routePaths = edges.map(function (e) { return _this.route(source(e), target(e)); });\r\n            var order = cola.GridRouter.orderEdges(routePaths);\r\n            var routes = routePaths.map(function (e) { return cola.GridRouter.makeSegments(e); });\r\n            cola.GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);\r\n            cola.GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);\r\n            cola.GridRouter.unreverseEdges(routes, routePaths);\r\n            return routes;\r\n        };\r\n        // path may have been reversed by the subsequence processing in orderEdges\r\n        // so now we need to restore the original order\r\n        GridRouter.unreverseEdges = function (routes, routePaths) {\r\n            routes.forEach(function (segments, i) {\r\n                var path = routePaths[i];\r\n                if (path.reversed) {\r\n                    segments.reverse(); // reverse order of segments\r\n                    segments.forEach(function (segment) {\r\n                        segment.reverse(); // reverse each segment\r\n                    });\r\n                }\r\n            });\r\n        };\r\n        GridRouter.angleBetween2Lines = function (line1, line2) {\r\n            var angle1 = Math.atan2(line1[0].y - line1[1].y, line1[0].x - line1[1].x);\r\n            var angle2 = Math.atan2(line2[0].y - line2[1].y, line2[0].x - line2[1].x);\r\n            var diff = angle1 - angle2;\r\n            if (diff > Math.PI || diff < -Math.PI) {\r\n                diff = angle2 - angle1;\r\n            }\r\n            return diff;\r\n        };\r\n        // does the path a-b-c describe a left turn?\r\n        GridRouter.isLeft = function (a, b, c) {\r\n            return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) <= 0;\r\n        };\r\n        // for the given list of ordered pairs, returns a function that (efficiently) looks-up a specific pair to\r\n        // see if it exists in the list\r\n        GridRouter.getOrder = function (pairs) {\r\n            var outgoing = {};\r\n            for (var i = 0; i < pairs.length; i++) {\r\n                var p = pairs[i];\r\n                if (typeof outgoing[p.l] === 'undefined')\r\n                    outgoing[p.l] = {};\r\n                outgoing[p.l][p.r] = true;\r\n            }\r\n            return function (l, r) { return typeof outgoing[l] !== 'undefined' && outgoing[l][r]; };\r\n        };\r\n        // returns an ordering (a lookup function) that determines the correct order to nudge the\r\n        // edge paths apart to minimize crossings\r\n        GridRouter.orderEdges = function (edges) {\r\n            var edgeOrder = [];\r\n            for (var i = 0; i < edges.length - 1; i++) {\r\n                for (var j = i + 1; j < edges.length; j++) {\r\n                    var e = edges[i], f = edges[j], lcs = new cola.LongestCommonSubsequence(e, f);\r\n                    var u, vi, vj;\r\n                    if (lcs.length === 0)\r\n                        continue; // no common subpath\r\n                    if (lcs.reversed) {\r\n                        // if we found a common subpath but one of the edges runs the wrong way, \r\n                        // then reverse f.\r\n                        f.reverse();\r\n                        f.reversed = true;\r\n                        lcs = new cola.LongestCommonSubsequence(e, f);\r\n                    }\r\n                    if ((lcs.si <= 0 || lcs.ti <= 0) &&\r\n                        (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {\r\n                        // the paths do not diverge, so make an arbitrary ordering decision\r\n                        edgeOrder.push({ l: i, r: j });\r\n                        continue;\r\n                    }\r\n                    if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {\r\n                        // if the common subsequence of the\r\n                        // two edges being considered goes all the way to the\r\n                        // end of one (or both) of the lines then we have to \r\n                        // base our ordering decision on the other end of the\r\n                        // common subsequence\r\n                        u = e[lcs.si + 1];\r\n                        vj = e[lcs.si - 1];\r\n                        vi = f[lcs.ti - 1];\r\n                    }\r\n                    else {\r\n                        u = e[lcs.si + lcs.length - 2];\r\n                        vi = e[lcs.si + lcs.length];\r\n                        vj = f[lcs.ti + lcs.length];\r\n                    }\r\n                    if (GridRouter.isLeft(u, vi, vj)) {\r\n                        edgeOrder.push({ l: j, r: i });\r\n                    }\r\n                    else {\r\n                        edgeOrder.push({ l: i, r: j });\r\n                    }\r\n                }\r\n            }\r\n            //edgeOrder.forEach(function (e) { console.log('l:' + e.l + ',r:' + e.r) });\r\n            return cola.GridRouter.getOrder(edgeOrder);\r\n        };\r\n        // for an orthogonal path described by a sequence of points, create a list of segments\r\n        // if consecutive segments would make a straight line they are merged into a single segment\r\n        // segments are over cloned points, not the original vertices\r\n        GridRouter.makeSegments = function (path) {\r\n            function copyPoint(p) {\r\n                return { x: p.x, y: p.y };\r\n            }\r\n            var isStraight = function (a, b, c) { return Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001; };\r\n            var segments = [];\r\n            var a = copyPoint(path[0]);\r\n            for (var i = 1; i < path.length; i++) {\r\n                var b = copyPoint(path[i]), c = i < path.length - 1 ? path[i + 1] : null;\r\n                if (!c || !isStraight(a, b, c)) {\r\n                    segments.push([a, b]);\r\n                    a = b;\r\n                }\r\n            }\r\n            return segments;\r\n        };\r\n        // find a route between node s and node t\r\n        // returns an array of indices to verts\r\n        GridRouter.prototype.route = function (s, t) {\r\n            var _this = this;\r\n            var source = this.nodes[s], target = this.nodes[t];\r\n            this.obstacles = this.siblingObstacles(source, target);\r\n            var obstacleLookup = {};\r\n            this.obstacles.forEach(function (o) { return obstacleLookup[o.id] = o; });\r\n            this.passableEdges = this.edges.filter(function (e) {\r\n                var u = _this.verts[e.source], v = _this.verts[e.target];\r\n                return !(u.node && u.node.id in obstacleLookup\r\n                    || v.node && v.node.id in obstacleLookup);\r\n            });\r\n            // add dummy segments linking ports inside source and target\r\n            for (var i = 1; i < source.ports.length; i++) {\r\n                var u = source.ports[0].id;\r\n                var v = source.ports[i].id;\r\n                this.passableEdges.push({\r\n                    source: u,\r\n                    target: v,\r\n                    length: 0\r\n                });\r\n            }\r\n            for (var i = 1; i < target.ports.length; i++) {\r\n                var u = target.ports[0].id;\r\n                var v = target.ports[i].id;\r\n                this.passableEdges.push({\r\n                    source: u,\r\n                    target: v,\r\n                    length: 0\r\n                });\r\n            }\r\n            var getSource = function (e) { return e.source; }, getTarget = function (e) { return e.target; }, getLength = function (e) { return e.length; };\r\n            var shortestPathCalculator = new cola.shortestpaths.Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);\r\n            var bendPenalty = function (u, v, w) {\r\n                var a = _this.verts[u], b = _this.verts[v], c = _this.verts[w];\r\n                var dx = Math.abs(c.x - a.x), dy = Math.abs(c.y - a.y);\r\n                // don't count bends from internal node edges\r\n                if (a.node === source && a.node === b.node || b.node === target && b.node === c.node)\r\n                    return 0;\r\n                return dx > 1 && dy > 1 ? 1000 : 0;\r\n            };\r\n            // get shortest path\r\n            var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(source.ports[0].id, target.ports[0].id, bendPenalty);\r\n            // shortest path is reversed and does not include the target port\r\n            var pathPoints = shortestPath.reverse().map(function (vi) { return _this.verts[vi]; });\r\n            pathPoints.push(this.nodes[target.id].ports[0]);\r\n            // filter out any extra end points that are inside the source or target (i.e. the dummy segments above)\r\n            return pathPoints.filter(function (v, i) {\r\n                return !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source\r\n                    || i > 0 && v.node === target && pathPoints[i - 1].node === target);\r\n            });\r\n        };\r\n        GridRouter.getRoutePath = function (route, cornerradius, arrowwidth, arrowheight) {\r\n            var result = {\r\n                routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',\r\n                arrowpath: ''\r\n            };\r\n            if (route.length > 1) {\r\n                for (var i = 0; i < route.length; i++) {\r\n                    var li = route[i];\r\n                    var x = li[1].x, y = li[1].y;\r\n                    var dx = x - li[0].x;\r\n                    var dy = y - li[0].y;\r\n                    if (i < route.length - 1) {\r\n                        if (Math.abs(dx) > 0) {\r\n                            x -= dx / Math.abs(dx) * cornerradius;\r\n                        }\r\n                        else {\r\n                            y -= dy / Math.abs(dy) * cornerradius;\r\n                        }\r\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\r\n                        var l = route[i + 1];\r\n                        var x0 = l[0].x, y0 = l[0].y;\r\n                        var x1 = l[1].x;\r\n                        var y1 = l[1].y;\r\n                        dx = x1 - x0;\r\n                        dy = y1 - y0;\r\n                        var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;\r\n                        //console.log(cola.GridRouter.angleBetween2Lines(li, l))\r\n                        var x2, y2;\r\n                        if (Math.abs(dx) > 0) {\r\n                            x2 = x0 + dx / Math.abs(dx) * cornerradius;\r\n                            y2 = y0;\r\n                        }\r\n                        else {\r\n                            x2 = x0;\r\n                            y2 = y0 + dy / Math.abs(dy) * cornerradius;\r\n                        }\r\n                        var cx = Math.abs(x2 - x);\r\n                        var cy = Math.abs(y2 - y);\r\n                        result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';\r\n                    }\r\n                    else {\r\n                        var arrowtip = [x, y];\r\n                        var arrowcorner1, arrowcorner2;\r\n                        if (Math.abs(dx) > 0) {\r\n                            x -= dx / Math.abs(dx) * arrowheight;\r\n                            arrowcorner1 = [x, y + arrowwidth];\r\n                            arrowcorner2 = [x, y - arrowwidth];\r\n                        }\r\n                        else {\r\n                            y -= dy / Math.abs(dy) * arrowheight;\r\n                            arrowcorner1 = [x + arrowwidth, y];\r\n                            arrowcorner2 = [x - arrowwidth, y];\r\n                        }\r\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\r\n                        if (arrowheight > 0) {\r\n                            result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\r\n                                + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                var li = route[0];\r\n                var x = li[1].x, y = li[1].y;\r\n                var dx = x - li[0].x;\r\n                var dy = y - li[0].y;\r\n                var arrowtip = [x, y];\r\n                var arrowcorner1, arrowcorner2;\r\n                if (Math.abs(dx) > 0) {\r\n                    x -= dx / Math.abs(dx) * arrowheight;\r\n                    arrowcorner1 = [x, y + arrowwidth];\r\n                    arrowcorner2 = [x, y - arrowwidth];\r\n                }\r\n                else {\r\n                    y -= dy / Math.abs(dy) * arrowheight;\r\n                    arrowcorner1 = [x + arrowwidth, y];\r\n                    arrowcorner2 = [x - arrowwidth, y];\r\n                }\r\n                result.routepath += 'L ' + x + ' ' + y + ' ';\r\n                if (arrowheight > 0) {\r\n                    result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\r\n                        + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        return GridRouter;\r\n    })();\r\n    cola.GridRouter = GridRouter;\r\n})(cola || (cola = {}));\r\n/**\r\n * Use cola to do a layout in 3D!! Yay.\r\n * Pretty simple for the moment.\r\n */\r\nvar cola;\r\n(function (cola) {\r\n    var Link3D = (function () {\r\n        function Link3D(source, target) {\r\n            this.source = source;\r\n            this.target = target;\r\n        }\r\n        Link3D.prototype.actualLength = function (x) {\r\n            var _this = this;\r\n            return Math.sqrt(x.reduce(function (c, v) {\r\n                var dx = v[_this.target] - v[_this.source];\r\n                return c + dx * dx;\r\n            }, 0));\r\n        };\r\n        return Link3D;\r\n    })();\r\n    cola.Link3D = Link3D;\r\n    var Node3D = (function () {\r\n        function Node3D(x, y, z) {\r\n            if (x === void 0) { x = 0; }\r\n            if (y === void 0) { y = 0; }\r\n            if (z === void 0) { z = 0; }\r\n            this.x = x;\r\n            this.y = y;\r\n            this.z = z;\r\n        }\r\n        return Node3D;\r\n    })();\r\n    cola.Node3D = Node3D;\r\n    var Layout3D = (function () {\r\n        function Layout3D(nodes, links, idealLinkLength) {\r\n            var _this = this;\r\n            if (idealLinkLength === void 0) { idealLinkLength = 1; }\r\n            this.nodes = nodes;\r\n            this.links = links;\r\n            this.idealLinkLength = idealLinkLength;\r\n            this.constraints = null;\r\n            this.useJaccardLinkLengths = true;\r\n            this.result = new Array(Layout3D.k);\r\n            for (var i = 0; i < Layout3D.k; ++i) {\r\n                this.result[i] = new Array(nodes.length);\r\n            }\r\n            nodes.forEach(function (v, i) {\r\n                for (var _i = 0, _a = Layout3D.dims; _i < _a.length; _i++) {\r\n                    var dim = _a[_i];\r\n                    if (typeof v[dim] == 'undefined')\r\n                        v[dim] = Math.random();\r\n                }\r\n                _this.result[0][i] = v.x;\r\n                _this.result[1][i] = v.y;\r\n                _this.result[2][i] = v.z;\r\n            });\r\n        }\r\n        ;\r\n        Layout3D.prototype.linkLength = function (l) {\r\n            return l.actualLength(this.result);\r\n        };\r\n        Layout3D.prototype.start = function (iterations) {\r\n            var _this = this;\r\n            if (iterations === void 0) { iterations = 100; }\r\n            var n = this.nodes.length;\r\n            var linkAccessor = new LinkAccessor();\r\n            if (this.useJaccardLinkLengths)\r\n                cola.jaccardLinkLengths(this.links, linkAccessor, 1.5);\r\n            this.links.forEach(function (e) { return e.length *= _this.idealLinkLength; });\r\n            // Create the distance matrix that Cola needs\r\n            var distanceMatrix = (new cola.shortestpaths.Calculator(n, this.links, function (e) { return e.source; }, function (e) { return e.target; }, function (e) { return e.length; })).DistanceMatrix();\r\n            var D = cola.Descent.createSquareMatrix(n, function (i, j) { return distanceMatrix[i][j]; });\r\n            // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\r\n            // otherwise 2.\r\n            var G = cola.Descent.createSquareMatrix(n, function () { return 2; });\r\n            this.links.forEach(function (_a) {\r\n                var source = _a.source, target = _a.target;\r\n                return G[source][target] = G[target][source] = 1;\r\n            });\r\n            this.descent = new cola.Descent(this.result, D);\r\n            this.descent.threshold = 1e-3;\r\n            this.descent.G = G;\r\n            //let constraints = this.links.map(e=> <any>{\r\n            //    axis: 'y', left: e.source, right: e.target, gap: e.length*1.5\r\n            //});\r\n            if (this.constraints)\r\n                this.descent.project = new cola.vpsc.Projection(this.nodes, null, null, this.constraints).projectFunctions();\r\n            for (var i = 0; i < this.nodes.length; i++) {\r\n                var v = this.nodes[i];\r\n                if (v.fixed) {\r\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);\r\n                }\r\n            }\r\n            this.descent.run(iterations);\r\n            return this;\r\n        };\r\n        Layout3D.prototype.tick = function () {\r\n            this.descent.locks.clear();\r\n            for (var i = 0; i < this.nodes.length; i++) {\r\n                var v = this.nodes[i];\r\n                if (v.fixed) {\r\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);\r\n                }\r\n            }\r\n            return this.descent.rungeKutta();\r\n        };\r\n        Layout3D.dims = ['x', 'y', 'z'];\r\n        Layout3D.k = Layout3D.dims.length;\r\n        return Layout3D;\r\n    })();\r\n    cola.Layout3D = Layout3D;\r\n    var LinkAccessor = (function () {\r\n        function LinkAccessor() {\r\n        }\r\n        LinkAccessor.prototype.getSourceIndex = function (e) { return e.source; };\r\n        LinkAccessor.prototype.getTargetIndex = function (e) { return e.target; };\r\n        LinkAccessor.prototype.getLength = function (e) { return e.length; };\r\n        LinkAccessor.prototype.setLength = function (e, l) { e.length = l; };\r\n        return LinkAccessor;\r\n    })();\r\n})(cola || (cola = {}));\r\n/**\r\n * When compiled, this file will build a CommonJS module for WebCola.\r\n *\r\n * Unfortunately, internal and external TypeScript modules do not get\r\n * along well. This method of converting internal modules to external\r\n * modules is a bit of a hack, but is minimally invasive (i.e., no modules\r\n * need to be rewritten as external modules and modules can still span\r\n * multiple files)\r\n *\r\n * When starting a new project from scratch where CommonJS compatibility\r\n * is desired, consider instead preferring external modules to internal\r\n * modules.\r\n */\r\n///<reference path=\"./src/d3adaptor.ts\"/>\r\n///<reference path=\"./src/descent.ts\"/>\r\n///<reference path=\"./src/geom.ts\"/>\r\n///<reference path=\"./src/gridrouter.ts\"/>\r\n///<reference path=\"./src/handledisconnected.ts\"/>\r\n///<reference path=\"./src/layout.ts\"/>\r\n///<reference path=\"./src/layout3d.ts\"/>\r\n///<reference path=\"./src/linklengths.ts\"/>\r\n///<reference path=\"./src/powergraph.ts\"/>\r\n///<reference path=\"./src/pqueue.ts\"/>\r\n///<reference path=\"./src/rectangle.ts\"/>\r\n///<reference path=\"./src/shortestpaths.ts\"/>\r\n///<reference path=\"./src/vpsc.ts\"/>\r\n///<reference path=\"./src/rbtree.ts\"/>\r\n// Export cola as a CommonJS module. Note that we're bypassing TypeScript's external\r\n// module system here. Because internal modules were written with the browser in mind,\r\n// TypeScript's model is that the current context is the global context (i.e., window.cola\r\n// === cola), so `export = cola` is transpiled as a no-op.\r\nmodule.exports = cola;\r\n","exports.name = \"meteor-node-stubs\";\nexports.version = \"0.2.1\";\nexports.main = \"index.js\";\n","var map = require(\"./map.json\");\nvar meteorAliases = {};\n\nObject.keys(map).forEach(function (id) {\n  if (typeof map[id] === \"string\") {\n    try {\n      exports[id] = meteorAliases[id + \".js\"] =\n        require.resolve(map[id]);\n    } catch (e) {\n      // Resolution can fail at runtime if the stub was not included in the\n      // bundle because nothing depended on it.\n    }\n  } else {\n    exports[id] = map[id];\n    meteorAliases[id + \".js\"] = function(){};\n  }\n});\n\nif (typeof meteorInstall === \"function\") {\n  meteorInstall({\n    // Install the aliases into a node_modules directory one level up from\n    // the root directory, so that they do not clutter the namespace\n    // available to apps and packages.\n    \"..\": {\n      node_modules: meteorAliases\n    }\n  });\n}\n","module.exports = {\n  \"assert\": \"assert/\",\n  \"buffer\": \"buffer/\",\n  \"child_process\": null,\n  \"cluster\": null,\n  \"console\": \"console-browserify\",\n  \"constants\": \"constants-browserify\",\n  \"crypto\": \"crypto-browserify\",\n  \"dgram\": null,\n  \"dns\": null,\n  \"domain\": \"domain-browser\",\n  \"events\": \"events/\",\n  \"fs\": null,\n  \"http\": \"http-browserify\",\n  \"https\": \"https-browserify\",\n  \"module\": null,\n  \"net\": null,\n  \"os\": \"os-browserify/browser.js\",\n  \"path\": \"path-browserify\",\n  \"process\": \"process/browser.js\",\n  \"punycode\": \"punycode/\",\n  \"querystring\": \"querystring-es3/\",\n  \"readline\": null,\n  \"repl\": null,\n  \"stream\": \"stream-browserify\",\n  \"_stream_duplex\": \"readable-stream/duplex.js\",\n  \"_stream_passthrough\": \"readable-stream/passthrough.js\",\n  \"_stream_readable\": \"readable-stream/readable.js\",\n  \"_stream_transform\": \"readable-stream/transform.js\",\n  \"_stream_writable\": \"readable-stream/writable.js\",\n  \"string_decoder\": \"string_decoder/\",\n  \"sys\": \"util/util.js\",\n  \"timers\": \"timers-browserify\",\n  \"tls\": null,\n  \"tty\": \"tty-browserify\",\n  \"url\": \"url/\",\n  \"util\": \"util/util.js\",\n  \"vm\": \"vm-browserify\",\n  \"zlib\": \"browserify-zlib\"\n};\n","require(\"buffer/\");\n","require(\"process/browser.js\");\n","require(\"domain-browser\");\n","exports.name = \"buffer\";\nexports.version = \"4.5.0\";\nexports.main = \"index.js\";\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    this.length = 0\n    this.parent = undefined\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(array)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n} else {\n  // pre-set for values that may exist in the future\n  Buffer.prototype.length = undefined\n  Buffer.prototype.parent = undefined\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n","exports.name = \"base64-js\";\nexports.version = \"1.0.4\";\nexports.main = \"lib/b64.js\";\n",";(function (exports) {\n  'use strict'\n\n  var i\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n  var lookup = []\n  for (i = 0; i < code.length; i++) {\n    lookup[i] = code[i]\n  }\n  var revLookup = []\n\n  for (i = 0; i < code.length; ++i) {\n    revLookup[code.charCodeAt(i)] = i\n  }\n  revLookup['-'.charCodeAt(0)] = 62\n  revLookup['_'.charCodeAt(0)] = 63\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n  function decode (elt) {\n    var v = revLookup[elt.charCodeAt(0)]\n    return v !== undefined ? v : -1\n  }\n\n  function b64ToByteArray (b64) {\n    var i, j, l, tmp, placeHolders, arr\n\n    if (b64.length % 4 > 0) {\n      throw new Error('Invalid string. Length must be a multiple of 4')\n    }\n\n    // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n    var len = b64.length\n    placeHolders = b64.charAt(len - 2) === '=' ? 2 : b64.charAt(len - 1) === '=' ? 1 : 0\n\n    // base64 is 4/3 + up to two characters of the original data\n    arr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n    // if there are placeholders, only get up to the last complete 4 chars\n    l = placeHolders > 0 ? b64.length - 4 : b64.length\n\n    var L = 0\n\n    function push (v) {\n      arr[L++] = v\n    }\n\n    for (i = 0, j = 0; i < l; i += 4, j += 3) {\n      tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n      push((tmp & 0xFF0000) >> 16)\n      push((tmp & 0xFF00) >> 8)\n      push(tmp & 0xFF)\n    }\n\n    if (placeHolders === 2) {\n      tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n      push(tmp & 0xFF)\n    } else if (placeHolders === 1) {\n      tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n      push((tmp >> 8) & 0xFF)\n      push(tmp & 0xFF)\n    }\n\n    return arr\n  }\n\n  function encode (num) {\n    return lookup[num]\n  }\n\n  function tripletToBase64 (num) {\n    return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n  }\n\n  function encodeChunk (uint8, start, end) {\n    var temp\n    var output = []\n    for (var i = start; i < end; i += 3) {\n      temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n      output.push(tripletToBase64(temp))\n    }\n    return output.join('')\n  }\n\n  function uint8ToBase64 (uint8) {\n    var i\n    var extraBytes = uint8.length % 3 // if we have 1 byte left, pad 2 bytes\n    var output = ''\n    var parts = []\n    var temp, length\n    var maxChunkLength = 16383 // must be multiple of 3\n\n    // go through the array every three bytes, we'll deal with trailing stuff later\n\n    for (i = 0, length = uint8.length - extraBytes; i < length; i += maxChunkLength) {\n      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > length ? length : (i + maxChunkLength)))\n    }\n\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    switch (extraBytes) {\n      case 1:\n        temp = uint8[uint8.length - 1]\n        output += encode(temp >> 2)\n        output += encode((temp << 4) & 0x3F)\n        output += '=='\n        break\n      case 2:\n        temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n        output += encode(temp >> 10)\n        output += encode((temp >> 4) & 0x3F)\n        output += encode((temp << 2) & 0x3F)\n        output += '='\n        break\n      default:\n        break\n    }\n\n    parts.push(output)\n\n    return parts.join('')\n  }\n\n  exports.toByteArray = b64ToByteArray\n  exports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n","exports.name = \"ieee754\";\nexports.version = \"1.1.6\";\nexports.main = \"index.js\";\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","exports.name = \"isarray\";\nexports.version = \"1.0.0\";\nexports.main = \"index.js\";\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","exports.name = \"domain-browser\";\nexports.version = \"1.1.7\";\nexports.main = \"./index.js\";\n","// This file should be ES5 compatible\n/* eslint prefer-spread:0, no-var:0, prefer-reflect:0, no-magic-numbers:0 */\n'use strict'\nmodule.exports = (function () {\n\t// Import Events\n\tvar events = require('events')\n\n\t// Export Domain\n\tvar domain = {}\n\tdomain.createDomain = domain.create = function () {\n\t\tvar d = new events.EventEmitter()\n\n\t\tfunction emitError (e) {\n\t\t\td.emit('error', e)\n\t\t}\n\n\t\td.add = function (emitter) {\n\t\t\temitter.on('error', emitError)\n\t\t}\n\t\td.remove = function (emitter) {\n\t\t\temitter.removeListener('error', emitError)\n\t\t}\n\t\td.bind = function (fn) {\n\t\t\treturn function () {\n\t\t\t\tvar args = Array.prototype.slice.call(arguments)\n\t\t\t\ttry {\n\t\t\t\t\tfn.apply(null, args)\n\t\t\t\t}\n\t\t\t\tcatch (err) {\n\t\t\t\t\temitError(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td.intercept = function (fn) {\n\t\t\treturn function (err) {\n\t\t\t\tif ( err ) {\n\t\t\t\t\temitError(err)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments, 1)\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfn.apply(null, args)\n\t\t\t\t\t}\n\t\t\t\t\tcatch (err) {\n\t\t\t\t\t\temitError(err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td.run = function (fn) {\n\t\t\ttry {\n\t\t\t\tfn()\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\temitError(err)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\t\td.dispose = function () {\n\t\t\tthis.removeAllListeners()\n\t\t\treturn this\n\t\t}\n\t\td.enter = d.exit = function () {\n\t\t\treturn this\n\t\t}\n\t\treturn d\n\t}\n\treturn domain\n}).call(this)\n","exports.name = \"events\";\nexports.version = \"1.1.0\";\nexports.main = \"./events.js\";\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n"]}}]