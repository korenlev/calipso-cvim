{"version":3,"sources":["meteor://ðŸ’»app/packages/modules/server.js","meteor://ðŸ’»app/packages/modules/buffer.js","meteor://ðŸ’»app/packages/modules/install-packages.js","meteor://ðŸ’»app/packages/modules/process.js","meteor://ðŸ’»app/node_modules/webcola/package.json","meteor://ðŸ’»app/node_modules/webcola/WebCola/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1BA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/modules.js","sourcesContent":["require(\"./install-packages.js\");\nrequire(\"./buffer.js\");\nrequire(\"./process.js\");\n","try {\n  Buffer = global.Buffer || require(\"buffer\").Buffer;\n} catch (noBuffer) {}\n","function install(name) {\n  var meteorDir = {};\n\n  // Given a package name <name>, install a stub module in the\n  // /node_modules/meteor directory called <name>.js, so that\n  // require.resolve(\"meteor/<name>\") will always return\n  // /node_modules/meteor/<name>.js instead of something like\n  // /node_modules/meteor/<name>/index.js, in the rare but possible event\n  // that the package contains a file called index.js (#6590).\n  meteorDir[name + \".js\"] = function (r, e, module) {\n    module.exports = Package[name];\n  };\n\n  meteorInstall({\n    node_modules: {\n      meteor: meteorDir\n    }\n  });\n}\n\n// This file will be modified during computeJsOutputFilesMap to include\n// install(<name>) calls for every Meteor package.\n\ninstall(\"underscore\");\ninstall(\"meteor\");\ninstall(\"meteor-base\");\ninstall(\"mobile-experience\");\ninstall(\"npm-mongo\");\ninstall(\"babel-compiler\");\ninstall(\"ecmascript\");\ninstall(\"base64\");\ninstall(\"ejson\");\ninstall(\"id-map\");\ninstall(\"ordered-dict\");\ninstall(\"tracker\");\ninstall(\"modules-runtime\");\ninstall(\"modules\");\ninstall(\"es5-shim\");\ninstall(\"promise\");\ninstall(\"ecmascript-runtime\");\ninstall(\"babel-runtime\");\ninstall(\"random\");\ninstall(\"mongo-id\");\ninstall(\"diff-sequence\");\ninstall(\"geojson-utils\");\ninstall(\"minimongo\");\ninstall(\"check\");\ninstall(\"retry\");\ninstall(\"ddp-common\");\ninstall(\"ddp-client\");\ninstall(\"rate-limit\");\ninstall(\"ddp-rate-limiter\");\ninstall(\"logging\");\ninstall(\"routepolicy\");\ninstall(\"deps\");\ninstall(\"htmljs\");\ninstall(\"html-tools\");\ninstall(\"blaze-tools\");\ninstall(\"spacebars-compiler\");\ninstall(\"jquery\");\ninstall(\"observe-sequence\");\ninstall(\"reactive-var\");\ninstall(\"blaze\");\ninstall(\"spacebars\");\ninstall(\"ui\");\ninstall(\"boilerplate-generator\");\ninstall(\"webapp-hashing\");\ninstall(\"webapp\");\ninstall(\"callback-hook\");\ninstall(\"ddp-server\");\ninstall(\"ddp\");\ninstall(\"allow-deny\");\ninstall(\"binary-heap\");\ninstall(\"mongo\");\ninstall(\"blaze-html-templates\");\ninstall(\"session\");\ninstall(\"url\");\ninstall(\"http\");\ninstall(\"templating\");\ninstall(\"iron:core\");\ninstall(\"iron:dynamic-template\");\ninstall(\"iron:layout\");\ninstall(\"iron:url\");\ninstall(\"iron:middleware-stack\");\ninstall(\"iron:location\");\ninstall(\"reactive-dict\");\ninstall(\"iron:controller\");\ninstall(\"iron:router\");\ninstall(\"twbs:bootstrap\");\ninstall(\"d3js:d3\");\ninstall(\"standard-minifier-css\");\ninstall(\"standard-minifier-js\");\ninstall(\"limemakers:three\");\ninstall(\"pcel:loading\");\ninstall(\"spectrum:material-design-lite\");\ninstall(\"timmyg:wow\");\ninstall(\"accounts-ui\");\ninstall(\"npm-bcrypt\");\ninstall(\"accounts-base\");\ninstall(\"sha\");\ninstall(\"srp\");\ninstall(\"email\");\ninstall(\"accounts-password\");\ninstall(\"livedata\");\ninstall(\"hot-code-push\");\ninstall(\"launch-screen\");\ninstall(\"autoupdate\");\ninstall(\"reload\");\ninstall(\"service-configuration\");\n","try {\n  // The application can run `npm install process` to provide its own\n  // process stub; otherwise this module will provide a partial stub.\n  process = global.process || require(\"process\");\n} catch (noProcess) {\n  process = {};\n}\n\nif (Meteor.isServer) {\n  // Make require(\"process\") work on the server in all versions of Node.\n  meteorInstall({\n    node_modules: {\n      \"process.js\": function (r, e, module) {\n        module.exports = process;\n      }\n    }\n  });\n} else {\n  process.platform = \"browser\";\n  process.nextTick = process.nextTick || Meteor._setImmediate;\n}\n\nif (typeof process.env !== \"object\") {\n  process.env = {};\n}\n\n_.extend(process.env, meteorEnv);\n","exports.name = \"webcola\";\nexports.version = \"3.1.3\";\nexports.main = \"WebCola/index.js\";\n","var cola;\r\n(function (cola) {\r\n    var packingOptions = {\r\n        PADDING: 10,\r\n        GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,\r\n        FLOAT_EPSILON: 0.0001,\r\n        MAX_INERATIONS: 100\r\n    };\r\n    // assign x, y to nodes while using box packing algorithm for disconnected graphs\r\n    function applyPacking(graphs, w, h, node_size, desired_ratio) {\r\n        if (desired_ratio === void 0) { desired_ratio = 1; }\r\n        var init_x = 0, init_y = 0, svg_width = w, svg_height = h, desired_ratio = typeof desired_ratio !== 'undefined' ? desired_ratio : 1, node_size = typeof node_size !== 'undefined' ? node_size : 0, real_width = 0, real_height = 0, min_width = 0, global_bottom = 0, line = [];\r\n        if (graphs.length == 0)\r\n            return;\r\n        /// that would take care of single nodes problem\r\n        // graphs.forEach(function (g) {\r\n        //     if (g.array.length == 1) {\r\n        //         g.array[0].x = 0;\r\n        //         g.array[0].y = 0;\r\n        //     }\r\n        // });\r\n        calculate_bb(graphs);\r\n        apply(graphs, desired_ratio);\r\n        put_nodes_to_right_positions(graphs);\r\n        // get bounding boxes for all separate graphs\r\n        function calculate_bb(graphs) {\r\n            graphs.forEach(function (g) {\r\n                calculate_single_bb(g);\r\n            });\r\n            function calculate_single_bb(graph) {\r\n                var min_x = Number.MAX_VALUE, min_y = Number.MAX_VALUE, max_x = 0, max_y = 0;\r\n                graph.array.forEach(function (v) {\r\n                    var w = typeof v.width !== 'undefined' ? v.width : node_size;\r\n                    var h = typeof v.height !== 'undefined' ? v.height : node_size;\r\n                    w /= 2;\r\n                    h /= 2;\r\n                    max_x = Math.max(v.x + w, max_x);\r\n                    min_x = Math.min(v.x - w, min_x);\r\n                    max_y = Math.max(v.y + h, max_y);\r\n                    min_y = Math.min(v.y - h, min_y);\r\n                });\r\n                graph.width = max_x - min_x;\r\n                graph.height = max_y - min_y;\r\n            }\r\n        }\r\n        //function plot(data, left, right, opt_x, opt_y) {\r\n        //    // plot the cost function\r\n        //    var plot_svg = d3.select(\"body\").append(\"svg\")\r\n        //        .attr(\"width\", function () { return 2 * (right - left); })\r\n        //        .attr(\"height\", 200);\r\n        //    var x = d3.time.scale().range([0, 2 * (right - left)]);\r\n        //    var xAxis = d3.svg.axis().scale(x).orient(\"bottom\");\r\n        //    plot_svg.append(\"g\").attr(\"class\", \"x axis\")\r\n        //        .attr(\"transform\", \"translate(0, 199)\")\r\n        //        .call(xAxis);\r\n        //    var lastX = 0;\r\n        //    var lastY = 0;\r\n        //    var value = 0;\r\n        //    for (var r = left; r < right; r += 1) {\r\n        //        value = step(data, r);\r\n        //        // value = 1;\r\n        //        plot_svg.append(\"line\").attr(\"x1\", 2 * (lastX - left))\r\n        //            .attr(\"y1\", 200 - 30 * lastY)\r\n        //            .attr(\"x2\", 2 * r - 2 * left)\r\n        //            .attr(\"y2\", 200 - 30 * value)\r\n        //            .style(\"stroke\", \"rgb(6,120,155)\");\r\n        //        lastX = r;\r\n        //        lastY = value;\r\n        //    }\r\n        //    plot_svg.append(\"circle\").attr(\"cx\", 2 * opt_x - 2 * left).attr(\"cy\", 200 - 30 * opt_y)\r\n        //        .attr(\"r\", 5).style('fill', \"rgba(0,0,0,0.5)\");\r\n        //}\r\n        // actual assigning of position to nodes\r\n        function put_nodes_to_right_positions(graphs) {\r\n            graphs.forEach(function (g) {\r\n                // calculate current graph center:\r\n                var center = { x: 0, y: 0 };\r\n                g.array.forEach(function (node) {\r\n                    center.x += node.x;\r\n                    center.y += node.y;\r\n                });\r\n                center.x /= g.array.length;\r\n                center.y /= g.array.length;\r\n                // calculate current top left corner:\r\n                var corner = { x: center.x - g.width / 2, y: center.y - g.height / 2 };\r\n                var offset = { x: g.x - corner.x + svg_width / 2 - real_width / 2, y: g.y - corner.y + svg_height / 2 - real_height / 2 };\r\n                // put nodes:\r\n                g.array.forEach(function (node) {\r\n                    node.x += offset.x;\r\n                    node.y += offset.y;\r\n                });\r\n            });\r\n        }\r\n        // starts box packing algorithm\r\n        // desired ratio is 1 by default\r\n        function apply(data, desired_ratio) {\r\n            var curr_best_f = Number.POSITIVE_INFINITY;\r\n            var curr_best = 0;\r\n            data.sort(function (a, b) { return b.height - a.height; });\r\n            min_width = data.reduce(function (a, b) {\r\n                return a.width < b.width ? a.width : b.width;\r\n            });\r\n            var left = x1 = min_width;\r\n            var right = x2 = get_entire_width(data);\r\n            var iterationCounter = 0;\r\n            var f_x1 = Number.MAX_VALUE;\r\n            var f_x2 = Number.MAX_VALUE;\r\n            var flag = -1; // determines which among f_x1 and f_x2 to recompute\r\n            var dx = Number.MAX_VALUE;\r\n            var df = Number.MAX_VALUE;\r\n            while ((dx > min_width) || df > packingOptions.FLOAT_EPSILON) {\r\n                if (flag != 1) {\r\n                    var x1 = right - (right - left) / packingOptions.GOLDEN_SECTION;\r\n                    var f_x1 = step(data, x1);\r\n                }\r\n                if (flag != 0) {\r\n                    var x2 = left + (right - left) / packingOptions.GOLDEN_SECTION;\r\n                    var f_x2 = step(data, x2);\r\n                }\r\n                dx = Math.abs(x1 - x2);\r\n                df = Math.abs(f_x1 - f_x2);\r\n                if (f_x1 < curr_best_f) {\r\n                    curr_best_f = f_x1;\r\n                    curr_best = x1;\r\n                }\r\n                if (f_x2 < curr_best_f) {\r\n                    curr_best_f = f_x2;\r\n                    curr_best = x2;\r\n                }\r\n                if (f_x1 > f_x2) {\r\n                    left = x1;\r\n                    x1 = x2;\r\n                    f_x1 = f_x2;\r\n                    flag = 1;\r\n                }\r\n                else {\r\n                    right = x2;\r\n                    x2 = x1;\r\n                    f_x2 = f_x1;\r\n                    flag = 0;\r\n                }\r\n                if (iterationCounter++ > 100) {\r\n                    break;\r\n                }\r\n            }\r\n            // plot(data, min_width, get_entire_width(data), curr_best, curr_best_f);\r\n            step(data, curr_best);\r\n        }\r\n        // one iteration of the optimization method\r\n        // (gives a proper, but not necessarily optimal packing)\r\n        function step(data, max_width) {\r\n            line = [];\r\n            real_width = 0;\r\n            real_height = 0;\r\n            global_bottom = init_y;\r\n            for (var i = 0; i < data.length; i++) {\r\n                var o = data[i];\r\n                put_rect(o, max_width);\r\n            }\r\n            return Math.abs(get_real_ratio() - desired_ratio);\r\n        }\r\n        // looking for a position to one box \r\n        function put_rect(rect, max_width) {\r\n            var parent = undefined;\r\n            for (var i = 0; i < line.length; i++) {\r\n                if ((line[i].space_left >= rect.height) && (line[i].x + line[i].width + rect.width + packingOptions.PADDING - max_width) <= packingOptions.FLOAT_EPSILON) {\r\n                    parent = line[i];\r\n                    break;\r\n                }\r\n            }\r\n            line.push(rect);\r\n            if (parent !== undefined) {\r\n                rect.x = parent.x + parent.width + packingOptions.PADDING;\r\n                rect.y = parent.bottom;\r\n                rect.space_left = rect.height;\r\n                rect.bottom = rect.y;\r\n                parent.space_left -= rect.height + packingOptions.PADDING;\r\n                parent.bottom += rect.height + packingOptions.PADDING;\r\n            }\r\n            else {\r\n                rect.y = global_bottom;\r\n                global_bottom += rect.height + packingOptions.PADDING;\r\n                rect.x = init_x;\r\n                rect.bottom = rect.y;\r\n                rect.space_left = rect.height;\r\n            }\r\n            if (rect.y + rect.height - real_height > -packingOptions.FLOAT_EPSILON)\r\n                real_height = rect.y + rect.height - init_y;\r\n            if (rect.x + rect.width - real_width > -packingOptions.FLOAT_EPSILON)\r\n                real_width = rect.x + rect.width - init_x;\r\n        }\r\n        ;\r\n        function get_entire_width(data) {\r\n            var width = 0;\r\n            data.forEach(function (d) { return width += d.width + packingOptions.PADDING; });\r\n            return width;\r\n        }\r\n        function get_real_ratio() {\r\n            return (real_width / real_height);\r\n        }\r\n    }\r\n    cola.applyPacking = applyPacking;\r\n    /**\r\n     * connected components of graph\r\n     * returns an array of {}\r\n     */\r\n    function separateGraphs(nodes, links) {\r\n        var marks = {};\r\n        var ways = {};\r\n        var graphs = [];\r\n        var clusters = 0;\r\n        for (var i = 0; i < links.length; i++) {\r\n            var link = links[i];\r\n            var n1 = link.source;\r\n            var n2 = link.target;\r\n            if (ways[n1.index])\r\n                ways[n1.index].push(n2);\r\n            else\r\n                ways[n1.index] = [n2];\r\n            if (ways[n2.index])\r\n                ways[n2.index].push(n1);\r\n            else\r\n                ways[n2.index] = [n1];\r\n        }\r\n        for (var i = 0; i < nodes.length; i++) {\r\n            var node = nodes[i];\r\n            if (marks[node.index])\r\n                continue;\r\n            explore_node(node, true);\r\n        }\r\n        function explore_node(n, is_new) {\r\n            if (marks[n.index] !== undefined)\r\n                return;\r\n            if (is_new) {\r\n                clusters++;\r\n                graphs.push({ array: [] });\r\n            }\r\n            marks[n.index] = clusters;\r\n            graphs[clusters - 1].array.push(n);\r\n            var adjacent = ways[n.index];\r\n            if (!adjacent)\r\n                return;\r\n            for (var j = 0; j < adjacent.length; j++) {\r\n                explore_node(adjacent[j], false);\r\n            }\r\n        }\r\n        return graphs;\r\n    }\r\n    cola.separateGraphs = separateGraphs;\r\n})(cola || (cola = {}));\r\nvar cola;\r\n(function (cola) {\r\n    var vpsc;\r\n    (function (vpsc) {\r\n        var PositionStats = (function () {\r\n            function PositionStats(scale) {\r\n                this.scale = scale;\r\n                this.AB = 0;\r\n                this.AD = 0;\r\n                this.A2 = 0;\r\n            }\r\n            PositionStats.prototype.addVariable = function (v) {\r\n                var ai = this.scale / v.scale;\r\n                var bi = v.offset / v.scale;\r\n                var wi = v.weight;\r\n                this.AB += wi * ai * bi;\r\n                this.AD += wi * ai * v.desiredPosition;\r\n                this.A2 += wi * ai * ai;\r\n            };\r\n            PositionStats.prototype.getPosn = function () {\r\n                return (this.AD - this.AB) / this.A2;\r\n            };\r\n            return PositionStats;\r\n        })();\r\n        vpsc.PositionStats = PositionStats;\r\n        var Constraint = (function () {\r\n            function Constraint(left, right, gap, equality) {\r\n                if (equality === void 0) { equality = false; }\r\n                this.left = left;\r\n                this.right = right;\r\n                this.gap = gap;\r\n                this.equality = equality;\r\n                this.active = false;\r\n                this.unsatisfiable = false;\r\n                this.left = left;\r\n                this.right = right;\r\n                this.gap = gap;\r\n                this.equality = equality;\r\n            }\r\n            Constraint.prototype.slack = function () {\r\n                return this.unsatisfiable ? Number.MAX_VALUE\r\n                    : this.right.scale * this.right.position() - this.gap\r\n                        - this.left.scale * this.left.position();\r\n            };\r\n            return Constraint;\r\n        })();\r\n        vpsc.Constraint = Constraint;\r\n        var Variable = (function () {\r\n            function Variable(desiredPosition, weight, scale) {\r\n                if (weight === void 0) { weight = 1; }\r\n                if (scale === void 0) { scale = 1; }\r\n                this.desiredPosition = desiredPosition;\r\n                this.weight = weight;\r\n                this.scale = scale;\r\n                this.offset = 0;\r\n            }\r\n            Variable.prototype.dfdv = function () {\r\n                return 2.0 * this.weight * (this.position() - this.desiredPosition);\r\n            };\r\n            Variable.prototype.position = function () {\r\n                return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;\r\n            };\r\n            // visit neighbours by active constraints within the same block\r\n            Variable.prototype.visitNeighbours = function (prev, f) {\r\n                var ff = function (c, next) { return c.active && prev !== next && f(c, next); };\r\n                this.cOut.forEach(function (c) { return ff(c, c.right); });\r\n                this.cIn.forEach(function (c) { return ff(c, c.left); });\r\n            };\r\n            return Variable;\r\n        })();\r\n        vpsc.Variable = Variable;\r\n        var Block = (function () {\r\n            function Block(v) {\r\n                this.vars = [];\r\n                v.offset = 0;\r\n                this.ps = new PositionStats(v.scale);\r\n                this.addVariable(v);\r\n            }\r\n            Block.prototype.addVariable = function (v) {\r\n                v.block = this;\r\n                this.vars.push(v);\r\n                this.ps.addVariable(v);\r\n                this.posn = this.ps.getPosn();\r\n            };\r\n            // move the block where it needs to be to minimize cost\r\n            Block.prototype.updateWeightedPosition = function () {\r\n                this.ps.AB = this.ps.AD = this.ps.A2 = 0;\r\n                for (var i = 0, n = this.vars.length; i < n; ++i)\r\n                    this.ps.addVariable(this.vars[i]);\r\n                this.posn = this.ps.getPosn();\r\n            };\r\n            Block.prototype.compute_lm = function (v, u, postAction) {\r\n                var _this = this;\r\n                var dfdv = v.dfdv();\r\n                v.visitNeighbours(u, function (c, next) {\r\n                    var _dfdv = _this.compute_lm(next, v, postAction);\r\n                    if (next === c.right) {\r\n                        dfdv += _dfdv * c.left.scale;\r\n                        c.lm = _dfdv;\r\n                    }\r\n                    else {\r\n                        dfdv += _dfdv * c.right.scale;\r\n                        c.lm = -_dfdv;\r\n                    }\r\n                    postAction(c);\r\n                });\r\n                return dfdv / v.scale;\r\n            };\r\n            Block.prototype.populateSplitBlock = function (v, prev) {\r\n                var _this = this;\r\n                v.visitNeighbours(prev, function (c, next) {\r\n                    next.offset = v.offset + (next === c.right ? c.gap : -c.gap);\r\n                    _this.addVariable(next);\r\n                    _this.populateSplitBlock(next, v);\r\n                });\r\n            };\r\n            // traverse the active constraint tree applying visit to each active constraint\r\n            Block.prototype.traverse = function (visit, acc, v, prev) {\r\n                var _this = this;\r\n                if (v === void 0) { v = this.vars[0]; }\r\n                if (prev === void 0) { prev = null; }\r\n                v.visitNeighbours(prev, function (c, next) {\r\n                    acc.push(visit(c));\r\n                    _this.traverse(visit, acc, next, v);\r\n                });\r\n            };\r\n            // calculate lagrangian multipliers on constraints and\r\n            // find the active constraint in this block with the smallest lagrangian.\r\n            // if the lagrangian is negative, then the constraint is a split candidate.  \r\n            Block.prototype.findMinLM = function () {\r\n                var m = null;\r\n                this.compute_lm(this.vars[0], null, function (c) {\r\n                    if (!c.equality && (m === null || c.lm < m.lm))\r\n                        m = c;\r\n                });\r\n                return m;\r\n            };\r\n            Block.prototype.findMinLMBetween = function (lv, rv) {\r\n                this.compute_lm(lv, null, function () { });\r\n                var m = null;\r\n                this.findPath(lv, null, rv, function (c, next) {\r\n                    if (!c.equality && c.right === next && (m === null || c.lm < m.lm))\r\n                        m = c;\r\n                });\r\n                return m;\r\n            };\r\n            Block.prototype.findPath = function (v, prev, to, visit) {\r\n                var _this = this;\r\n                var endFound = false;\r\n                v.visitNeighbours(prev, function (c, next) {\r\n                    if (!endFound && (next === to || _this.findPath(next, v, to, visit))) {\r\n                        endFound = true;\r\n                        visit(c, next);\r\n                    }\r\n                });\r\n                return endFound;\r\n            };\r\n            // Search active constraint tree from u to see if there is a directed path to v.\r\n            // Returns true if path is found.\r\n            Block.prototype.isActiveDirectedPathBetween = function (u, v) {\r\n                if (u === v)\r\n                    return true;\r\n                var i = u.cOut.length;\r\n                while (i--) {\r\n                    var c = u.cOut[i];\r\n                    if (c.active && this.isActiveDirectedPathBetween(c.right, v))\r\n                        return true;\r\n                }\r\n                return false;\r\n            };\r\n            // split the block into two by deactivating the specified constraint\r\n            Block.split = function (c) {\r\n                /* DEBUG\r\n                            console.log(\"split on \" + c);\r\n                            console.assert(c.active, \"attempt to split on inactive constraint\");\r\n                DEBUG */\r\n                c.active = false;\r\n                return [Block.createSplitBlock(c.left), Block.createSplitBlock(c.right)];\r\n            };\r\n            Block.createSplitBlock = function (startVar) {\r\n                var b = new Block(startVar);\r\n                b.populateSplitBlock(startVar, null);\r\n                return b;\r\n            };\r\n            // find a split point somewhere between the specified variables\r\n            Block.prototype.splitBetween = function (vl, vr) {\r\n                /* DEBUG\r\n                            console.assert(vl.block === this);\r\n                            console.assert(vr.block === this);\r\n                DEBUG */\r\n                var c = this.findMinLMBetween(vl, vr);\r\n                if (c !== null) {\r\n                    var bs = Block.split(c);\r\n                    return { constraint: c, lb: bs[0], rb: bs[1] };\r\n                }\r\n                // couldn't find a split point - for example the active path is all equality constraints\r\n                return null;\r\n            };\r\n            Block.prototype.mergeAcross = function (b, c, dist) {\r\n                c.active = true;\r\n                for (var i = 0, n = b.vars.length; i < n; ++i) {\r\n                    var v = b.vars[i];\r\n                    v.offset += dist;\r\n                    this.addVariable(v);\r\n                }\r\n                this.posn = this.ps.getPosn();\r\n            };\r\n            Block.prototype.cost = function () {\r\n                var sum = 0, i = this.vars.length;\r\n                while (i--) {\r\n                    var v = this.vars[i], d = v.position() - v.desiredPosition;\r\n                    sum += d * d * v.weight;\r\n                }\r\n                return sum;\r\n            };\r\n            return Block;\r\n        })();\r\n        vpsc.Block = Block;\r\n        var Blocks = (function () {\r\n            function Blocks(vs) {\r\n                this.vs = vs;\r\n                var n = vs.length;\r\n                this.list = new Array(n);\r\n                while (n--) {\r\n                    var b = new Block(vs[n]);\r\n                    this.list[n] = b;\r\n                    b.blockInd = n;\r\n                }\r\n            }\r\n            Blocks.prototype.cost = function () {\r\n                var sum = 0, i = this.list.length;\r\n                while (i--)\r\n                    sum += this.list[i].cost();\r\n                return sum;\r\n            };\r\n            Blocks.prototype.insert = function (b) {\r\n                /* DEBUG\r\n                            console.assert(!this.contains(b), \"blocks error: tried to reinsert block \" + b.blockInd)\r\n                DEBUG */\r\n                b.blockInd = this.list.length;\r\n                this.list.push(b);\r\n                /* DEBUG\r\n                            console.log(\"insert block: \" + b.blockInd);\r\n                            this.contains(b);\r\n                DEBUG */\r\n            };\r\n            Blocks.prototype.remove = function (b) {\r\n                /* DEBUG\r\n                            console.log(\"remove block: \" + b.blockInd);\r\n                            console.assert(this.contains(b));\r\n                DEBUG */\r\n                var last = this.list.length - 1;\r\n                var swapBlock = this.list[last];\r\n                this.list.length = last;\r\n                if (b !== swapBlock) {\r\n                    this.list[b.blockInd] = swapBlock;\r\n                    swapBlock.blockInd = b.blockInd;\r\n                }\r\n            };\r\n            // merge the blocks on either side of the specified constraint, by copying the smaller block into the larger\r\n            // and deleting the smaller.\r\n            Blocks.prototype.merge = function (c) {\r\n                var l = c.left.block, r = c.right.block;\r\n                /* DEBUG\r\n                            console.assert(l!==r, \"attempt to merge within the same block\");\r\n                DEBUG */\r\n                var dist = c.right.offset - c.left.offset - c.gap;\r\n                if (l.vars.length < r.vars.length) {\r\n                    r.mergeAcross(l, c, dist);\r\n                    this.remove(l);\r\n                }\r\n                else {\r\n                    l.mergeAcross(r, c, -dist);\r\n                    this.remove(r);\r\n                }\r\n                /* DEBUG\r\n                            console.assert(Math.abs(c.slack()) < 1e-6, \"Error: Constraint should be at equality after merge!\");\r\n                            console.log(\"merged on \" + c);\r\n                DEBUG */\r\n            };\r\n            Blocks.prototype.forEach = function (f) {\r\n                this.list.forEach(f);\r\n            };\r\n            // useful, for example, after variable desired positions change.\r\n            Blocks.prototype.updateBlockPositions = function () {\r\n                this.list.forEach(function (b) { return b.updateWeightedPosition(); });\r\n            };\r\n            // split each block across its constraint with the minimum lagrangian \r\n            Blocks.prototype.split = function (inactive) {\r\n                var _this = this;\r\n                this.updateBlockPositions();\r\n                this.list.forEach(function (b) {\r\n                    var v = b.findMinLM();\r\n                    if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {\r\n                        b = v.left.block;\r\n                        Block.split(v).forEach(function (nb) { return _this.insert(nb); });\r\n                        _this.remove(b);\r\n                        inactive.push(v);\r\n                    }\r\n                });\r\n            };\r\n            return Blocks;\r\n        })();\r\n        vpsc.Blocks = Blocks;\r\n        var Solver = (function () {\r\n            function Solver(vs, cs) {\r\n                this.vs = vs;\r\n                this.cs = cs;\r\n                this.vs = vs;\r\n                vs.forEach(function (v) {\r\n                    v.cIn = [], v.cOut = [];\r\n                    /* DEBUG\r\n                                    v.toString = () => \"v\" + vs.indexOf(v);\r\n                    DEBUG */\r\n                });\r\n                this.cs = cs;\r\n                cs.forEach(function (c) {\r\n                    c.left.cOut.push(c);\r\n                    c.right.cIn.push(c);\r\n                    /* DEBUG\r\n                                    c.toString = () => c.left + \"+\" + c.gap + \"<=\" + c.right + \" slack=\" + c.slack() + \" active=\" + c.active;\r\n                    DEBUG */\r\n                });\r\n                this.inactive = cs.map(function (c) { c.active = false; return c; });\r\n                this.bs = null;\r\n            }\r\n            Solver.prototype.cost = function () {\r\n                return this.bs.cost();\r\n            };\r\n            // set starting positions without changing desired positions.\r\n            // Note: it throws away any previous block structure.\r\n            Solver.prototype.setStartingPositions = function (ps) {\r\n                this.inactive = this.cs.map(function (c) { c.active = false; return c; });\r\n                this.bs = new Blocks(this.vs);\r\n                this.bs.forEach(function (b, i) { return b.posn = ps[i]; });\r\n            };\r\n            Solver.prototype.setDesiredPositions = function (ps) {\r\n                this.vs.forEach(function (v, i) { return v.desiredPosition = ps[i]; });\r\n            };\r\n            /* DEBUG\r\n                    private getId(v: Variable): number {\r\n                        return this.vs.indexOf(v);\r\n                    }\r\n            \r\n                    // sanity check of the index integrity of the inactive list\r\n                    checkInactive(): void {\r\n                        var inactiveCount = 0;\r\n                        this.cs.forEach(c=> {\r\n                            var i = this.inactive.indexOf(c);\r\n                            console.assert(!c.active && i >= 0 || c.active && i < 0, \"constraint should be in the inactive list if it is not active: \" + c);\r\n                            if (i >= 0) {\r\n                                inactiveCount++;\r\n                            } else {\r\n                                console.assert(c.active, \"inactive constraint not found in inactive list: \" + c);\r\n                            }\r\n                        });\r\n                        console.assert(inactiveCount === this.inactive.length, inactiveCount + \" inactive constraints found, \" + this.inactive.length + \"in inactive list\");\r\n                    }\r\n                    // after every call to satisfy the following should check should pass\r\n                    checkSatisfied(): void {\r\n                        this.cs.forEach(c=>console.assert(c.slack() >= vpsc.Solver.ZERO_UPPERBOUND, \"Error: Unsatisfied constraint! \"+c));\r\n                    }\r\n            DEBUG */\r\n            Solver.prototype.mostViolated = function () {\r\n                var minSlack = Number.MAX_VALUE, v = null, l = this.inactive, n = l.length, deletePoint = n;\r\n                for (var i = 0; i < n; ++i) {\r\n                    var c = l[i];\r\n                    if (c.unsatisfiable)\r\n                        continue;\r\n                    var slack = c.slack();\r\n                    if (c.equality || slack < minSlack) {\r\n                        minSlack = slack;\r\n                        v = c;\r\n                        deletePoint = i;\r\n                        if (c.equality)\r\n                            break;\r\n                    }\r\n                }\r\n                if (deletePoint !== n &&\r\n                    (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality)) {\r\n                    l[deletePoint] = l[n - 1];\r\n                    l.length = n - 1;\r\n                }\r\n                return v;\r\n            };\r\n            // satisfy constraints by building block structure over violated constraints\r\n            // and moving the blocks to their desired positions\r\n            Solver.prototype.satisfy = function () {\r\n                if (this.bs == null) {\r\n                    this.bs = new Blocks(this.vs);\r\n                }\r\n                /* DEBUG\r\n                            console.log(\"satisfy: \" + this.bs);\r\n                DEBUG */\r\n                this.bs.split(this.inactive);\r\n                var v = null;\r\n                while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {\r\n                    var lb = v.left.block, rb = v.right.block;\r\n                    /* DEBUG\r\n                                    console.log(\"most violated is: \" + v);\r\n                                    this.bs.contains(lb);\r\n                                    this.bs.contains(rb);\r\n                    DEBUG */\r\n                    if (lb !== rb) {\r\n                        this.bs.merge(v);\r\n                    }\r\n                    else {\r\n                        if (lb.isActiveDirectedPathBetween(v.right, v.left)) {\r\n                            // cycle found!\r\n                            v.unsatisfiable = true;\r\n                            continue;\r\n                        }\r\n                        // constraint is within block, need to split first\r\n                        var split = lb.splitBetween(v.left, v.right);\r\n                        if (split !== null) {\r\n                            this.bs.insert(split.lb);\r\n                            this.bs.insert(split.rb);\r\n                            this.bs.remove(lb);\r\n                            this.inactive.push(split.constraint);\r\n                        }\r\n                        else {\r\n                            /* DEBUG\r\n                                                    console.log(\"unsatisfiable constraint found\");\r\n                            DEBUG */\r\n                            v.unsatisfiable = true;\r\n                            continue;\r\n                        }\r\n                        if (v.slack() >= 0) {\r\n                            /* DEBUG\r\n                                                    console.log(\"violated constraint indirectly satisfied: \" + v);\r\n                            DEBUG */\r\n                            // v was satisfied by the above split!\r\n                            this.inactive.push(v);\r\n                        }\r\n                        else {\r\n                            /* DEBUG\r\n                                                    console.log(\"merge after split:\");\r\n                            DEBUG */\r\n                            this.bs.merge(v);\r\n                        }\r\n                    }\r\n                }\r\n                /* DEBUG\r\n                            this.checkSatisfied();\r\n                DEBUG */\r\n            };\r\n            // repeatedly build and split block structure until we converge to an optimal solution\r\n            Solver.prototype.solve = function () {\r\n                this.satisfy();\r\n                var lastcost = Number.MAX_VALUE, cost = this.bs.cost();\r\n                while (Math.abs(lastcost - cost) > 0.0001) {\r\n                    this.satisfy();\r\n                    lastcost = cost;\r\n                    cost = this.bs.cost();\r\n                }\r\n                return cost;\r\n            };\r\n            Solver.LAGRANGIAN_TOLERANCE = -1e-4;\r\n            Solver.ZERO_UPPERBOUND = -1e-10;\r\n            return Solver;\r\n        })();\r\n        vpsc.Solver = Solver;\r\n    })(vpsc = cola.vpsc || (cola.vpsc = {}));\r\n})(cola || (cola = {}));\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar cola;\r\n(function (cola) {\r\n    var vpsc;\r\n    (function (vpsc) {\r\n        //Based on js_es:\r\n        //\r\n        //https://github.com/vadimg/js_bintrees\r\n        //\r\n        //Copyright (C) 2011 by Vadim Graboys\r\n        //\r\n        //Permission is hereby granted, free of charge, to any person obtaining a copy\r\n        //of this software and associated documentation files (the \"Software\"), to deal\r\n        //in the Software without restriction, including without limitation the rights\r\n        //to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n        //copies of the Software, and to permit persons to whom the Software is\r\n        //furnished to do so, subject to the following conditions:\r\n        //\r\n        //The above copyright notice and this permission notice shall be included in\r\n        //all copies or substantial portions of the Software.\r\n        //\r\n        //THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n        //IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n        //FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n        //AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n        //LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n        //OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n        //THE SOFTWARE.\r\n        var TreeBase = (function () {\r\n            function TreeBase() {\r\n                // returns iterator to node if found, null otherwise\r\n                this.findIter = function (data) {\r\n                    var res = this._root;\r\n                    var iter = this.iterator();\r\n                    while (res !== null) {\r\n                        var c = this._comparator(data, res.data);\r\n                        if (c === 0) {\r\n                            iter._cursor = res;\r\n                            return iter;\r\n                        }\r\n                        else {\r\n                            iter._ancestors.push(res);\r\n                            res = res.get_child(c > 0);\r\n                        }\r\n                    }\r\n                    return null;\r\n                };\r\n            }\r\n            // removes all nodes from the tree\r\n            TreeBase.prototype.clear = function () {\r\n                this._root = null;\r\n                this.size = 0;\r\n            };\r\n            ;\r\n            // returns node data if found, null otherwise\r\n            TreeBase.prototype.find = function (data) {\r\n                var res = this._root;\r\n                while (res !== null) {\r\n                    var c = this._comparator(data, res.data);\r\n                    if (c === 0) {\r\n                        return res.data;\r\n                    }\r\n                    else {\r\n                        res = res.get_child(c > 0);\r\n                    }\r\n                }\r\n                return null;\r\n            };\r\n            ;\r\n            // Returns an interator to the tree node immediately before (or at) the element\r\n            TreeBase.prototype.lowerBound = function (data) {\r\n                return this._bound(data, this._comparator);\r\n            };\r\n            ;\r\n            // Returns an interator to the tree node immediately after (or at) the element\r\n            TreeBase.prototype.upperBound = function (data) {\r\n                var cmp = this._comparator;\r\n                function reverse_cmp(a, b) {\r\n                    return cmp(b, a);\r\n                }\r\n                return this._bound(data, reverse_cmp);\r\n            };\r\n            ;\r\n            // returns null if tree is empty\r\n            TreeBase.prototype.min = function () {\r\n                var res = this._root;\r\n                if (res === null) {\r\n                    return null;\r\n                }\r\n                while (res.left !== null) {\r\n                    res = res.left;\r\n                }\r\n                return res.data;\r\n            };\r\n            ;\r\n            // returns null if tree is empty\r\n            TreeBase.prototype.max = function () {\r\n                var res = this._root;\r\n                if (res === null) {\r\n                    return null;\r\n                }\r\n                while (res.right !== null) {\r\n                    res = res.right;\r\n                }\r\n                return res.data;\r\n            };\r\n            ;\r\n            // returns a null iterator\r\n            // call next() or prev() to point to an element\r\n            TreeBase.prototype.iterator = function () {\r\n                return new Iterator(this);\r\n            };\r\n            ;\r\n            // calls cb on each node's data, in order\r\n            TreeBase.prototype.each = function (cb) {\r\n                var it = this.iterator(), data;\r\n                while ((data = it.next()) !== null) {\r\n                    cb(data);\r\n                }\r\n            };\r\n            ;\r\n            // calls cb on each node's data, in reverse order\r\n            TreeBase.prototype.reach = function (cb) {\r\n                var it = this.iterator(), data;\r\n                while ((data = it.prev()) !== null) {\r\n                    cb(data);\r\n                }\r\n            };\r\n            ;\r\n            // used for lowerBound and upperBound\r\n            TreeBase.prototype._bound = function (data, cmp) {\r\n                var cur = this._root;\r\n                var iter = this.iterator();\r\n                while (cur !== null) {\r\n                    var c = this._comparator(data, cur.data);\r\n                    if (c === 0) {\r\n                        iter._cursor = cur;\r\n                        return iter;\r\n                    }\r\n                    iter._ancestors.push(cur);\r\n                    cur = cur.get_child(c > 0);\r\n                }\r\n                for (var i = iter._ancestors.length - 1; i >= 0; --i) {\r\n                    cur = iter._ancestors[i];\r\n                    if (cmp(data, cur.data) > 0) {\r\n                        iter._cursor = cur;\r\n                        iter._ancestors.length = i;\r\n                        return iter;\r\n                    }\r\n                }\r\n                iter._ancestors.length = 0;\r\n                return iter;\r\n            };\r\n            ;\r\n            return TreeBase;\r\n        })();\r\n        vpsc.TreeBase = TreeBase;\r\n        var Iterator = (function () {\r\n            function Iterator(tree) {\r\n                this._tree = tree;\r\n                this._ancestors = [];\r\n                this._cursor = null;\r\n            }\r\n            Iterator.prototype.data = function () {\r\n                return this._cursor !== null ? this._cursor.data : null;\r\n            };\r\n            ;\r\n            // if null-iterator, returns first node\r\n            // otherwise, returns next node\r\n            Iterator.prototype.next = function () {\r\n                if (this._cursor === null) {\r\n                    var root = this._tree._root;\r\n                    if (root !== null) {\r\n                        this._minNode(root);\r\n                    }\r\n                }\r\n                else {\r\n                    if (this._cursor.right === null) {\r\n                        // no greater node in subtree, go up to parent\r\n                        // if coming from a right child, continue up the stack\r\n                        var save;\r\n                        do {\r\n                            save = this._cursor;\r\n                            if (this._ancestors.length) {\r\n                                this._cursor = this._ancestors.pop();\r\n                            }\r\n                            else {\r\n                                this._cursor = null;\r\n                                break;\r\n                            }\r\n                        } while (this._cursor.right === save);\r\n                    }\r\n                    else {\r\n                        // get the next node from the subtree\r\n                        this._ancestors.push(this._cursor);\r\n                        this._minNode(this._cursor.right);\r\n                    }\r\n                }\r\n                return this._cursor !== null ? this._cursor.data : null;\r\n            };\r\n            ;\r\n            // if null-iterator, returns last node\r\n            // otherwise, returns previous node\r\n            Iterator.prototype.prev = function () {\r\n                if (this._cursor === null) {\r\n                    var root = this._tree._root;\r\n                    if (root !== null) {\r\n                        this._maxNode(root);\r\n                    }\r\n                }\r\n                else {\r\n                    if (this._cursor.left === null) {\r\n                        var save;\r\n                        do {\r\n                            save = this._cursor;\r\n                            if (this._ancestors.length) {\r\n                                this._cursor = this._ancestors.pop();\r\n                            }\r\n                            else {\r\n                                this._cursor = null;\r\n                                break;\r\n                            }\r\n                        } while (this._cursor.left === save);\r\n                    }\r\n                    else {\r\n                        this._ancestors.push(this._cursor);\r\n                        this._maxNode(this._cursor.left);\r\n                    }\r\n                }\r\n                return this._cursor !== null ? this._cursor.data : null;\r\n            };\r\n            ;\r\n            Iterator.prototype._minNode = function (start) {\r\n                while (start.left !== null) {\r\n                    this._ancestors.push(start);\r\n                    start = start.left;\r\n                }\r\n                this._cursor = start;\r\n            };\r\n            ;\r\n            Iterator.prototype._maxNode = function (start) {\r\n                while (start.right !== null) {\r\n                    this._ancestors.push(start);\r\n                    start = start.right;\r\n                }\r\n                this._cursor = start;\r\n            };\r\n            ;\r\n            return Iterator;\r\n        })();\r\n        vpsc.Iterator = Iterator;\r\n        var Node = (function () {\r\n            function Node(data) {\r\n                this.data = data;\r\n                this.left = null;\r\n                this.right = null;\r\n                this.red = true;\r\n            }\r\n            Node.prototype.get_child = function (dir) {\r\n                return dir ? this.right : this.left;\r\n            };\r\n            ;\r\n            Node.prototype.set_child = function (dir, val) {\r\n                if (dir) {\r\n                    this.right = val;\r\n                }\r\n                else {\r\n                    this.left = val;\r\n                }\r\n            };\r\n            ;\r\n            return Node;\r\n        })();\r\n        var RBTree = (function (_super) {\r\n            __extends(RBTree, _super);\r\n            function RBTree(comparator) {\r\n                _super.call(this);\r\n                this._root = null;\r\n                this._comparator = comparator;\r\n                this.size = 0;\r\n            }\r\n            // returns true if inserted, false if duplicate\r\n            RBTree.prototype.insert = function (data) {\r\n                var ret = false;\r\n                if (this._root === null) {\r\n                    // empty tree\r\n                    this._root = new Node(data);\r\n                    ret = true;\r\n                    this.size++;\r\n                }\r\n                else {\r\n                    var head = new Node(undefined); // fake tree root\r\n                    var dir = false;\r\n                    var last = false;\r\n                    // setup\r\n                    var gp = null; // grandparent\r\n                    var ggp = head; // grand-grand-parent\r\n                    var p = null; // parent\r\n                    var node = this._root;\r\n                    ggp.right = this._root;\r\n                    // search down\r\n                    while (true) {\r\n                        if (node === null) {\r\n                            // insert new node at the bottom\r\n                            node = new Node(data);\r\n                            p.set_child(dir, node);\r\n                            ret = true;\r\n                            this.size++;\r\n                        }\r\n                        else if (RBTree.is_red(node.left) && RBTree.is_red(node.right)) {\r\n                            // color flip\r\n                            node.red = true;\r\n                            node.left.red = false;\r\n                            node.right.red = false;\r\n                        }\r\n                        // fix red violation\r\n                        if (RBTree.is_red(node) && RBTree.is_red(p)) {\r\n                            var dir2 = ggp.right === gp;\r\n                            if (node === p.get_child(last)) {\r\n                                ggp.set_child(dir2, RBTree.single_rotate(gp, !last));\r\n                            }\r\n                            else {\r\n                                ggp.set_child(dir2, RBTree.double_rotate(gp, !last));\r\n                            }\r\n                        }\r\n                        var cmp = this._comparator(node.data, data);\r\n                        // stop if found\r\n                        if (cmp === 0) {\r\n                            break;\r\n                        }\r\n                        last = dir;\r\n                        dir = cmp < 0;\r\n                        // update helpers\r\n                        if (gp !== null) {\r\n                            ggp = gp;\r\n                        }\r\n                        gp = p;\r\n                        p = node;\r\n                        node = node.get_child(dir);\r\n                    }\r\n                    // update root\r\n                    this._root = head.right;\r\n                }\r\n                // make root black\r\n                this._root.red = false;\r\n                return ret;\r\n            };\r\n            ;\r\n            // returns true if removed, false if not found\r\n            RBTree.prototype.remove = function (data) {\r\n                if (this._root === null) {\r\n                    return false;\r\n                }\r\n                var head = new Node(undefined); // fake tree root\r\n                var node = head;\r\n                node.right = this._root;\r\n                var p = null; // parent\r\n                var gp = null; // grand parent\r\n                var found = null; // found item\r\n                var dir = true;\r\n                while (node.get_child(dir) !== null) {\r\n                    var last = dir;\r\n                    // update helpers\r\n                    gp = p;\r\n                    p = node;\r\n                    node = node.get_child(dir);\r\n                    var cmp = this._comparator(data, node.data);\r\n                    dir = cmp > 0;\r\n                    // save found node\r\n                    if (cmp === 0) {\r\n                        found = node;\r\n                    }\r\n                    // push the red node down\r\n                    if (!RBTree.is_red(node) && !RBTree.is_red(node.get_child(dir))) {\r\n                        if (RBTree.is_red(node.get_child(!dir))) {\r\n                            var sr = RBTree.single_rotate(node, dir);\r\n                            p.set_child(last, sr);\r\n                            p = sr;\r\n                        }\r\n                        else if (!RBTree.is_red(node.get_child(!dir))) {\r\n                            var sibling = p.get_child(!last);\r\n                            if (sibling !== null) {\r\n                                if (!RBTree.is_red(sibling.get_child(!last)) && !RBTree.is_red(sibling.get_child(last))) {\r\n                                    // color flip\r\n                                    p.red = false;\r\n                                    sibling.red = true;\r\n                                    node.red = true;\r\n                                }\r\n                                else {\r\n                                    var dir2 = gp.right === p;\r\n                                    if (RBTree.is_red(sibling.get_child(last))) {\r\n                                        gp.set_child(dir2, RBTree.double_rotate(p, last));\r\n                                    }\r\n                                    else if (RBTree.is_red(sibling.get_child(!last))) {\r\n                                        gp.set_child(dir2, RBTree.single_rotate(p, last));\r\n                                    }\r\n                                    // ensure correct coloring\r\n                                    var gpc = gp.get_child(dir2);\r\n                                    gpc.red = true;\r\n                                    node.red = true;\r\n                                    gpc.left.red = false;\r\n                                    gpc.right.red = false;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // replace and remove if found\r\n                if (found !== null) {\r\n                    found.data = node.data;\r\n                    p.set_child(p.right === node, node.get_child(node.left === null));\r\n                    this.size--;\r\n                }\r\n                // update root and make it black\r\n                this._root = head.right;\r\n                if (this._root !== null) {\r\n                    this._root.red = false;\r\n                }\r\n                return found !== null;\r\n            };\r\n            ;\r\n            RBTree.is_red = function (node) {\r\n                return node !== null && node.red;\r\n            };\r\n            RBTree.single_rotate = function (root, dir) {\r\n                var save = root.get_child(!dir);\r\n                root.set_child(!dir, save.get_child(dir));\r\n                save.set_child(dir, root);\r\n                root.red = true;\r\n                save.red = false;\r\n                return save;\r\n            };\r\n            RBTree.double_rotate = function (root, dir) {\r\n                root.set_child(!dir, RBTree.single_rotate(root.get_child(!dir), !dir));\r\n                return RBTree.single_rotate(root, dir);\r\n            };\r\n            return RBTree;\r\n        })(TreeBase);\r\n        vpsc.RBTree = RBTree;\r\n    })(vpsc = cola.vpsc || (cola.vpsc = {}));\r\n})(cola || (cola = {}));\r\n///<reference path=\"vpsc.ts\"/>\r\n///<reference path=\"rbtree.ts\"/>\r\nvar cola;\r\n(function (cola) {\r\n    var vpsc;\r\n    (function (vpsc) {\r\n        function computeGroupBounds(g) {\r\n            g.bounds = typeof g.leaves !== \"undefined\" ?\r\n                g.leaves.reduce(function (r, c) { return c.bounds.union(r); }, Rectangle.empty()) :\r\n                Rectangle.empty();\r\n            if (typeof g.groups !== \"undefined\")\r\n                g.bounds = g.groups.reduce(function (r, c) { return computeGroupBounds(c).union(r); }, g.bounds);\r\n            g.bounds = g.bounds.inflate(g.padding);\r\n            return g.bounds;\r\n        }\r\n        vpsc.computeGroupBounds = computeGroupBounds;\r\n        var Rectangle = (function () {\r\n            function Rectangle(x, X, y, Y) {\r\n                this.x = x;\r\n                this.X = X;\r\n                this.y = y;\r\n                this.Y = Y;\r\n            }\r\n            Rectangle.empty = function () { return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY); };\r\n            Rectangle.prototype.cx = function () { return (this.x + this.X) / 2; };\r\n            Rectangle.prototype.cy = function () { return (this.y + this.Y) / 2; };\r\n            Rectangle.prototype.overlapX = function (r) {\r\n                var ux = this.cx(), vx = r.cx();\r\n                if (ux <= vx && r.x < this.X)\r\n                    return this.X - r.x;\r\n                if (vx <= ux && this.x < r.X)\r\n                    return r.X - this.x;\r\n                return 0;\r\n            };\r\n            Rectangle.prototype.overlapY = function (r) {\r\n                var uy = this.cy(), vy = r.cy();\r\n                if (uy <= vy && r.y < this.Y)\r\n                    return this.Y - r.y;\r\n                if (vy <= uy && this.y < r.Y)\r\n                    return r.Y - this.y;\r\n                return 0;\r\n            };\r\n            Rectangle.prototype.setXCentre = function (cx) {\r\n                var dx = cx - this.cx();\r\n                this.x += dx;\r\n                this.X += dx;\r\n            };\r\n            Rectangle.prototype.setYCentre = function (cy) {\r\n                var dy = cy - this.cy();\r\n                this.y += dy;\r\n                this.Y += dy;\r\n            };\r\n            Rectangle.prototype.width = function () {\r\n                return this.X - this.x;\r\n            };\r\n            Rectangle.prototype.height = function () {\r\n                return this.Y - this.y;\r\n            };\r\n            Rectangle.prototype.union = function (r) {\r\n                return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));\r\n            };\r\n            /**\r\n             * return any intersection points between the given line and the sides of this rectangle\r\n             * @method lineIntersection\r\n             * @param x1 number first x coord of line\r\n             * @param y1 number first y coord of line\r\n             * @param x2 number second x coord of line\r\n             * @param y2 number second y coord of line\r\n             * @return any intersection points found\r\n             */\r\n            Rectangle.prototype.lineIntersections = function (x1, y1, x2, y2) {\r\n                var sides = [[this.x, this.y, this.X, this.y],\r\n                    [this.X, this.y, this.X, this.Y],\r\n                    [this.X, this.Y, this.x, this.Y],\r\n                    [this.x, this.Y, this.x, this.y]];\r\n                var intersections = [];\r\n                for (var i = 0; i < 4; ++i) {\r\n                    var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);\r\n                    if (r !== null)\r\n                        intersections.push({ x: r.x, y: r.y });\r\n                }\r\n                return intersections;\r\n            };\r\n            /**\r\n             * return any intersection points between a line extending from the centre of this rectangle to the given point,\r\n             *  and the sides of this rectangle\r\n             * @method lineIntersection\r\n             * @param x2 number second x coord of line\r\n             * @param y2 number second y coord of line\r\n             * @return any intersection points found\r\n             */\r\n            Rectangle.prototype.rayIntersection = function (x2, y2) {\r\n                var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);\r\n                return ints.length > 0 ? ints[0] : null;\r\n            };\r\n            Rectangle.prototype.vertices = function () {\r\n                return [\r\n                    { x: this.x, y: this.y },\r\n                    { x: this.X, y: this.y },\r\n                    { x: this.X, y: this.Y },\r\n                    { x: this.x, y: this.Y },\r\n                    { x: this.x, y: this.y }];\r\n            };\r\n            Rectangle.lineIntersection = function (x1, y1, x2, y2, x3, y3, x4, y4) {\r\n                var dx12 = x2 - x1, dx34 = x4 - x3, dy12 = y2 - y1, dy34 = y4 - y3, denominator = dy34 * dx12 - dx34 * dy12;\r\n                if (denominator == 0)\r\n                    return null;\r\n                var dx31 = x1 - x3, dy31 = y1 - y3, numa = dx34 * dy31 - dy34 * dx31, a = numa / denominator, numb = dx12 * dy31 - dy12 * dx31, b = numb / denominator;\r\n                if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {\r\n                    return {\r\n                        x: x1 + a * dx12,\r\n                        y: y1 + a * dy12\r\n                    };\r\n                }\r\n                return null;\r\n            };\r\n            Rectangle.prototype.inflate = function (pad) {\r\n                return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);\r\n            };\r\n            return Rectangle;\r\n        })();\r\n        vpsc.Rectangle = Rectangle;\r\n        function makeEdgeBetween(source, target, ah) {\r\n            var si = source.rayIntersection(target.cx(), target.cy()) || { x: source.cx(), y: source.cy() }, ti = target.rayIntersection(source.cx(), source.cy()) || { x: target.cx(), y: target.cy() }, dx = ti.x - si.x, dy = ti.y - si.y, l = Math.sqrt(dx * dx + dy * dy), al = l - ah;\r\n            return {\r\n                sourceIntersection: si,\r\n                targetIntersection: ti,\r\n                arrowStart: { x: si.x + al * dx / l, y: si.y + al * dy / l }\r\n            };\r\n        }\r\n        vpsc.makeEdgeBetween = makeEdgeBetween;\r\n        function makeEdgeTo(s, target, ah) {\r\n            var ti = target.rayIntersection(s.x, s.y);\r\n            if (!ti)\r\n                ti = { x: target.cx(), y: target.cy() };\r\n            var dx = ti.x - s.x, dy = ti.y - s.y, l = Math.sqrt(dx * dx + dy * dy);\r\n            return { x: ti.x - ah * dx / l, y: ti.y - ah * dy / l };\r\n        }\r\n        vpsc.makeEdgeTo = makeEdgeTo;\r\n        var Node = (function () {\r\n            function Node(v, r, pos) {\r\n                this.v = v;\r\n                this.r = r;\r\n                this.pos = pos;\r\n                this.prev = makeRBTree();\r\n                this.next = makeRBTree();\r\n            }\r\n            return Node;\r\n        })();\r\n        var Event = (function () {\r\n            function Event(isOpen, v, pos) {\r\n                this.isOpen = isOpen;\r\n                this.v = v;\r\n                this.pos = pos;\r\n            }\r\n            return Event;\r\n        })();\r\n        function compareEvents(a, b) {\r\n            if (a.pos > b.pos) {\r\n                return 1;\r\n            }\r\n            if (a.pos < b.pos) {\r\n                return -1;\r\n            }\r\n            if (a.isOpen) {\r\n                // open must come before close\r\n                return -1;\r\n            }\r\n            if (b.isOpen) {\r\n                // open must come before close\r\n                return 1;\r\n            }\r\n            return 0;\r\n        }\r\n        function makeRBTree() {\r\n            return new vpsc.RBTree(function (a, b) { return a.pos - b.pos; });\r\n        }\r\n        var xRect = {\r\n            getCentre: function (r) { return r.cx(); },\r\n            getOpen: function (r) { return r.y; },\r\n            getClose: function (r) { return r.Y; },\r\n            getSize: function (r) { return r.width(); },\r\n            makeRect: function (open, close, center, size) { return new Rectangle(center - size / 2, center + size / 2, open, close); },\r\n            findNeighbours: findXNeighbours\r\n        };\r\n        var yRect = {\r\n            getCentre: function (r) { return r.cy(); },\r\n            getOpen: function (r) { return r.x; },\r\n            getClose: function (r) { return r.X; },\r\n            getSize: function (r) { return r.height(); },\r\n            makeRect: function (open, close, center, size) { return new Rectangle(open, close, center - size / 2, center + size / 2); },\r\n            findNeighbours: findYNeighbours\r\n        };\r\n        function generateGroupConstraints(root, f, minSep, isContained) {\r\n            if (isContained === void 0) { isContained = false; }\r\n            var padding = root.padding, gn = typeof root.groups !== 'undefined' ? root.groups.length : 0, ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0, childConstraints = !gn ? []\r\n                : root.groups.reduce(function (ccs, g) { return ccs.concat(generateGroupConstraints(g, f, minSep, true)); }, []), n = (isContained ? 2 : 0) + ln + gn, vs = new Array(n), rs = new Array(n), i = 0, add = function (r, v) { rs[i] = r; vs[i++] = v; };\r\n            if (isContained) {\r\n                // if this group is contained by another, then we add two dummy vars and rectangles for the borders\r\n                var b = root.bounds, c = f.getCentre(b), s = f.getSize(b) / 2, open = f.getOpen(b), close = f.getClose(b), min = c - s + padding / 2, max = c + s - padding / 2;\r\n                root.minVar.desiredPosition = min;\r\n                add(f.makeRect(open, close, min, padding), root.minVar);\r\n                root.maxVar.desiredPosition = max;\r\n                add(f.makeRect(open, close, max, padding), root.maxVar);\r\n            }\r\n            if (ln)\r\n                root.leaves.forEach(function (l) { return add(l.bounds, l.variable); });\r\n            if (gn)\r\n                root.groups.forEach(function (g) {\r\n                    var b = g.bounds;\r\n                    add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);\r\n                });\r\n            var cs = generateConstraints(rs, vs, f, minSep);\r\n            if (gn) {\r\n                vs.forEach(function (v) { v.cOut = [], v.cIn = []; });\r\n                cs.forEach(function (c) { c.left.cOut.push(c), c.right.cIn.push(c); });\r\n                root.groups.forEach(function (g) {\r\n                    var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;\r\n                    g.minVar.cIn.forEach(function (c) { return c.gap += gapAdjustment; });\r\n                    g.minVar.cOut.forEach(function (c) { c.left = g.maxVar; c.gap += gapAdjustment; });\r\n                });\r\n            }\r\n            return childConstraints.concat(cs);\r\n        }\r\n        function generateConstraints(rs, vars, rect, minSep) {\r\n            var i, n = rs.length;\r\n            var N = 2 * n;\r\n            console.assert(vars.length >= n);\r\n            var events = new Array(N);\r\n            for (i = 0; i < n; ++i) {\r\n                var r = rs[i];\r\n                var v = new Node(vars[i], r, rect.getCentre(r));\r\n                events[i] = new Event(true, v, rect.getOpen(r));\r\n                events[i + n] = new Event(false, v, rect.getClose(r));\r\n            }\r\n            events.sort(compareEvents);\r\n            var cs = new Array();\r\n            var scanline = makeRBTree();\r\n            for (i = 0; i < N; ++i) {\r\n                var e = events[i];\r\n                var v = e.v;\r\n                if (e.isOpen) {\r\n                    scanline.insert(v);\r\n                    rect.findNeighbours(v, scanline);\r\n                }\r\n                else {\r\n                    // close event\r\n                    scanline.remove(v);\r\n                    var makeConstraint = function (l, r) {\r\n                        var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;\r\n                        cs.push(new vpsc.Constraint(l.v, r.v, sep));\r\n                    };\r\n                    var visitNeighbours = function (forward, reverse, mkcon) {\r\n                        var u, it = v[forward].iterator();\r\n                        while ((u = it[forward]()) !== null) {\r\n                            mkcon(u, v);\r\n                            u[reverse].remove(v);\r\n                        }\r\n                    };\r\n                    visitNeighbours(\"prev\", \"next\", function (u, v) { return makeConstraint(u, v); });\r\n                    visitNeighbours(\"next\", \"prev\", function (u, v) { return makeConstraint(v, u); });\r\n                }\r\n            }\r\n            console.assert(scanline.size === 0);\r\n            return cs;\r\n        }\r\n        function findXNeighbours(v, scanline) {\r\n            var f = function (forward, reverse) {\r\n                var it = scanline.findIter(v);\r\n                var u;\r\n                while ((u = it[forward]()) !== null) {\r\n                    var uovervX = u.r.overlapX(v.r);\r\n                    if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {\r\n                        v[forward].insert(u);\r\n                        u[reverse].insert(v);\r\n                    }\r\n                    if (uovervX <= 0) {\r\n                        break;\r\n                    }\r\n                }\r\n            };\r\n            f(\"next\", \"prev\");\r\n            f(\"prev\", \"next\");\r\n        }\r\n        function findYNeighbours(v, scanline) {\r\n            var f = function (forward, reverse) {\r\n                var u = scanline.findIter(v)[forward]();\r\n                if (u !== null && u.r.overlapX(v.r) > 0) {\r\n                    v[forward].insert(u);\r\n                    u[reverse].insert(v);\r\n                }\r\n            };\r\n            f(\"next\", \"prev\");\r\n            f(\"prev\", \"next\");\r\n        }\r\n        function generateXConstraints(rs, vars) {\r\n            return generateConstraints(rs, vars, xRect, 1e-6);\r\n        }\r\n        vpsc.generateXConstraints = generateXConstraints;\r\n        function generateYConstraints(rs, vars) {\r\n            return generateConstraints(rs, vars, yRect, 1e-6);\r\n        }\r\n        vpsc.generateYConstraints = generateYConstraints;\r\n        function generateXGroupConstraints(root) {\r\n            return generateGroupConstraints(root, xRect, 1e-6);\r\n        }\r\n        vpsc.generateXGroupConstraints = generateXGroupConstraints;\r\n        function generateYGroupConstraints(root) {\r\n            return generateGroupConstraints(root, yRect, 1e-6);\r\n        }\r\n        vpsc.generateYGroupConstraints = generateYGroupConstraints;\r\n        function removeOverlaps(rs) {\r\n            var vs = rs.map(function (r) { return new vpsc.Variable(r.cx()); });\r\n            var cs = vpsc.generateXConstraints(rs, vs);\r\n            var solver = new vpsc.Solver(vs, cs);\r\n            solver.solve();\r\n            vs.forEach(function (v, i) { return rs[i].setXCentre(v.position()); });\r\n            vs = rs.map(function (r) { return new vpsc.Variable(r.cy()); });\r\n            cs = vpsc.generateYConstraints(rs, vs);\r\n            solver = new vpsc.Solver(vs, cs);\r\n            solver.solve();\r\n            vs.forEach(function (v, i) { return rs[i].setYCentre(v.position()); });\r\n        }\r\n        vpsc.removeOverlaps = removeOverlaps;\r\n        var IndexedVariable = (function (_super) {\r\n            __extends(IndexedVariable, _super);\r\n            function IndexedVariable(index, w) {\r\n                _super.call(this, 0, w);\r\n                this.index = index;\r\n            }\r\n            return IndexedVariable;\r\n        })(vpsc.Variable);\r\n        vpsc.IndexedVariable = IndexedVariable;\r\n        var Projection = (function () {\r\n            function Projection(nodes, groups, rootGroup, constraints, avoidOverlaps) {\r\n                var _this = this;\r\n                if (rootGroup === void 0) { rootGroup = null; }\r\n                if (constraints === void 0) { constraints = null; }\r\n                if (avoidOverlaps === void 0) { avoidOverlaps = false; }\r\n                this.nodes = nodes;\r\n                this.groups = groups;\r\n                this.rootGroup = rootGroup;\r\n                this.avoidOverlaps = avoidOverlaps;\r\n                this.variables = nodes.map(function (v, i) {\r\n                    return v.variable = new IndexedVariable(i, 1);\r\n                });\r\n                if (constraints)\r\n                    this.createConstraints(constraints);\r\n                if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {\r\n                    nodes.forEach(function (v) {\r\n                        if (!v.width || !v.height) {\r\n                            //If undefined, default to nothing\r\n                            v.bounds = new vpsc.Rectangle(v.x, v.x, v.y, v.y);\r\n                            return;\r\n                        }\r\n                        var w2 = v.width / 2, h2 = v.height / 2;\r\n                        v.bounds = new vpsc.Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);\r\n                    });\r\n                    computeGroupBounds(rootGroup);\r\n                    var i = nodes.length;\r\n                    groups.forEach(function (g) {\r\n                        _this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\r\n                        _this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\r\n                    });\r\n                }\r\n            }\r\n            Projection.prototype.createSeparation = function (c) {\r\n                return new vpsc.Constraint(this.nodes[c.left].variable, this.nodes[c.right].variable, c.gap, typeof c.equality !== \"undefined\" ? c.equality : false);\r\n            };\r\n            Projection.prototype.makeFeasible = function (c) {\r\n                var _this = this;\r\n                if (!this.avoidOverlaps)\r\n                    return;\r\n                var axis = 'x', dim = 'width';\r\n                if (c.axis === 'x')\r\n                    axis = 'y', dim = 'height';\r\n                var vs = c.offsets.map(function (o) { return _this.nodes[o.node]; }).sort(function (a, b) { return a[axis] - b[axis]; });\r\n                var p = null;\r\n                vs.forEach(function (v) {\r\n                    if (p)\r\n                        v[axis] = p[axis] + p[dim] + 1;\r\n                    p = v;\r\n                });\r\n            };\r\n            Projection.prototype.createAlignment = function (c) {\r\n                var _this = this;\r\n                var u = this.nodes[c.offsets[0].node].variable;\r\n                this.makeFeasible(c);\r\n                var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;\r\n                c.offsets.slice(1).forEach(function (o) {\r\n                    var v = _this.nodes[o.node].variable;\r\n                    cs.push(new vpsc.Constraint(u, v, o.offset, true));\r\n                });\r\n            };\r\n            Projection.prototype.createConstraints = function (constraints) {\r\n                var _this = this;\r\n                var isSep = function (c) { return typeof c.type === 'undefined' || c.type === 'separation'; };\r\n                this.xConstraints = constraints\r\n                    .filter(function (c) { return c.axis === \"x\" && isSep(c); })\r\n                    .map(function (c) { return _this.createSeparation(c); });\r\n                this.yConstraints = constraints\r\n                    .filter(function (c) { return c.axis === \"y\" && isSep(c); })\r\n                    .map(function (c) { return _this.createSeparation(c); });\r\n                constraints\r\n                    .filter(function (c) { return c.type === 'alignment'; })\r\n                    .forEach(function (c) { return _this.createAlignment(c); });\r\n            };\r\n            Projection.prototype.setupVariablesAndBounds = function (x0, y0, desired, getDesired) {\r\n                this.nodes.forEach(function (v, i) {\r\n                    if (v.fixed) {\r\n                        v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;\r\n                        desired[i] = getDesired(v);\r\n                    }\r\n                    else {\r\n                        v.variable.weight = 1;\r\n                    }\r\n                    var w = (v.width || 0) / 2, h = (v.height || 0) / 2;\r\n                    var ix = x0[i], iy = y0[i];\r\n                    v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);\r\n                });\r\n            };\r\n            Projection.prototype.xProject = function (x0, y0, x) {\r\n                if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints))\r\n                    return;\r\n                this.project(x0, y0, x0, x, function (v) { return v.px; }, this.xConstraints, generateXGroupConstraints, function (v) { return v.bounds.setXCentre(x[v.variable.index] = v.variable.position()); }, function (g) {\r\n                    var xmin = x[g.minVar.index] = g.minVar.position();\r\n                    var xmax = x[g.maxVar.index] = g.maxVar.position();\r\n                    var p2 = g.padding / 2;\r\n                    g.bounds.x = xmin - p2;\r\n                    g.bounds.X = xmax + p2;\r\n                });\r\n            };\r\n            Projection.prototype.yProject = function (x0, y0, y) {\r\n                if (!this.rootGroup && !this.yConstraints)\r\n                    return;\r\n                this.project(x0, y0, y0, y, function (v) { return v.py; }, this.yConstraints, generateYGroupConstraints, function (v) { return v.bounds.setYCentre(y[v.variable.index] = v.variable.position()); }, function (g) {\r\n                    var ymin = y[g.minVar.index] = g.minVar.position();\r\n                    var ymax = y[g.maxVar.index] = g.maxVar.position();\r\n                    var p2 = g.padding / 2;\r\n                    g.bounds.y = ymin - p2;\r\n                    ;\r\n                    g.bounds.Y = ymax + p2;\r\n                });\r\n            };\r\n            Projection.prototype.projectFunctions = function () {\r\n                var _this = this;\r\n                return [\r\n                    function (x0, y0, x) { return _this.xProject(x0, y0, x); },\r\n                    function (x0, y0, y) { return _this.yProject(x0, y0, y); }\r\n                ];\r\n            };\r\n            Projection.prototype.project = function (x0, y0, start, desired, getDesired, cs, generateConstraints, updateNodeBounds, updateGroupBounds) {\r\n                this.setupVariablesAndBounds(x0, y0, desired, getDesired);\r\n                if (this.rootGroup && this.avoidOverlaps) {\r\n                    computeGroupBounds(this.rootGroup);\r\n                    cs = cs.concat(generateConstraints(this.rootGroup));\r\n                }\r\n                this.solve(this.variables, cs, start, desired);\r\n                this.nodes.forEach(updateNodeBounds);\r\n                if (this.rootGroup && this.avoidOverlaps) {\r\n                    this.groups.forEach(updateGroupBounds);\r\n                    computeGroupBounds(this.rootGroup);\r\n                }\r\n            };\r\n            Projection.prototype.solve = function (vs, cs, starting, desired) {\r\n                var solver = new vpsc.Solver(vs, cs);\r\n                solver.setStartingPositions(starting);\r\n                solver.setDesiredPositions(desired);\r\n                solver.solve();\r\n            };\r\n            return Projection;\r\n        })();\r\n        vpsc.Projection = Projection;\r\n    })(vpsc = cola.vpsc || (cola.vpsc = {}));\r\n})(cola || (cola = {}));\r\n///<reference path=\"vpsc.ts\"/>\r\n///<reference path=\"rectangle.ts\"/>\r\nvar cola;\r\n(function (cola) {\r\n    var geom;\r\n    (function (geom) {\r\n        var Point = (function () {\r\n            function Point() {\r\n            }\r\n            return Point;\r\n        })();\r\n        geom.Point = Point;\r\n        var LineSegment = (function () {\r\n            function LineSegment(x1, y1, x2, y2) {\r\n                this.x1 = x1;\r\n                this.y1 = y1;\r\n                this.x2 = x2;\r\n                this.y2 = y2;\r\n            }\r\n            return LineSegment;\r\n        })();\r\n        geom.LineSegment = LineSegment;\r\n        var PolyPoint = (function (_super) {\r\n            __extends(PolyPoint, _super);\r\n            function PolyPoint() {\r\n                _super.apply(this, arguments);\r\n            }\r\n            return PolyPoint;\r\n        })(Point);\r\n        geom.PolyPoint = PolyPoint;\r\n        /** tests if a point is Left|On|Right of an infinite line.\r\n         * @param points P0, P1, and P2\r\n         * @return >0 for P2 left of the line through P0 and P1\r\n         *            =0 for P2 on the line\r\n         *            <0 for P2 right of the line\r\n         */\r\n        function isLeft(P0, P1, P2) {\r\n            return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);\r\n        }\r\n        geom.isLeft = isLeft;\r\n        function above(p, vi, vj) {\r\n            return isLeft(p, vi, vj) > 0;\r\n        }\r\n        function below(p, vi, vj) {\r\n            return isLeft(p, vi, vj) < 0;\r\n        }\r\n        /**\r\n         * returns the convex hull of a set of points using Andrew's monotone chain algorithm\r\n         * see: http://geomalgorithms.com/a10-_hull-1.html#Monotone%20Chain\r\n         * @param S array of points\r\n         * @return the convex hull as an array of points\r\n         */\r\n        function ConvexHull(S) {\r\n            var P = S.slice(0).sort(function (a, b) { return a.x !== b.x ? b.x - a.x : b.y - a.y; });\r\n            var n = S.length, i;\r\n            var minmin = 0;\r\n            var xmin = P[0].x;\r\n            for (i = 1; i < n; ++i) {\r\n                if (P[i].x !== xmin)\r\n                    break;\r\n            }\r\n            var minmax = i - 1;\r\n            var H = [];\r\n            H.push(P[minmin]); // push minmin point onto stack\r\n            if (minmax === n - 1) {\r\n                if (P[minmax].y !== P[minmin].y)\r\n                    H.push(P[minmax]);\r\n            }\r\n            else {\r\n                // Get the indices of points with max x-coord and min|max y-coord\r\n                var maxmin, maxmax = n - 1;\r\n                var xmax = P[n - 1].x;\r\n                for (i = n - 2; i >= 0; i--)\r\n                    if (P[i].x !== xmax)\r\n                        break;\r\n                maxmin = i + 1;\r\n                // Compute the lower hull on the stack H\r\n                i = minmax;\r\n                while (++i <= maxmin) {\r\n                    // the lower line joins P[minmin]  with P[maxmin]\r\n                    if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin)\r\n                        continue; // ignore P[i] above or on the lower line\r\n                    while (H.length > 1) {\r\n                        // test if  P[i] is left of the line at the stack top\r\n                        if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\r\n                            break; // P[i] is a new hull  vertex\r\n                        else\r\n                            H.length -= 1; // pop top point off  stack\r\n                    }\r\n                    if (i != minmin)\r\n                        H.push(P[i]);\r\n                }\r\n                // Next, compute the upper hull on the stack H above the bottom hull\r\n                if (maxmax != maxmin)\r\n                    H.push(P[maxmax]); // push maxmax point onto stack\r\n                var bot = H.length; // the bottom point of the upper hull stack\r\n                i = maxmin;\r\n                while (--i >= minmax) {\r\n                    // the upper line joins P[maxmax]  with P[minmax]\r\n                    if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax)\r\n                        continue; // ignore P[i] below or on the upper line\r\n                    while (H.length > bot) {\r\n                        // test if  P[i] is left of the line at the stack top\r\n                        if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\r\n                            break; // P[i] is a new hull  vertex\r\n                        else\r\n                            H.length -= 1; // pop top point off  stack\r\n                    }\r\n                    if (i != minmin)\r\n                        H.push(P[i]); // push P[i] onto stack\r\n                }\r\n            }\r\n            return H;\r\n        }\r\n        geom.ConvexHull = ConvexHull;\r\n        // apply f to the points in P in clockwise order around the point p\r\n        function clockwiseRadialSweep(p, P, f) {\r\n            P.slice(0).sort(function (a, b) { return Math.atan2(a.y - p.y, a.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x); }).forEach(f);\r\n        }\r\n        geom.clockwiseRadialSweep = clockwiseRadialSweep;\r\n        function nextPolyPoint(p, ps) {\r\n            if (p.polyIndex === ps.length - 1)\r\n                return ps[0];\r\n            return ps[p.polyIndex + 1];\r\n        }\r\n        function prevPolyPoint(p, ps) {\r\n            if (p.polyIndex === 0)\r\n                return ps[ps.length - 1];\r\n            return ps[p.polyIndex - 1];\r\n        }\r\n        // tangent_PointPolyC(): fast binary search for tangents to a convex polygon\r\n        //    Input:  P = a 2D point (exterior to the polygon)\r\n        //            n = number of polygon vertices\r\n        //            V = array of vertices for a 2D convex polygon with V[n] = V[0]\r\n        //    Output: rtan = index of rightmost tangent point V[rtan]\r\n        //            ltan = index of leftmost tangent point V[ltan]\r\n        function tangent_PointPolyC(P, V) {\r\n            return { rtan: Rtangent_PointPolyC(P, V), ltan: Ltangent_PointPolyC(P, V) };\r\n        }\r\n        // Rtangent_PointPolyC(): binary search for convex polygon right tangent\r\n        //    Input:  P = a 2D point (exterior to the polygon)\r\n        //            n = number of polygon vertices\r\n        //            V = array of vertices for a 2D convex polygon with V[n] = V[0]\r\n        //    Return: index \"i\" of rightmost tangent point V[i]\r\n        function Rtangent_PointPolyC(P, V) {\r\n            var n = V.length - 1;\r\n            // use binary search for large convex polygons\r\n            var a, b, c; // indices for edge chain endpoints\r\n            var upA, dnC; // test for up direction of edges a and c\r\n            // rightmost tangent = maximum for the isLeft() ordering\r\n            // test if V[0] is a local maximum\r\n            if (below(P, V[1], V[0]) && !above(P, V[n - 1], V[0]))\r\n                return 0; // V[0] is the maximum tangent point\r\n            for (a = 0, b = n;;) {\r\n                if (b - a === 1)\r\n                    if (above(P, V[a], V[b]))\r\n                        return a;\r\n                    else\r\n                        return b;\r\n                c = Math.floor((a + b) / 2); // midpoint of [a,b], and 0<c<n\r\n                dnC = below(P, V[c + 1], V[c]);\r\n                if (dnC && !above(P, V[c - 1], V[c]))\r\n                    return c; // V[c] is the maximum tangent point\r\n                // no max yet, so continue with the binary search\r\n                // pick one of the two subchains [a,c] or [c,b]\r\n                upA = above(P, V[a + 1], V[a]);\r\n                if (upA) {\r\n                    if (dnC)\r\n                        b = c; // select [a,c]\r\n                    else {\r\n                        if (above(P, V[a], V[c]))\r\n                            b = c; // select [a,c]\r\n                        else\r\n                            a = c; // select [c,b]\r\n                    }\r\n                }\r\n                else {\r\n                    if (!dnC)\r\n                        a = c; // select [c,b]\r\n                    else {\r\n                        if (below(P, V[a], V[c]))\r\n                            b = c; // select [a,c]\r\n                        else\r\n                            a = c; // select [c,b]\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Ltangent_PointPolyC(): binary search for convex polygon left tangent\r\n        //    Input:  P = a 2D point (exterior to the polygon)\r\n        //            n = number of polygon vertices\r\n        //            V = array of vertices for a 2D convex polygon with V[n]=V[0]\r\n        //    Return: index \"i\" of leftmost tangent point V[i]\r\n        function Ltangent_PointPolyC(P, V) {\r\n            var n = V.length - 1;\r\n            // use binary search for large convex polygons\r\n            var a, b, c; // indices for edge chain endpoints\r\n            var dnA, dnC; // test for down direction of edges a and c\r\n            // leftmost tangent = minimum for the isLeft() ordering\r\n            // test if V[0] is a local minimum\r\n            if (above(P, V[n - 1], V[0]) && !below(P, V[1], V[0]))\r\n                return 0; // V[0] is the minimum tangent point\r\n            for (a = 0, b = n;;) {\r\n                if (b - a === 1)\r\n                    if (below(P, V[a], V[b]))\r\n                        return a;\r\n                    else\r\n                        return b;\r\n                c = Math.floor((a + b) / 2); // midpoint of [a,b], and 0<c<n\r\n                dnC = below(P, V[c + 1], V[c]);\r\n                if (above(P, V[c - 1], V[c]) && !dnC)\r\n                    return c; // V[c] is the minimum tangent point\r\n                // no min yet, so continue with the binary search\r\n                // pick one of the two subchains [a,c] or [c,b]\r\n                dnA = below(P, V[a + 1], V[a]);\r\n                if (dnA) {\r\n                    if (!dnC)\r\n                        b = c; // select [a,c]\r\n                    else {\r\n                        if (below(P, V[a], V[c]))\r\n                            b = c; // select [a,c]\r\n                        else\r\n                            a = c; // select [c,b]\r\n                    }\r\n                }\r\n                else {\r\n                    if (dnC)\r\n                        a = c; // select [c,b]\r\n                    else {\r\n                        if (above(P, V[a], V[c]))\r\n                            b = c; // select [a,c]\r\n                        else\r\n                            a = c; // select [c,b]\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // RLtangent_PolyPolyC(): get the RL tangent between two convex polygons\r\n        //    Input:  m = number of vertices in polygon 1\r\n        //            V = array of vertices for convex polygon 1 with V[m]=V[0]\r\n        //            n = number of vertices in polygon 2\r\n        //            W = array of vertices for convex polygon 2 with W[n]=W[0]\r\n        //    Output: *t1 = index of tangent point V[t1] for polygon 1\r\n        //            *t2 = index of tangent point W[t2] for polygon 2\r\n        function tangent_PolyPolyC(V, W, t1, t2, cmp1, cmp2) {\r\n            var ix1, ix2; // search indices for polygons 1 and 2\r\n            // first get the initial vertex on each polygon\r\n            ix1 = t1(W[0], V); // right tangent from W[0] to V\r\n            ix2 = t2(V[ix1], W); // left tangent from V[ix1] to W\r\n            // ping-pong linear search until it stabilizes\r\n            var done = false; // flag when done\r\n            while (!done) {\r\n                done = true; // assume done until...\r\n                while (true) {\r\n                    if (ix1 === V.length - 1)\r\n                        ix1 = 0;\r\n                    if (cmp1(W[ix2], V[ix1], V[ix1 + 1]))\r\n                        break;\r\n                    ++ix1; // get Rtangent from W[ix2] to V\r\n                }\r\n                while (true) {\r\n                    if (ix2 === 0)\r\n                        ix2 = W.length - 1;\r\n                    if (cmp2(V[ix1], W[ix2], W[ix2 - 1]))\r\n                        break;\r\n                    --ix2; // get Ltangent from V[ix1] to W\r\n                    done = false; // not done if had to adjust this\r\n                }\r\n            }\r\n            return { t1: ix1, t2: ix2 };\r\n        }\r\n        geom.tangent_PolyPolyC = tangent_PolyPolyC;\r\n        function LRtangent_PolyPolyC(V, W) {\r\n            var rl = RLtangent_PolyPolyC(W, V);\r\n            return { t1: rl.t2, t2: rl.t1 };\r\n        }\r\n        geom.LRtangent_PolyPolyC = LRtangent_PolyPolyC;\r\n        function RLtangent_PolyPolyC(V, W) {\r\n            return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above, below);\r\n        }\r\n        geom.RLtangent_PolyPolyC = RLtangent_PolyPolyC;\r\n        function LLtangent_PolyPolyC(V, W) {\r\n            return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);\r\n        }\r\n        geom.LLtangent_PolyPolyC = LLtangent_PolyPolyC;\r\n        function RRtangent_PolyPolyC(V, W) {\r\n            return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above, above);\r\n        }\r\n        geom.RRtangent_PolyPolyC = RRtangent_PolyPolyC;\r\n        var BiTangent = (function () {\r\n            function BiTangent(t1, t2) {\r\n                this.t1 = t1;\r\n                this.t2 = t2;\r\n            }\r\n            return BiTangent;\r\n        })();\r\n        geom.BiTangent = BiTangent;\r\n        var BiTangents = (function () {\r\n            function BiTangents() {\r\n            }\r\n            return BiTangents;\r\n        })();\r\n        geom.BiTangents = BiTangents;\r\n        var TVGPoint = (function (_super) {\r\n            __extends(TVGPoint, _super);\r\n            function TVGPoint() {\r\n                _super.apply(this, arguments);\r\n            }\r\n            return TVGPoint;\r\n        })(Point);\r\n        geom.TVGPoint = TVGPoint;\r\n        var VisibilityVertex = (function () {\r\n            function VisibilityVertex(id, polyid, polyvertid, p) {\r\n                this.id = id;\r\n                this.polyid = polyid;\r\n                this.polyvertid = polyvertid;\r\n                this.p = p;\r\n                p.vv = this;\r\n            }\r\n            return VisibilityVertex;\r\n        })();\r\n        geom.VisibilityVertex = VisibilityVertex;\r\n        var VisibilityEdge = (function () {\r\n            function VisibilityEdge(source, target) {\r\n                this.source = source;\r\n                this.target = target;\r\n            }\r\n            VisibilityEdge.prototype.length = function () {\r\n                var dx = this.source.p.x - this.target.p.x;\r\n                var dy = this.source.p.y - this.target.p.y;\r\n                return Math.sqrt(dx * dx + dy * dy);\r\n            };\r\n            return VisibilityEdge;\r\n        })();\r\n        geom.VisibilityEdge = VisibilityEdge;\r\n        var TangentVisibilityGraph = (function () {\r\n            function TangentVisibilityGraph(P, g0) {\r\n                this.P = P;\r\n                this.V = [];\r\n                this.E = [];\r\n                if (!g0) {\r\n                    var n = P.length;\r\n                    for (var i = 0; i < n; i++) {\r\n                        var p = P[i];\r\n                        for (var j = 0; j < p.length; ++j) {\r\n                            var pj = p[j], vv = new VisibilityVertex(this.V.length, i, j, pj);\r\n                            this.V.push(vv);\r\n                            if (j > 0)\r\n                                this.E.push(new VisibilityEdge(p[j - 1].vv, vv));\r\n                        }\r\n                    }\r\n                    for (var i = 0; i < n - 1; i++) {\r\n                        var Pi = P[i];\r\n                        for (var j = i + 1; j < n; j++) {\r\n                            var Pj = P[j], t = geom.tangents(Pi, Pj);\r\n                            for (var q in t) {\r\n                                var c = t[q], source = Pi[c.t1], target = Pj[c.t2];\r\n                                this.addEdgeIfVisible(source, target, i, j);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    this.V = g0.V.slice(0);\r\n                    this.E = g0.E.slice(0);\r\n                }\r\n            }\r\n            TangentVisibilityGraph.prototype.addEdgeIfVisible = function (u, v, i1, i2) {\r\n                if (!this.intersectsPolys(new LineSegment(u.x, u.y, v.x, v.y), i1, i2)) {\r\n                    this.E.push(new VisibilityEdge(u.vv, v.vv));\r\n                }\r\n            };\r\n            TangentVisibilityGraph.prototype.addPoint = function (p, i1) {\r\n                var n = this.P.length;\r\n                this.V.push(new VisibilityVertex(this.V.length, n, 0, p));\r\n                for (var i = 0; i < n; ++i) {\r\n                    if (i === i1)\r\n                        continue;\r\n                    var poly = this.P[i], t = tangent_PointPolyC(p, poly);\r\n                    this.addEdgeIfVisible(p, poly[t.ltan], i1, i);\r\n                    this.addEdgeIfVisible(p, poly[t.rtan], i1, i);\r\n                }\r\n                return p.vv;\r\n            };\r\n            TangentVisibilityGraph.prototype.intersectsPolys = function (l, i1, i2) {\r\n                for (var i = 0, n = this.P.length; i < n; ++i) {\r\n                    if (i != i1 && i != i2 && intersects(l, this.P[i]).length > 0) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            };\r\n            return TangentVisibilityGraph;\r\n        })();\r\n        geom.TangentVisibilityGraph = TangentVisibilityGraph;\r\n        function intersects(l, P) {\r\n            var ints = [];\r\n            for (var i = 1, n = P.length; i < n; ++i) {\r\n                var int = cola.vpsc.Rectangle.lineIntersection(l.x1, l.y1, l.x2, l.y2, P[i - 1].x, P[i - 1].y, P[i].x, P[i].y);\r\n                if (int)\r\n                    ints.push(int);\r\n            }\r\n            return ints;\r\n        }\r\n        function tangents(V, W) {\r\n            var m = V.length - 1, n = W.length - 1;\r\n            var bt = new BiTangents();\r\n            for (var i = 0; i < m; ++i) {\r\n                for (var j = 0; j < n; ++j) {\r\n                    var v1 = V[i == 0 ? m - 1 : i - 1];\r\n                    var v2 = V[i];\r\n                    var v3 = V[i + 1];\r\n                    var w1 = W[j == 0 ? n - 1 : j - 1];\r\n                    var w2 = W[j];\r\n                    var w3 = W[j + 1];\r\n                    var v1v2w2 = isLeft(v1, v2, w2);\r\n                    var v2w1w2 = isLeft(v2, w1, w2);\r\n                    var v2w2w3 = isLeft(v2, w2, w3);\r\n                    var w1w2v2 = isLeft(w1, w2, v2);\r\n                    var w2v1v2 = isLeft(w2, v1, v2);\r\n                    var w2v2v3 = isLeft(w2, v2, v3);\r\n                    if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0\r\n                        && w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {\r\n                        bt.ll = new BiTangent(i, j);\r\n                    }\r\n                    else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0\r\n                        && w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {\r\n                        bt.rr = new BiTangent(i, j);\r\n                    }\r\n                    else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0\r\n                        && w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {\r\n                        bt.rl = new BiTangent(i, j);\r\n                    }\r\n                    else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0\r\n                        && w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {\r\n                        bt.lr = new BiTangent(i, j);\r\n                    }\r\n                }\r\n            }\r\n            return bt;\r\n        }\r\n        geom.tangents = tangents;\r\n        function isPointInsidePoly(p, poly) {\r\n            for (var i = 1, n = poly.length; i < n; ++i)\r\n                if (below(poly[i - 1], poly[i], p))\r\n                    return false;\r\n            return true;\r\n        }\r\n        function isAnyPInQ(p, q) {\r\n            return !p.every(function (v) { return !isPointInsidePoly(v, q); });\r\n        }\r\n        function polysOverlap(p, q) {\r\n            if (isAnyPInQ(p, q))\r\n                return true;\r\n            if (isAnyPInQ(q, p))\r\n                return true;\r\n            for (var i = 1, n = p.length; i < n; ++i) {\r\n                var v = p[i], u = p[i - 1];\r\n                if (intersects(new LineSegment(u.x, u.y, v.x, v.y), q).length > 0)\r\n                    return true;\r\n            }\r\n            return false;\r\n        }\r\n        geom.polysOverlap = polysOverlap;\r\n    })(geom = cola.geom || (cola.geom = {}));\r\n})(cola || (cola = {}));\r\n/**\r\n * @module cola\r\n */\r\nvar cola;\r\n(function (cola) {\r\n    /**\r\n     * Descent respects a collection of locks over nodes that should not move\r\n     * @class Locks\r\n     */\r\n    var Locks = (function () {\r\n        function Locks() {\r\n            this.locks = {};\r\n        }\r\n        /**\r\n         * add a lock on the node at index id\r\n         * @method add\r\n         * @param id index of node to be locked\r\n         * @param x required position for node\r\n         */\r\n        Locks.prototype.add = function (id, x) {\r\n            /* DEBUG\r\n                        if (isNaN(x[0]) || isNaN(x[1])) debugger;\r\n            DEBUG */\r\n            this.locks[id] = x;\r\n        };\r\n        /**\r\n         * @method clear clear all locks\r\n         */\r\n        Locks.prototype.clear = function () {\r\n            this.locks = {};\r\n        };\r\n        /**\r\n         * @isEmpty\r\n         * @returns false if no locks exist\r\n         */\r\n        Locks.prototype.isEmpty = function () {\r\n            for (var l in this.locks)\r\n                return false;\r\n            return true;\r\n        };\r\n        /**\r\n         * perform an operation on each lock\r\n         * @apply\r\n         */\r\n        Locks.prototype.apply = function (f) {\r\n            for (var l in this.locks) {\r\n                f(l, this.locks[l]);\r\n            }\r\n        };\r\n        return Locks;\r\n    })();\r\n    cola.Locks = Locks;\r\n    /**\r\n     * Uses a gradient descent approach to reduce a stress or p-stress goal function over a graph with specified ideal edge lengths or a square matrix of dissimilarities.\r\n     * The standard stress function over a graph nodes with position vectors x,y,z is (mathematica input):\r\n     *   stress[x_,y_,z_,D_,w_]:=Sum[w[[i,j]] (length[x[[i]],y[[i]],z[[i]],x[[j]],y[[j]],z[[j]]]-d[[i,j]])^2,{i,Length[x]-1},{j,i+1,Length[x]}]\r\n     * where: D is a square matrix of ideal separations between nodes, w is matrix of weights for those separations\r\n     *        length[x1_, y1_, z1_, x2_, y2_, z2_] = Sqrt[(x1 - x2)^2 + (y1 - y2)^2 + (z1 - z2)^2]\r\n     * below, we use wij = 1/(Dij^2)\r\n     *\r\n     * @class Descent\r\n     */\r\n    var Descent = (function () {\r\n        /**\r\n         * @method constructor\r\n         * @param x {number[][]} initial coordinates for nodes\r\n         * @param D {number[][]} matrix of desired distances between pairs of nodes\r\n         * @param G {number[][]} [default=null] if specified, G is a matrix of weights for goal terms between pairs of nodes.\r\n         * If G[i][j] > 1 and the separation between nodes i and j is greater than their ideal distance, then there is no contribution for this pair to the goal\r\n         * If G[i][j] <= 1 then it is used as a weighting on the contribution of the variance between ideal and actual separation between i and j to the goal function\r\n         */\r\n        function Descent(x, D, G) {\r\n            if (G === void 0) { G = null; }\r\n            this.D = D;\r\n            this.G = G;\r\n            this.threshold = 0.0001;\r\n            // Parameters for grid snap stress.\r\n            // TODO: Make a pluggable \"StressTerm\" class instead of this\r\n            // mess.\r\n            this.numGridSnapNodes = 0;\r\n            this.snapGridSize = 100;\r\n            this.snapStrength = 1000;\r\n            this.scaleSnapByMaxH = false;\r\n            this.random = new PseudoRandom();\r\n            this.project = null;\r\n            this.x = x;\r\n            this.k = x.length; // dimensionality\r\n            var n = this.n = x[0].length; // number of nodes\r\n            this.H = new Array(this.k);\r\n            this.g = new Array(this.k);\r\n            this.Hd = new Array(this.k);\r\n            this.a = new Array(this.k);\r\n            this.b = new Array(this.k);\r\n            this.c = new Array(this.k);\r\n            this.d = new Array(this.k);\r\n            this.e = new Array(this.k);\r\n            this.ia = new Array(this.k);\r\n            this.ib = new Array(this.k);\r\n            this.xtmp = new Array(this.k);\r\n            this.locks = new Locks();\r\n            this.minD = Number.MAX_VALUE;\r\n            var i = n, j;\r\n            while (i--) {\r\n                j = n;\r\n                while (--j > i) {\r\n                    var d = D[i][j];\r\n                    if (d > 0 && d < this.minD) {\r\n                        this.minD = d;\r\n                    }\r\n                }\r\n            }\r\n            if (this.minD === Number.MAX_VALUE)\r\n                this.minD = 1;\r\n            i = this.k;\r\n            while (i--) {\r\n                this.g[i] = new Array(n);\r\n                this.H[i] = new Array(n);\r\n                j = n;\r\n                while (j--) {\r\n                    this.H[i][j] = new Array(n);\r\n                }\r\n                this.Hd[i] = new Array(n);\r\n                this.a[i] = new Array(n);\r\n                this.b[i] = new Array(n);\r\n                this.c[i] = new Array(n);\r\n                this.d[i] = new Array(n);\r\n                this.e[i] = new Array(n);\r\n                this.ia[i] = new Array(n);\r\n                this.ib[i] = new Array(n);\r\n                this.xtmp[i] = new Array(n);\r\n            }\r\n        }\r\n        Descent.createSquareMatrix = function (n, f) {\r\n            var M = new Array(n);\r\n            for (var i = 0; i < n; ++i) {\r\n                M[i] = new Array(n);\r\n                for (var j = 0; j < n; ++j) {\r\n                    M[i][j] = f(i, j);\r\n                }\r\n            }\r\n            return M;\r\n        };\r\n        Descent.prototype.offsetDir = function () {\r\n            var _this = this;\r\n            var u = new Array(this.k);\r\n            var l = 0;\r\n            for (var i = 0; i < this.k; ++i) {\r\n                var x = u[i] = this.random.getNextBetween(0.01, 1) - 0.5;\r\n                l += x * x;\r\n            }\r\n            l = Math.sqrt(l);\r\n            return u.map(function (x) { return x *= _this.minD / l; });\r\n        };\r\n        // compute first and second derivative information storing results in this.g and this.H\r\n        Descent.prototype.computeDerivatives = function (x) {\r\n            var _this = this;\r\n            var n = this.n;\r\n            if (n < 1)\r\n                return;\r\n            var i;\r\n            /* DEBUG\r\n                        for (var u: number = 0; u < n; ++u)\r\n                            for (i = 0; i < this.k; ++i)\r\n                                if (isNaN(x[i][u])) debugger;\r\n            DEBUG */\r\n            var d = new Array(this.k);\r\n            var d2 = new Array(this.k);\r\n            var Huu = new Array(this.k);\r\n            var maxH = 0;\r\n            for (var u = 0; u < n; ++u) {\r\n                for (i = 0; i < this.k; ++i)\r\n                    Huu[i] = this.g[i][u] = 0;\r\n                for (var v = 0; v < n; ++v) {\r\n                    if (u === v)\r\n                        continue;\r\n                    // The following loop randomly displaces nodes that are at identical positions\r\n                    var maxDisplaces = n; // avoid infinite loop in the case of numerical issues, such as huge values\r\n                    while (maxDisplaces--) {\r\n                        var sd2 = 0;\r\n                        for (i = 0; i < this.k; ++i) {\r\n                            var dx = d[i] = x[i][u] - x[i][v];\r\n                            sd2 += d2[i] = dx * dx;\r\n                        }\r\n                        if (sd2 > 1e-9)\r\n                            break;\r\n                        var rd = this.offsetDir();\r\n                        for (i = 0; i < this.k; ++i)\r\n                            x[i][v] += rd[i];\r\n                    }\r\n                    var l = Math.sqrt(sd2);\r\n                    var D = this.D[u][v];\r\n                    var weight = this.G != null ? this.G[u][v] : 1;\r\n                    if (weight > 1 && l > D || !isFinite(D)) {\r\n                        for (i = 0; i < this.k; ++i)\r\n                            this.H[i][u][v] = 0;\r\n                        continue;\r\n                    }\r\n                    if (weight > 1) {\r\n                        weight = 1;\r\n                    }\r\n                    var D2 = D * D;\r\n                    var gs = 2 * weight * (l - D) / (D2 * l);\r\n                    var l3 = l * l * l;\r\n                    var hs = 2 * -weight / (D2 * l3);\r\n                    if (!isFinite(gs))\r\n                        console.log(gs);\r\n                    for (i = 0; i < this.k; ++i) {\r\n                        this.g[i][u] += d[i] * gs;\r\n                        Huu[i] -= this.H[i][u][v] = hs * (l3 + D * (d2[i] - sd2) + l * sd2);\r\n                    }\r\n                }\r\n                for (i = 0; i < this.k; ++i)\r\n                    maxH = Math.max(maxH, this.H[i][u][u] = Huu[i]);\r\n            }\r\n            // Grid snap forces\r\n            var r = this.snapGridSize / 2;\r\n            var g = this.snapGridSize;\r\n            var w = this.snapStrength;\r\n            var k = w / (r * r);\r\n            var numNodes = this.numGridSnapNodes;\r\n            //var numNodes = n;\r\n            for (var u = 0; u < numNodes; ++u) {\r\n                for (i = 0; i < this.k; ++i) {\r\n                    var xiu = this.x[i][u];\r\n                    var m = xiu / g;\r\n                    var f = m % 1;\r\n                    var q = m - f;\r\n                    var a = Math.abs(f);\r\n                    var dx = (a <= 0.5) ? xiu - q * g :\r\n                        (xiu > 0) ? xiu - (q + 1) * g : xiu - (q - 1) * g;\r\n                    if (-r < dx && dx <= r) {\r\n                        if (this.scaleSnapByMaxH) {\r\n                            this.g[i][u] += maxH * k * dx;\r\n                            this.H[i][u][u] += maxH * k;\r\n                        }\r\n                        else {\r\n                            this.g[i][u] += k * dx;\r\n                            this.H[i][u][u] += k;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!this.locks.isEmpty()) {\r\n                this.locks.apply(function (u, p) {\r\n                    for (i = 0; i < _this.k; ++i) {\r\n                        _this.H[i][u][u] += maxH;\r\n                        _this.g[i][u] -= maxH * (p[i] - x[i][u]);\r\n                    }\r\n                });\r\n            }\r\n            /* DEBUG\r\n                        for (var u: number = 0; u < n; ++u)\r\n                            for (i = 0; i < this.k; ++i) {\r\n                                if (isNaN(this.g[i][u])) debugger;\r\n                                for (var v: number = 0; v < n; ++v)\r\n                                    if (isNaN(this.H[i][u][v])) debugger;\r\n                            }\r\n            DEBUG */\r\n        };\r\n        Descent.dotProd = function (a, b) {\r\n            var x = 0, i = a.length;\r\n            while (i--)\r\n                x += a[i] * b[i];\r\n            return x;\r\n        };\r\n        // result r = matrix m * vector v\r\n        Descent.rightMultiply = function (m, v, r) {\r\n            var i = m.length;\r\n            while (i--)\r\n                r[i] = Descent.dotProd(m[i], v);\r\n        };\r\n        // computes the optimal step size to take in direction d using the\r\n        // derivative information in this.g and this.H\r\n        // returns the scalar multiplier to apply to d to get the optimal step\r\n        Descent.prototype.computeStepSize = function (d) {\r\n            var numerator = 0, denominator = 0;\r\n            for (var i = 0; i < this.k; ++i) {\r\n                numerator += Descent.dotProd(this.g[i], d[i]);\r\n                Descent.rightMultiply(this.H[i], d[i], this.Hd[i]);\r\n                denominator += Descent.dotProd(d[i], this.Hd[i]);\r\n            }\r\n            if (denominator === 0 || !isFinite(denominator))\r\n                return 0;\r\n            return 1 * numerator / denominator;\r\n        };\r\n        Descent.prototype.reduceStress = function () {\r\n            this.computeDerivatives(this.x);\r\n            var alpha = this.computeStepSize(this.g);\r\n            for (var i = 0; i < this.k; ++i) {\r\n                this.takeDescentStep(this.x[i], this.g[i], alpha);\r\n            }\r\n            return this.computeStress();\r\n        };\r\n        Descent.copy = function (a, b) {\r\n            var m = a.length, n = b[0].length;\r\n            for (var i = 0; i < m; ++i) {\r\n                for (var j = 0; j < n; ++j) {\r\n                    b[i][j] = a[i][j];\r\n                }\r\n            }\r\n        };\r\n        // takes a step of stepSize * d from x0, and then project against any constraints.\r\n        // result is returned in r.\r\n        // x0: starting positions\r\n        // r: result positions will be returned here\r\n        // d: unconstrained descent vector\r\n        // stepSize: amount to step along d\r\n        Descent.prototype.stepAndProject = function (x0, r, d, stepSize) {\r\n            Descent.copy(x0, r);\r\n            this.takeDescentStep(r[0], d[0], stepSize);\r\n            if (this.project)\r\n                this.project[0](x0[0], x0[1], r[0]);\r\n            this.takeDescentStep(r[1], d[1], stepSize);\r\n            if (this.project)\r\n                this.project[1](r[0], x0[1], r[1]);\r\n            // todo: allow projection against constraints in higher dimensions\r\n            for (var i = 2; i < this.k; i++)\r\n                this.takeDescentStep(r[i], d[i], stepSize);\r\n            // the following makes locks extra sticky... but hides the result of the projection from the consumer\r\n            //if (!this.locks.isEmpty()) {\r\n            //    this.locks.apply((u, p) => {\r\n            //        for (var i = 0; i < this.k; i++) {\r\n            //            r[i][u] = p[i];\r\n            //        }\r\n            //    });\r\n            //}\r\n        };\r\n        Descent.mApply = function (m, n, f) {\r\n            var i = m;\r\n            while (i-- > 0) {\r\n                var j = n;\r\n                while (j-- > 0)\r\n                    f(i, j);\r\n            }\r\n        };\r\n        Descent.prototype.matrixApply = function (f) {\r\n            Descent.mApply(this.k, this.n, f);\r\n        };\r\n        Descent.prototype.computeNextPosition = function (x0, r) {\r\n            var _this = this;\r\n            this.computeDerivatives(x0);\r\n            var alpha = this.computeStepSize(this.g);\r\n            this.stepAndProject(x0, r, this.g, alpha);\r\n            /* DEBUG\r\n                        for (var u: number = 0; u < this.n; ++u)\r\n                            for (var i = 0; i < this.k; ++i)\r\n                                if (isNaN(r[i][u])) debugger;\r\n            DEBUG */\r\n            if (this.project) {\r\n                this.matrixApply(function (i, j) { return _this.e[i][j] = x0[i][j] - r[i][j]; });\r\n                var beta = this.computeStepSize(this.e);\r\n                beta = Math.max(0.2, Math.min(beta, 1));\r\n                this.stepAndProject(x0, r, this.e, beta);\r\n            }\r\n        };\r\n        Descent.prototype.run = function (iterations) {\r\n            var stress = Number.MAX_VALUE, converged = false;\r\n            while (!converged && iterations-- > 0) {\r\n                var s = this.rungeKutta();\r\n                converged = Math.abs(stress / s - 1) < this.threshold;\r\n                stress = s;\r\n            }\r\n            return stress;\r\n        };\r\n        Descent.prototype.rungeKutta = function () {\r\n            var _this = this;\r\n            this.computeNextPosition(this.x, this.a);\r\n            Descent.mid(this.x, this.a, this.ia);\r\n            this.computeNextPosition(this.ia, this.b);\r\n            Descent.mid(this.x, this.b, this.ib);\r\n            this.computeNextPosition(this.ib, this.c);\r\n            this.computeNextPosition(this.c, this.d);\r\n            var disp = 0;\r\n            this.matrixApply(function (i, j) {\r\n                var x = (_this.a[i][j] + 2.0 * _this.b[i][j] + 2.0 * _this.c[i][j] + _this.d[i][j]) / 6.0, d = _this.x[i][j] - x;\r\n                disp += d * d;\r\n                _this.x[i][j] = x;\r\n            });\r\n            return disp;\r\n        };\r\n        Descent.mid = function (a, b, m) {\r\n            Descent.mApply(a.length, a[0].length, function (i, j) {\r\n                return m[i][j] = a[i][j] + (b[i][j] - a[i][j]) / 2.0;\r\n            });\r\n        };\r\n        Descent.prototype.takeDescentStep = function (x, d, stepSize) {\r\n            for (var i = 0; i < this.n; ++i) {\r\n                x[i] = x[i] - stepSize * d[i];\r\n            }\r\n        };\r\n        Descent.prototype.computeStress = function () {\r\n            var stress = 0;\r\n            for (var u = 0, nMinus1 = this.n - 1; u < nMinus1; ++u) {\r\n                for (var v = u + 1, n = this.n; v < n; ++v) {\r\n                    var l = 0;\r\n                    for (var i = 0; i < this.k; ++i) {\r\n                        var dx = this.x[i][u] - this.x[i][v];\r\n                        l += dx * dx;\r\n                    }\r\n                    l = Math.sqrt(l);\r\n                    var d = this.D[u][v];\r\n                    if (!isFinite(d))\r\n                        continue;\r\n                    var rl = d - l;\r\n                    var d2 = d * d;\r\n                    stress += rl * rl / d2;\r\n                }\r\n            }\r\n            return stress;\r\n        };\r\n        Descent.zeroDistance = 1e-10;\r\n        return Descent;\r\n    })();\r\n    cola.Descent = Descent;\r\n    // Linear congruential pseudo random number generator\r\n    var PseudoRandom = (function () {\r\n        function PseudoRandom(seed) {\r\n            if (seed === void 0) { seed = 1; }\r\n            this.seed = seed;\r\n            this.a = 214013;\r\n            this.c = 2531011;\r\n            this.m = 2147483648;\r\n            this.range = 32767;\r\n        }\r\n        // random real between 0 and 1\r\n        PseudoRandom.prototype.getNext = function () {\r\n            this.seed = (this.seed * this.a + this.c) % this.m;\r\n            return (this.seed >> 16) / this.range;\r\n        };\r\n        // random real between min and max\r\n        PseudoRandom.prototype.getNextBetween = function (min, max) {\r\n            return min + this.getNext() * (max - min);\r\n        };\r\n        return PseudoRandom;\r\n    })();\r\n    cola.PseudoRandom = PseudoRandom;\r\n})(cola || (cola = {}));\r\nvar cola;\r\n(function (cola) {\r\n    var powergraph;\r\n    (function (powergraph) {\r\n        var PowerEdge = (function () {\r\n            function PowerEdge(source, target, type) {\r\n                this.source = source;\r\n                this.target = target;\r\n                this.type = type;\r\n            }\r\n            return PowerEdge;\r\n        })();\r\n        powergraph.PowerEdge = PowerEdge;\r\n        var Configuration = (function () {\r\n            function Configuration(n, edges, linkAccessor, rootGroup) {\r\n                var _this = this;\r\n                this.linkAccessor = linkAccessor;\r\n                this.modules = new Array(n);\r\n                this.roots = [];\r\n                if (rootGroup) {\r\n                    this.initModulesFromGroup(rootGroup);\r\n                }\r\n                else {\r\n                    this.roots.push(new ModuleSet());\r\n                    for (var i = 0; i < n; ++i)\r\n                        this.roots[0].add(this.modules[i] = new Module(i));\r\n                }\r\n                this.R = edges.length;\r\n                edges.forEach(function (e) {\r\n                    var s = _this.modules[linkAccessor.getSourceIndex(e)], t = _this.modules[linkAccessor.getTargetIndex(e)], type = linkAccessor.getType(e);\r\n                    s.outgoing.add(type, t);\r\n                    t.incoming.add(type, s);\r\n                });\r\n            }\r\n            Configuration.prototype.initModulesFromGroup = function (group) {\r\n                var moduleSet = new ModuleSet();\r\n                this.roots.push(moduleSet);\r\n                for (var i = 0; i < group.leaves.length; ++i) {\r\n                    var node = group.leaves[i];\r\n                    var module = new Module(node.id);\r\n                    this.modules[node.id] = module;\r\n                    moduleSet.add(module);\r\n                }\r\n                if (group.groups) {\r\n                    for (var j = 0; j < group.groups.length; ++j) {\r\n                        var child = group.groups[j];\r\n                        // Propagate group properties (like padding, stiffness, ...) as module definition so that the generated power graph group will inherit it\r\n                        var definition = {};\r\n                        for (var prop in child)\r\n                            if (prop !== \"leaves\" && prop !== \"groups\" && child.hasOwnProperty(prop))\r\n                                definition[prop] = child[prop];\r\n                        // Use negative module id to avoid clashes between predefined and generated modules\r\n                        moduleSet.add(new Module(-1 - j, new LinkSets(), new LinkSets(), this.initModulesFromGroup(child), definition));\r\n                    }\r\n                }\r\n                return moduleSet;\r\n            };\r\n            // merge modules a and b keeping track of their power edges and removing the from roots\r\n            Configuration.prototype.merge = function (a, b, k) {\r\n                if (k === void 0) { k = 0; }\r\n                var inInt = a.incoming.intersection(b.incoming), outInt = a.outgoing.intersection(b.outgoing);\r\n                var children = new ModuleSet();\r\n                children.add(a);\r\n                children.add(b);\r\n                var m = new Module(this.modules.length, outInt, inInt, children);\r\n                this.modules.push(m);\r\n                var update = function (s, i, o) {\r\n                    s.forAll(function (ms, linktype) {\r\n                        ms.forAll(function (n) {\r\n                            var nls = n[i];\r\n                            nls.add(linktype, m);\r\n                            nls.remove(linktype, a);\r\n                            nls.remove(linktype, b);\r\n                            a[o].remove(linktype, n);\r\n                            b[o].remove(linktype, n);\r\n                        });\r\n                    });\r\n                };\r\n                update(outInt, \"incoming\", \"outgoing\");\r\n                update(inInt, \"outgoing\", \"incoming\");\r\n                this.R -= inInt.count() + outInt.count();\r\n                this.roots[k].remove(a);\r\n                this.roots[k].remove(b);\r\n                this.roots[k].add(m);\r\n                return m;\r\n            };\r\n            Configuration.prototype.rootMerges = function (k) {\r\n                if (k === void 0) { k = 0; }\r\n                var rs = this.roots[k].modules();\r\n                var n = rs.length;\r\n                var merges = new Array(n * (n - 1));\r\n                var ctr = 0;\r\n                for (var i = 0, i_ = n - 1; i < i_; ++i) {\r\n                    for (var j = i + 1; j < n; ++j) {\r\n                        var a = rs[i], b = rs[j];\r\n                        merges[ctr] = { id: ctr, nEdges: this.nEdges(a, b), a: a, b: b };\r\n                        ctr++;\r\n                    }\r\n                }\r\n                return merges;\r\n            };\r\n            Configuration.prototype.greedyMerge = function () {\r\n                for (var i = 0; i < this.roots.length; ++i) {\r\n                    // Handle single nested module case\r\n                    if (this.roots[i].modules().length < 2)\r\n                        continue;\r\n                    // find the merge that allows for the most edges to be removed.  secondary ordering based on arbitrary id (for predictability)\r\n                    var ms = this.rootMerges(i).sort(function (a, b) { return a.nEdges == b.nEdges ? a.id - b.id : a.nEdges - b.nEdges; });\r\n                    var m = ms[0];\r\n                    if (m.nEdges >= this.R)\r\n                        continue;\r\n                    this.merge(m.a, m.b, i);\r\n                    return true;\r\n                }\r\n            };\r\n            Configuration.prototype.nEdges = function (a, b) {\r\n                var inInt = a.incoming.intersection(b.incoming), outInt = a.outgoing.intersection(b.outgoing);\r\n                return this.R - inInt.count() - outInt.count();\r\n            };\r\n            Configuration.prototype.getGroupHierarchy = function (retargetedEdges) {\r\n                var _this = this;\r\n                var groups = [];\r\n                var root = {};\r\n                toGroups(this.roots[0], root, groups);\r\n                var es = this.allEdges();\r\n                es.forEach(function (e) {\r\n                    var a = _this.modules[e.source];\r\n                    var b = _this.modules[e.target];\r\n                    retargetedEdges.push(new PowerEdge(typeof a.gid === \"undefined\" ? e.source : groups[a.gid], typeof b.gid === \"undefined\" ? e.target : groups[b.gid], e.type));\r\n                });\r\n                return groups;\r\n            };\r\n            Configuration.prototype.allEdges = function () {\r\n                var es = [];\r\n                Configuration.getEdges(this.roots[0], es);\r\n                return es;\r\n            };\r\n            Configuration.getEdges = function (modules, es) {\r\n                modules.forAll(function (m) {\r\n                    m.getEdges(es);\r\n                    Configuration.getEdges(m.children, es);\r\n                });\r\n            };\r\n            return Configuration;\r\n        })();\r\n        powergraph.Configuration = Configuration;\r\n        function toGroups(modules, group, groups) {\r\n            modules.forAll(function (m) {\r\n                if (m.isLeaf()) {\r\n                    if (!group.leaves)\r\n                        group.leaves = [];\r\n                    group.leaves.push(m.id);\r\n                }\r\n                else {\r\n                    var g = group;\r\n                    m.gid = groups.length;\r\n                    if (!m.isIsland() || m.isPredefined()) {\r\n                        g = { id: m.gid };\r\n                        if (m.isPredefined())\r\n                            // Apply original group properties\r\n                            for (var prop in m.definition)\r\n                                g[prop] = m.definition[prop];\r\n                        if (!group.groups)\r\n                            group.groups = [];\r\n                        group.groups.push(m.gid);\r\n                        groups.push(g);\r\n                    }\r\n                    toGroups(m.children, g, groups);\r\n                }\r\n            });\r\n        }\r\n        var Module = (function () {\r\n            function Module(id, outgoing, incoming, children, definition) {\r\n                if (outgoing === void 0) { outgoing = new LinkSets(); }\r\n                if (incoming === void 0) { incoming = new LinkSets(); }\r\n                if (children === void 0) { children = new ModuleSet(); }\r\n                this.id = id;\r\n                this.outgoing = outgoing;\r\n                this.incoming = incoming;\r\n                this.children = children;\r\n                this.definition = definition;\r\n            }\r\n            Module.prototype.getEdges = function (es) {\r\n                var _this = this;\r\n                this.outgoing.forAll(function (ms, edgetype) {\r\n                    ms.forAll(function (target) {\r\n                        es.push(new PowerEdge(_this.id, target.id, edgetype));\r\n                    });\r\n                });\r\n            };\r\n            Module.prototype.isLeaf = function () {\r\n                return this.children.count() === 0;\r\n            };\r\n            Module.prototype.isIsland = function () {\r\n                return this.outgoing.count() === 0 && this.incoming.count() === 0;\r\n            };\r\n            Module.prototype.isPredefined = function () {\r\n                return typeof this.definition !== \"undefined\";\r\n            };\r\n            return Module;\r\n        })();\r\n        powergraph.Module = Module;\r\n        function intersection(m, n) {\r\n            var i = {};\r\n            for (var v in m)\r\n                if (v in n)\r\n                    i[v] = m[v];\r\n            return i;\r\n        }\r\n        var ModuleSet = (function () {\r\n            function ModuleSet() {\r\n                this.table = {};\r\n            }\r\n            ModuleSet.prototype.count = function () {\r\n                return Object.keys(this.table).length;\r\n            };\r\n            ModuleSet.prototype.intersection = function (other) {\r\n                var result = new ModuleSet();\r\n                result.table = intersection(this.table, other.table);\r\n                return result;\r\n            };\r\n            ModuleSet.prototype.intersectionCount = function (other) {\r\n                return this.intersection(other).count();\r\n            };\r\n            ModuleSet.prototype.contains = function (id) {\r\n                return id in this.table;\r\n            };\r\n            ModuleSet.prototype.add = function (m) {\r\n                this.table[m.id] = m;\r\n            };\r\n            ModuleSet.prototype.remove = function (m) {\r\n                delete this.table[m.id];\r\n            };\r\n            ModuleSet.prototype.forAll = function (f) {\r\n                for (var mid in this.table) {\r\n                    f(this.table[mid]);\r\n                }\r\n            };\r\n            ModuleSet.prototype.modules = function () {\r\n                var vs = [];\r\n                this.forAll(function (m) {\r\n                    if (!m.isPredefined())\r\n                        vs.push(m);\r\n                });\r\n                return vs;\r\n            };\r\n            return ModuleSet;\r\n        })();\r\n        powergraph.ModuleSet = ModuleSet;\r\n        var LinkSets = (function () {\r\n            function LinkSets() {\r\n                this.sets = {};\r\n                this.n = 0;\r\n            }\r\n            LinkSets.prototype.count = function () {\r\n                return this.n;\r\n            };\r\n            LinkSets.prototype.contains = function (id) {\r\n                var result = false;\r\n                this.forAllModules(function (m) {\r\n                    if (!result && m.id == id) {\r\n                        result = true;\r\n                    }\r\n                });\r\n                return result;\r\n            };\r\n            LinkSets.prototype.add = function (linktype, m) {\r\n                var s = linktype in this.sets ? this.sets[linktype] : this.sets[linktype] = new ModuleSet();\r\n                s.add(m);\r\n                ++this.n;\r\n            };\r\n            LinkSets.prototype.remove = function (linktype, m) {\r\n                var ms = this.sets[linktype];\r\n                ms.remove(m);\r\n                if (ms.count() === 0) {\r\n                    delete this.sets[linktype];\r\n                }\r\n                --this.n;\r\n            };\r\n            LinkSets.prototype.forAll = function (f) {\r\n                for (var linktype in this.sets) {\r\n                    f(this.sets[linktype], linktype);\r\n                }\r\n            };\r\n            LinkSets.prototype.forAllModules = function (f) {\r\n                this.forAll(function (ms, lt) { return ms.forAll(f); });\r\n            };\r\n            LinkSets.prototype.intersection = function (other) {\r\n                var result = new LinkSets();\r\n                this.forAll(function (ms, lt) {\r\n                    if (lt in other.sets) {\r\n                        var i = ms.intersection(other.sets[lt]), n = i.count();\r\n                        if (n > 0) {\r\n                            result.sets[lt] = i;\r\n                            result.n += n;\r\n                        }\r\n                    }\r\n                });\r\n                return result;\r\n            };\r\n            return LinkSets;\r\n        })();\r\n        powergraph.LinkSets = LinkSets;\r\n        function intersectionCount(m, n) {\r\n            return Object.keys(intersection(m, n)).length;\r\n        }\r\n        function getGroups(nodes, links, la, rootGroup) {\r\n            var n = nodes.length, c = new powergraph.Configuration(n, links, la, rootGroup);\r\n            while (c.greedyMerge())\r\n                ;\r\n            var powerEdges = [];\r\n            var g = c.getGroupHierarchy(powerEdges);\r\n            powerEdges.forEach(function (e) {\r\n                var f = function (end) {\r\n                    var g = e[end];\r\n                    if (typeof g == \"number\")\r\n                        e[end] = nodes[g];\r\n                };\r\n                f(\"source\");\r\n                f(\"target\");\r\n            });\r\n            return { groups: g, powerEdges: powerEdges };\r\n        }\r\n        powergraph.getGroups = getGroups;\r\n    })(powergraph = cola.powergraph || (cola.powergraph = {}));\r\n})(cola || (cola = {}));\r\n/**\r\n * @module cola\r\n */\r\nvar cola;\r\n(function (cola) {\r\n    // compute the size of the union of two sets a and b\r\n    function unionCount(a, b) {\r\n        var u = {};\r\n        for (var i in a)\r\n            u[i] = {};\r\n        for (var i in b)\r\n            u[i] = {};\r\n        return Object.keys(u).length;\r\n    }\r\n    // compute the size of the intersection of two sets a and b\r\n    function intersectionCount(a, b) {\r\n        var n = 0;\r\n        for (var i in a)\r\n            if (typeof b[i] !== 'undefined')\r\n                ++n;\r\n        return n;\r\n    }\r\n    function getNeighbours(links, la) {\r\n        var neighbours = {};\r\n        var addNeighbours = function (u, v) {\r\n            if (typeof neighbours[u] === 'undefined')\r\n                neighbours[u] = {};\r\n            neighbours[u][v] = {};\r\n        };\r\n        links.forEach(function (e) {\r\n            var u = la.getSourceIndex(e), v = la.getTargetIndex(e);\r\n            addNeighbours(u, v);\r\n            addNeighbours(v, u);\r\n        });\r\n        return neighbours;\r\n    }\r\n    // modify the lengths of the specified links by the result of function f weighted by w\r\n    function computeLinkLengths(links, w, f, la) {\r\n        var neighbours = getNeighbours(links, la);\r\n        links.forEach(function (l) {\r\n            var a = neighbours[la.getSourceIndex(l)];\r\n            var b = neighbours[la.getTargetIndex(l)];\r\n            la.setLength(l, 1 + w * f(a, b));\r\n        });\r\n    }\r\n    /** modify the specified link lengths based on the symmetric difference of their neighbours\r\n     * @class symmetricDiffLinkLengths\r\n     */\r\n    function symmetricDiffLinkLengths(links, la, w) {\r\n        if (w === void 0) { w = 1; }\r\n        computeLinkLengths(links, w, function (a, b) { return Math.sqrt(unionCount(a, b) - intersectionCount(a, b)); }, la);\r\n    }\r\n    cola.symmetricDiffLinkLengths = symmetricDiffLinkLengths;\r\n    /** modify the specified links lengths based on the jaccard difference between their neighbours\r\n     * @class jaccardLinkLengths\r\n     */\r\n    function jaccardLinkLengths(links, la, w) {\r\n        if (w === void 0) { w = 1; }\r\n        computeLinkLengths(links, w, function (a, b) {\r\n            return Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b);\r\n        }, la);\r\n    }\r\n    cola.jaccardLinkLengths = jaccardLinkLengths;\r\n    /** generate separation constraints for all edges unless both their source and sink are in the same strongly connected component\r\n     * @class generateDirectedEdgeConstraints\r\n     */\r\n    function generateDirectedEdgeConstraints(n, links, axis, la) {\r\n        var components = stronglyConnectedComponents(n, links, la);\r\n        var nodes = {};\r\n        components.forEach(function (c, i) {\r\n            return c.forEach(function (v) { return nodes[v] = i; });\r\n        });\r\n        var constraints = [];\r\n        links.forEach(function (l) {\r\n            var ui = la.getSourceIndex(l), vi = la.getTargetIndex(l), u = nodes[ui], v = nodes[vi];\r\n            if (u !== v) {\r\n                constraints.push({\r\n                    axis: axis,\r\n                    left: ui,\r\n                    right: vi,\r\n                    gap: la.getMinSeparation(l)\r\n                });\r\n            }\r\n        });\r\n        return constraints;\r\n    }\r\n    cola.generateDirectedEdgeConstraints = generateDirectedEdgeConstraints;\r\n    /**\r\n     * Tarjan's strongly connected components algorithm for directed graphs\r\n     * returns an array of arrays of node indicies in each of the strongly connected components.\r\n     * a vertex not in a SCC of two or more nodes is it's own SCC.\r\n     * adaptation of https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\r\n     */\r\n    function stronglyConnectedComponents(numVertices, edges, la) {\r\n        var nodes = [];\r\n        var index = 0;\r\n        var stack = [];\r\n        var components = [];\r\n        function strongConnect(v) {\r\n            // Set the depth index for v to the smallest unused index\r\n            v.index = v.lowlink = index++;\r\n            stack.push(v);\r\n            v.onStack = true;\r\n            // Consider successors of v\r\n            for (var _i = 0, _a = v.out; _i < _a.length; _i++) {\r\n                var w = _a[_i];\r\n                if (typeof w.index === 'undefined') {\r\n                    // Successor w has not yet been visited; recurse on it\r\n                    strongConnect(w);\r\n                    v.lowlink = Math.min(v.lowlink, w.lowlink);\r\n                }\r\n                else if (w.onStack) {\r\n                    // Successor w is in stack S and hence in the current SCC\r\n                    v.lowlink = Math.min(v.lowlink, w.index);\r\n                }\r\n            }\r\n            // If v is a root node, pop the stack and generate an SCC\r\n            if (v.lowlink === v.index) {\r\n                // start a new strongly connected component\r\n                var component = [];\r\n                while (stack.length) {\r\n                    w = stack.pop();\r\n                    w.onStack = false;\r\n                    //add w to current strongly connected component\r\n                    component.push(w);\r\n                    if (w === v)\r\n                        break;\r\n                }\r\n                // output the current strongly connected component\r\n                components.push(component.map(function (v) { return v.id; }));\r\n            }\r\n        }\r\n        for (var i = 0; i < numVertices; i++) {\r\n            nodes.push({ id: i, out: [] });\r\n        }\r\n        for (var _i = 0; _i < edges.length; _i++) {\r\n            var e = edges[_i];\r\n            var v_1 = nodes[la.getSourceIndex(e)], w = nodes[la.getTargetIndex(e)];\r\n            v_1.out.push(w);\r\n        }\r\n        for (var _a = 0; _a < nodes.length; _a++) {\r\n            var v = nodes[_a];\r\n            if (typeof v.index === 'undefined')\r\n                strongConnect(v);\r\n        }\r\n        return components;\r\n    }\r\n    cola.stronglyConnectedComponents = stronglyConnectedComponents;\r\n})(cola || (cola = {}));\r\nvar PairingHeap = (function () {\r\n    // from: https://gist.github.com/nervoussystem\r\n    //{elem:object, subheaps:[array of heaps]}\r\n    function PairingHeap(elem) {\r\n        this.elem = elem;\r\n        this.subheaps = [];\r\n    }\r\n    PairingHeap.prototype.toString = function (selector) {\r\n        var str = \"\", needComma = false;\r\n        for (var i = 0; i < this.subheaps.length; ++i) {\r\n            var subheap = this.subheaps[i];\r\n            if (!subheap.elem) {\r\n                needComma = false;\r\n                continue;\r\n            }\r\n            if (needComma) {\r\n                str = str + \",\";\r\n            }\r\n            str = str + subheap.toString(selector);\r\n            needComma = true;\r\n        }\r\n        if (str !== \"\") {\r\n            str = \"(\" + str + \")\";\r\n        }\r\n        return (this.elem ? selector(this.elem) : \"\") + str;\r\n    };\r\n    PairingHeap.prototype.forEach = function (f) {\r\n        if (!this.empty()) {\r\n            f(this.elem, this);\r\n            this.subheaps.forEach(function (s) { return s.forEach(f); });\r\n        }\r\n    };\r\n    PairingHeap.prototype.count = function () {\r\n        return this.empty() ? 0 : 1 + this.subheaps.reduce(function (n, h) {\r\n            return n + h.count();\r\n        }, 0);\r\n    };\r\n    PairingHeap.prototype.min = function () {\r\n        return this.elem;\r\n    };\r\n    PairingHeap.prototype.empty = function () {\r\n        return this.elem == null;\r\n    };\r\n    PairingHeap.prototype.contains = function (h) {\r\n        if (this === h)\r\n            return true;\r\n        for (var i = 0; i < this.subheaps.length; i++) {\r\n            if (this.subheaps[i].contains(h))\r\n                return true;\r\n        }\r\n        return false;\r\n    };\r\n    PairingHeap.prototype.isHeap = function (lessThan) {\r\n        var _this = this;\r\n        return this.subheaps.every(function (h) { return lessThan(_this.elem, h.elem) && h.isHeap(lessThan); });\r\n    };\r\n    PairingHeap.prototype.insert = function (obj, lessThan) {\r\n        return this.merge(new PairingHeap(obj), lessThan);\r\n    };\r\n    PairingHeap.prototype.merge = function (heap2, lessThan) {\r\n        if (this.empty())\r\n            return heap2;\r\n        else if (heap2.empty())\r\n            return this;\r\n        else if (lessThan(this.elem, heap2.elem)) {\r\n            this.subheaps.push(heap2);\r\n            return this;\r\n        }\r\n        else {\r\n            heap2.subheaps.push(this);\r\n            return heap2;\r\n        }\r\n    };\r\n    PairingHeap.prototype.removeMin = function (lessThan) {\r\n        if (this.empty())\r\n            return null;\r\n        else\r\n            return this.mergePairs(lessThan);\r\n    };\r\n    PairingHeap.prototype.mergePairs = function (lessThan) {\r\n        if (this.subheaps.length == 0)\r\n            return new PairingHeap(null);\r\n        else if (this.subheaps.length == 1) {\r\n            return this.subheaps[0];\r\n        }\r\n        else {\r\n            var firstPair = this.subheaps.pop().merge(this.subheaps.pop(), lessThan);\r\n            var remaining = this.mergePairs(lessThan);\r\n            return firstPair.merge(remaining, lessThan);\r\n        }\r\n    };\r\n    PairingHeap.prototype.decreaseKey = function (subheap, newValue, setHeapNode, lessThan) {\r\n        var newHeap = subheap.removeMin(lessThan);\r\n        //reassign subheap values to preserve tree\r\n        subheap.elem = newHeap.elem;\r\n        subheap.subheaps = newHeap.subheaps;\r\n        if (setHeapNode !== null && newHeap.elem !== null) {\r\n            setHeapNode(subheap.elem, subheap);\r\n        }\r\n        var pairingNode = new PairingHeap(newValue);\r\n        if (setHeapNode !== null) {\r\n            setHeapNode(newValue, pairingNode);\r\n        }\r\n        return this.merge(pairingNode, lessThan);\r\n    };\r\n    return PairingHeap;\r\n})();\r\n/**\r\n * @class PriorityQueue a min priority queue backed by a pairing heap\r\n */\r\nvar PriorityQueue = (function () {\r\n    function PriorityQueue(lessThan) {\r\n        this.lessThan = lessThan;\r\n    }\r\n    /**\r\n     * @method top\r\n     * @return the top element (the min element as defined by lessThan)\r\n     */\r\n    PriorityQueue.prototype.top = function () {\r\n        if (this.empty()) {\r\n            return null;\r\n        }\r\n        return this.root.elem;\r\n    };\r\n    /**\r\n     * @method push\r\n     * put things on the heap\r\n     */\r\n    PriorityQueue.prototype.push = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i - 0] = arguments[_i];\r\n        }\r\n        var pairingNode;\r\n        for (var i = 0, arg; arg = args[i]; ++i) {\r\n            pairingNode = new PairingHeap(arg);\r\n            this.root = this.empty() ?\r\n                pairingNode : this.root.merge(pairingNode, this.lessThan);\r\n        }\r\n        return pairingNode;\r\n    };\r\n    /**\r\n     * @method empty\r\n     * @return true if no more elements in queue\r\n     */\r\n    PriorityQueue.prototype.empty = function () {\r\n        return !this.root || !this.root.elem;\r\n    };\r\n    /**\r\n     * @method isHeap check heap condition (for testing)\r\n     * @return true if queue is in valid state\r\n     */\r\n    PriorityQueue.prototype.isHeap = function () {\r\n        return this.root.isHeap(this.lessThan);\r\n    };\r\n    /**\r\n     * @method forEach apply f to each element of the queue\r\n     * @param f function to apply\r\n     */\r\n    PriorityQueue.prototype.forEach = function (f) {\r\n        this.root.forEach(f);\r\n    };\r\n    /**\r\n     * @method pop remove and return the min element from the queue\r\n     */\r\n    PriorityQueue.prototype.pop = function () {\r\n        if (this.empty()) {\r\n            return null;\r\n        }\r\n        var obj = this.root.min();\r\n        this.root = this.root.removeMin(this.lessThan);\r\n        return obj;\r\n    };\r\n    /**\r\n     * @method reduceKey reduce the key value of the specified heap node\r\n     */\r\n    PriorityQueue.prototype.reduceKey = function (heapNode, newKey, setHeapNode) {\r\n        if (setHeapNode === void 0) { setHeapNode = null; }\r\n        this.root = this.root.decreaseKey(heapNode, newKey, setHeapNode, this.lessThan);\r\n    };\r\n    PriorityQueue.prototype.toString = function (selector) {\r\n        return this.root.toString(selector);\r\n    };\r\n    /**\r\n     * @method count\r\n     * @return number of elements in queue\r\n     */\r\n    PriorityQueue.prototype.count = function () {\r\n        return this.root.count();\r\n    };\r\n    return PriorityQueue;\r\n})();\r\n///<reference path=\"pqueue.ts\"/>\r\n/**\r\n * @module shortestpaths\r\n */\r\nvar cola;\r\n(function (cola) {\r\n    var shortestpaths;\r\n    (function (shortestpaths) {\r\n        var Neighbour = (function () {\r\n            function Neighbour(id, distance) {\r\n                this.id = id;\r\n                this.distance = distance;\r\n            }\r\n            return Neighbour;\r\n        })();\r\n        var Node = (function () {\r\n            function Node(id) {\r\n                this.id = id;\r\n                this.neighbours = [];\r\n            }\r\n            return Node;\r\n        })();\r\n        var QueueEntry = (function () {\r\n            function QueueEntry(node, prev, d) {\r\n                this.node = node;\r\n                this.prev = prev;\r\n                this.d = d;\r\n            }\r\n            return QueueEntry;\r\n        })();\r\n        /**\r\n         * calculates all-pairs shortest paths or shortest paths from a single node\r\n         * @class Calculator\r\n         * @constructor\r\n         * @param n {number} number of nodes\r\n         * @param es {Edge[]} array of edges\r\n         */\r\n        var Calculator = (function () {\r\n            function Calculator(n, es, getSourceIndex, getTargetIndex, getLength) {\r\n                this.n = n;\r\n                this.es = es;\r\n                this.neighbours = new Array(this.n);\r\n                var i = this.n;\r\n                while (i--)\r\n                    this.neighbours[i] = new Node(i);\r\n                i = this.es.length;\r\n                while (i--) {\r\n                    var e = this.es[i];\r\n                    var u = getSourceIndex(e), v = getTargetIndex(e);\r\n                    var d = getLength(e);\r\n                    this.neighbours[u].neighbours.push(new Neighbour(v, d));\r\n                    this.neighbours[v].neighbours.push(new Neighbour(u, d));\r\n                }\r\n            }\r\n            /**\r\n             * compute shortest paths for graph over n nodes with edges an array of source/target pairs\r\n             * edges may optionally have a length attribute.  1 is the default.\r\n             * Uses Johnson's algorithm.\r\n             *\r\n             * @method DistanceMatrix\r\n             * @return the distance matrix\r\n             */\r\n            Calculator.prototype.DistanceMatrix = function () {\r\n                var D = new Array(this.n);\r\n                for (var i = 0; i < this.n; ++i) {\r\n                    D[i] = this.dijkstraNeighbours(i);\r\n                }\r\n                return D;\r\n            };\r\n            /**\r\n             * get shortest paths from a specified start node\r\n             * @method DistancesFromNode\r\n             * @param start node index\r\n             * @return array of path lengths\r\n             */\r\n            Calculator.prototype.DistancesFromNode = function (start) {\r\n                return this.dijkstraNeighbours(start);\r\n            };\r\n            Calculator.prototype.PathFromNodeToNode = function (start, end) {\r\n                return this.dijkstraNeighbours(start, end);\r\n            };\r\n            // find shortest path from start to end, with the opportunity at \r\n            // each edge traversal to compute a custom cost based on the \r\n            // previous edge.  For example, to penalise bends.\r\n            Calculator.prototype.PathFromNodeToNodeWithPrevCost = function (start, end, prevCost) {\r\n                var q = new PriorityQueue(function (a, b) { return a.d <= b.d; }), u = this.neighbours[start], qu = new QueueEntry(u, null, 0), visitedFrom = {};\r\n                q.push(qu);\r\n                while (!q.empty()) {\r\n                    qu = q.pop();\r\n                    u = qu.node;\r\n                    if (u.id === end) {\r\n                        break;\r\n                    }\r\n                    var i = u.neighbours.length;\r\n                    while (i--) {\r\n                        var neighbour = u.neighbours[i], v = this.neighbours[neighbour.id];\r\n                        // don't double back\r\n                        if (qu.prev && v.id === qu.prev.node.id)\r\n                            continue;\r\n                        // don't retraverse an edge if it has already been explored\r\n                        // from a lower cost route\r\n                        var viduid = v.id + ',' + u.id;\r\n                        if (viduid in visitedFrom && visitedFrom[viduid] <= qu.d)\r\n                            continue;\r\n                        var cc = qu.prev ? prevCost(qu.prev.node.id, u.id, v.id) : 0, t = qu.d + neighbour.distance + cc;\r\n                        // store cost of this traversal\r\n                        visitedFrom[viduid] = t;\r\n                        q.push(new QueueEntry(v, qu, t));\r\n                    }\r\n                }\r\n                var path = [];\r\n                while (qu.prev) {\r\n                    qu = qu.prev;\r\n                    path.push(qu.node.id);\r\n                }\r\n                return path;\r\n            };\r\n            Calculator.prototype.dijkstraNeighbours = function (start, dest) {\r\n                if (dest === void 0) { dest = -1; }\r\n                var q = new PriorityQueue(function (a, b) { return a.d <= b.d; }), i = this.neighbours.length, d = new Array(i);\r\n                while (i--) {\r\n                    var node = this.neighbours[i];\r\n                    node.d = i === start ? 0 : Number.POSITIVE_INFINITY;\r\n                    node.q = q.push(node);\r\n                }\r\n                while (!q.empty()) {\r\n                    // console.log(q.toString(function (u) { return u.id + \"=\" + (u.d === Number.POSITIVE_INFINITY ? \"\\u221E\" : u.d.toFixed(2) )}));\r\n                    var u = q.pop();\r\n                    d[u.id] = u.d;\r\n                    if (u.id === dest) {\r\n                        var path = [];\r\n                        var v = u;\r\n                        while (typeof v.prev !== 'undefined') {\r\n                            path.push(v.prev.id);\r\n                            v = v.prev;\r\n                        }\r\n                        return path;\r\n                    }\r\n                    i = u.neighbours.length;\r\n                    while (i--) {\r\n                        var neighbour = u.neighbours[i];\r\n                        var v = this.neighbours[neighbour.id];\r\n                        var t = u.d + neighbour.distance;\r\n                        if (u.d !== Number.MAX_VALUE && v.d > t) {\r\n                            v.d = t;\r\n                            v.prev = u;\r\n                            q.reduceKey(v.q, v, function (e, q) { return e.q = q; });\r\n                        }\r\n                    }\r\n                }\r\n                return d;\r\n            };\r\n            return Calculator;\r\n        })();\r\n        shortestpaths.Calculator = Calculator;\r\n    })(shortestpaths = cola.shortestpaths || (cola.shortestpaths = {}));\r\n})(cola || (cola = {}));\r\n///<reference path=\"handledisconnected.ts\"/>\r\n///<reference path=\"geom.ts\"/>\r\n///<reference path=\"descent.ts\"/>\r\n///<reference path=\"powergraph.ts\"/>\r\n///<reference path=\"linklengths.ts\"/>\r\n///<reference path=\"shortestpaths.ts\"/>\r\n/**\r\n * @module cola\r\n */\r\nvar cola;\r\n(function (cola) {\r\n    /**\r\n     * The layout process fires three events:\r\n     *  - start: layout iterations started\r\n     *  - tick: fired once per iteration, listen to this to animate\r\n     *  - end: layout converged, you might like to zoom-to-fit or something at notification of this event\r\n     */\r\n    (function (EventType) {\r\n        EventType[EventType[\"start\"] = 0] = \"start\";\r\n        EventType[EventType[\"tick\"] = 1] = \"tick\";\r\n        EventType[EventType[\"end\"] = 2] = \"end\";\r\n    })(cola.EventType || (cola.EventType = {}));\r\n    var EventType = cola.EventType;\r\n    ;\r\n    function isGroup(g) {\r\n        return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';\r\n    }\r\n    /**\r\n     * Main interface to cola layout.\r\n     * @class Layout\r\n     */\r\n    var Layout = (function () {\r\n        function Layout() {\r\n            var _this = this;\r\n            this._canvasSize = [1, 1];\r\n            this._linkDistance = 20;\r\n            this._defaultNodeSize = 10;\r\n            this._linkLengthCalculator = null;\r\n            this._linkType = null;\r\n            this._avoidOverlaps = false;\r\n            this._handleDisconnected = true;\r\n            this._running = false;\r\n            this._nodes = [];\r\n            this._groups = [];\r\n            this._rootGroup = null;\r\n            this._links = [];\r\n            this._constraints = [];\r\n            this._distanceMatrix = null;\r\n            this._descent = null;\r\n            this._directedLinkConstraints = null;\r\n            this._threshold = 0.01;\r\n            this._visibilityGraph = null;\r\n            this._groupCompactness = 1e-6;\r\n            // sub-class and override this property to replace with a more sophisticated eventing mechanism\r\n            this.event = null;\r\n            this.linkAccessor = {\r\n                getSourceIndex: Layout.getSourceIndex,\r\n                getTargetIndex: Layout.getTargetIndex,\r\n                setLength: Layout.setLinkLength,\r\n                getType: function (l) { return typeof _this._linkType === \"function\" ? _this._linkType(l) : 0; }\r\n            };\r\n        }\r\n        // subscribe a listener to an event\r\n        // sub-class and override this method to replace with a more sophisticated eventing mechanism\r\n        Layout.prototype.on = function (e, listener) {\r\n            // override me!\r\n            if (!this.event)\r\n                this.event = {};\r\n            if (typeof e === 'string') {\r\n                this.event[EventType[e]] = listener;\r\n            }\r\n            else {\r\n                this.event[e] = listener;\r\n            }\r\n            return this;\r\n        };\r\n        // a function that is notified of events like \"tick\"\r\n        // sub-class and override this method to replace with a more sophisticated eventing mechanism\r\n        Layout.prototype.trigger = function (e) {\r\n            if (this.event && typeof this.event[e.type] !== 'undefined') {\r\n                this.event[e.type](e);\r\n            }\r\n        };\r\n        // a function that kicks off the iteration tick loop\r\n        // it calls tick() repeatedly until tick returns true (is converged)\r\n        // subclass and override it with something fancier (e.g. dispatch tick on a timer)\r\n        Layout.prototype.kick = function () {\r\n            while (!this.tick())\r\n                ;\r\n        };\r\n        /**\r\n         * iterate the layout.  Returns true when layout converged.\r\n         */\r\n        Layout.prototype.tick = function () {\r\n            if (this._alpha < this._threshold) {\r\n                this._running = false;\r\n                this.trigger({ type: EventType.end, alpha: this._alpha = 0, stress: this._lastStress });\r\n                return true;\r\n            }\r\n            var n = this._nodes.length, m = this._links.length;\r\n            var o, i;\r\n            this._descent.locks.clear();\r\n            for (i = 0; i < n; ++i) {\r\n                o = this._nodes[i];\r\n                if (o.fixed) {\r\n                    if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {\r\n                        o.px = o.x;\r\n                        o.py = o.y;\r\n                    }\r\n                    var p = [o.px, o.py];\r\n                    this._descent.locks.add(i, p);\r\n                }\r\n            }\r\n            var s1 = this._descent.rungeKutta();\r\n            //var s1 = descent.reduceStress();\r\n            if (s1 === 0) {\r\n                this._alpha = 0;\r\n            }\r\n            else if (typeof this._lastStress !== 'undefined') {\r\n                this._alpha = s1; //Math.abs(Math.abs(this._lastStress / s1) - 1);\r\n            }\r\n            this._lastStress = s1;\r\n            this.updateNodePositions();\r\n            this.trigger({ type: EventType.tick, alpha: this._alpha, stress: this._lastStress });\r\n            return false;\r\n        };\r\n        // copy positions out of descent instance into each of the nodes' center coords\r\n        Layout.prototype.updateNodePositions = function () {\r\n            var x = this._descent.x[0], y = this._descent.x[1];\r\n            var o, i = this._nodes.length;\r\n            while (i--) {\r\n                o = this._nodes[i];\r\n                o.x = x[i];\r\n                o.y = y[i];\r\n            }\r\n        };\r\n        Layout.prototype.nodes = function (v) {\r\n            if (!v) {\r\n                if (this._nodes.length === 0 && this._links.length > 0) {\r\n                    // if we have links but no nodes, create the nodes array now with empty objects for the links to point at.\r\n                    // in this case the links are expected to be numeric indices for nodes in the range 0..n-1 where n is the number of nodes\r\n                    var n = 0;\r\n                    this._links.forEach(function (l) {\r\n                        n = Math.max(n, l.source, l.target);\r\n                    });\r\n                    this._nodes = new Array(++n);\r\n                    for (var i = 0; i < n; ++i) {\r\n                        this._nodes[i] = {};\r\n                    }\r\n                }\r\n                return this._nodes;\r\n            }\r\n            this._nodes = v;\r\n            return this;\r\n        };\r\n        Layout.prototype.groups = function (x) {\r\n            var _this = this;\r\n            if (!x)\r\n                return this._groups;\r\n            this._groups = x;\r\n            this._rootGroup = {};\r\n            this._groups.forEach(function (g) {\r\n                if (typeof g.padding === \"undefined\")\r\n                    g.padding = 1;\r\n                if (typeof g.leaves !== \"undefined\")\r\n                    g.leaves.forEach(function (v, i) { (g.leaves[i] = _this._nodes[v]).parent = g; });\r\n                if (typeof g.groups !== \"undefined\")\r\n                    g.groups.forEach(function (gi, i) { (g.groups[i] = _this._groups[gi]).parent = g; });\r\n            });\r\n            this._rootGroup.leaves = this._nodes.filter(function (v) { return typeof v.parent === 'undefined'; });\r\n            this._rootGroup.groups = this._groups.filter(function (g) { return typeof g.parent === 'undefined'; });\r\n            return this;\r\n        };\r\n        Layout.prototype.powerGraphGroups = function (f) {\r\n            var g = cola.powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);\r\n            this.groups(g.groups);\r\n            f(g);\r\n            return this;\r\n        };\r\n        Layout.prototype.avoidOverlaps = function (v) {\r\n            if (!arguments.length)\r\n                return this._avoidOverlaps;\r\n            this._avoidOverlaps = v;\r\n            return this;\r\n        };\r\n        Layout.prototype.handleDisconnected = function (v) {\r\n            if (!arguments.length)\r\n                return this._handleDisconnected;\r\n            this._handleDisconnected = v;\r\n            return this;\r\n        };\r\n        /**\r\n         * causes constraints to be generated such that directed graphs are laid out either from left-to-right or top-to-bottom.\r\n         * a separation constraint is generated in the selected axis for each edge that is not involved in a cycle (part of a strongly connected component)\r\n         * @param axis {string} 'x' for left-to-right, 'y' for top-to-bottom\r\n         * @param minSeparation {number|link=>number} either a number specifying a minimum spacing required across all links or a function to return the minimum spacing for each link\r\n         */\r\n        Layout.prototype.flowLayout = function (axis, minSeparation) {\r\n            if (!arguments.length)\r\n                axis = 'y';\r\n            this._directedLinkConstraints = {\r\n                axis: axis,\r\n                getMinSeparation: typeof minSeparation === 'number' ? function () { return minSeparation; } : minSeparation\r\n            };\r\n            return this;\r\n        };\r\n        Layout.prototype.links = function (x) {\r\n            if (!arguments.length)\r\n                return this._links;\r\n            this._links = x;\r\n            return this;\r\n        };\r\n        Layout.prototype.constraints = function (c) {\r\n            if (!arguments.length)\r\n                return this._constraints;\r\n            this._constraints = c;\r\n            return this;\r\n        };\r\n        Layout.prototype.distanceMatrix = function (d) {\r\n            if (!arguments.length)\r\n                return this._distanceMatrix;\r\n            this._distanceMatrix = d;\r\n            return this;\r\n        };\r\n        Layout.prototype.size = function (x) {\r\n            if (!x)\r\n                return this._canvasSize;\r\n            this._canvasSize = x;\r\n            return this;\r\n        };\r\n        Layout.prototype.defaultNodeSize = function (x) {\r\n            if (!x)\r\n                return this._defaultNodeSize;\r\n            this._defaultNodeSize = x;\r\n            return this;\r\n        };\r\n        Layout.prototype.groupCompactness = function (x) {\r\n            if (!x)\r\n                return this._groupCompactness;\r\n            this._groupCompactness = x;\r\n            return this;\r\n        };\r\n        Layout.prototype.linkDistance = function (x) {\r\n            if (!x) {\r\n                return this._linkDistance;\r\n            }\r\n            this._linkDistance = typeof x === \"function\" ? x : +x;\r\n            this._linkLengthCalculator = null;\r\n            return this;\r\n        };\r\n        Layout.prototype.linkType = function (f) {\r\n            this._linkType = f;\r\n            return this;\r\n        };\r\n        Layout.prototype.convergenceThreshold = function (x) {\r\n            if (!x)\r\n                return this._threshold;\r\n            this._threshold = typeof x === \"function\" ? x : +x;\r\n            return this;\r\n        };\r\n        Layout.prototype.alpha = function (x) {\r\n            if (!arguments.length)\r\n                return this._alpha;\r\n            else {\r\n                x = +x;\r\n                if (this._alpha) {\r\n                    if (x > 0)\r\n                        this._alpha = x; // we might keep it hot\r\n                    else\r\n                        this._alpha = 0; // or, next tick will dispatch \"end\"\r\n                }\r\n                else if (x > 0) {\r\n                    if (!this._running) {\r\n                        this._running = true;\r\n                        this.trigger({ type: EventType.start, alpha: this._alpha = x });\r\n                        this.kick();\r\n                    }\r\n                }\r\n                return this;\r\n            }\r\n        };\r\n        Layout.prototype.getLinkLength = function (link) {\r\n            return typeof this._linkDistance === \"function\" ? +(this._linkDistance(link)) : this._linkDistance;\r\n        };\r\n        Layout.setLinkLength = function (link, length) {\r\n            link.length = length;\r\n        };\r\n        Layout.prototype.getLinkType = function (link) {\r\n            return typeof this._linkType === \"function\" ? this._linkType(link) : 0;\r\n        };\r\n        /**\r\n         * compute an ideal length for each link based on the graph structure around that link.\r\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\r\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\r\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: sqrt(|a union b| - |a intersection b|)\r\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\r\n         * don't have to have been assigned before invoking this function.\r\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\r\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\r\n         */\r\n        Layout.prototype.symmetricDiffLinkLengths = function (idealLength, w) {\r\n            var _this = this;\r\n            if (w === void 0) { w = 1; }\r\n            this.linkDistance(function (l) { return idealLength * l.length; });\r\n            this._linkLengthCalculator = function () { return cola.symmetricDiffLinkLengths(_this._links, _this.linkAccessor, w); };\r\n            return this;\r\n        };\r\n        /**\r\n         * compute an ideal length for each link based on the graph structure around that link.\r\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\r\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\r\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: |a intersection b|/|a union b|\r\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\r\n         * don't have to have been assigned before invoking this function.\r\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\r\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\r\n         */\r\n        Layout.prototype.jaccardLinkLengths = function (idealLength, w) {\r\n            var _this = this;\r\n            if (w === void 0) { w = 1; }\r\n            this.linkDistance(function (l) { return idealLength * l.length; });\r\n            this._linkLengthCalculator = function () { return cola.jaccardLinkLengths(_this._links, _this.linkAccessor, w); };\r\n            return this;\r\n        };\r\n        /**\r\n         * start the layout process\r\n         * @method start\r\n         * @param {number} [initialUnconstrainedIterations=0] unconstrained initial layout iterations\r\n         * @param {number} [initialUserConstraintIterations=0] initial layout iterations with user-specified constraints\r\n         * @param {number} [initialAllConstraintsIterations=0] initial layout iterations with all constraints including non-overlap\r\n         * @param {number} [gridSnapIterations=0] iterations of \"grid snap\", which pulls nodes towards grid cell centers - grid of size node[0].width - only really makes sense if all nodes have the same width and height\r\n         * @param [keepRunning=true] keep iterating asynchronously via the tick method\r\n         */\r\n        Layout.prototype.start = function (initialUnconstrainedIterations, initialUserConstraintIterations, initialAllConstraintsIterations, gridSnapIterations, keepRunning) {\r\n            var _this = this;\r\n            if (initialUnconstrainedIterations === void 0) { initialUnconstrainedIterations = 0; }\r\n            if (initialUserConstraintIterations === void 0) { initialUserConstraintIterations = 0; }\r\n            if (initialAllConstraintsIterations === void 0) { initialAllConstraintsIterations = 0; }\r\n            if (gridSnapIterations === void 0) { gridSnapIterations = 0; }\r\n            if (keepRunning === void 0) { keepRunning = true; }\r\n            var i, j, n = this.nodes().length, N = n + 2 * this._groups.length, m = this._links.length, w = this._canvasSize[0], h = this._canvasSize[1];\r\n            if (this._linkLengthCalculator)\r\n                this._linkLengthCalculator();\r\n            var x = new Array(N), y = new Array(N);\r\n            var G = null;\r\n            var ao = this._avoidOverlaps;\r\n            this._nodes.forEach(function (v, i) {\r\n                v.index = i;\r\n                if (typeof v.x === 'undefined') {\r\n                    v.x = w / 2, v.y = h / 2;\r\n                }\r\n                x[i] = v.x, y[i] = v.y;\r\n            });\r\n            //should we do this to clearly label groups?\r\n            //this._groups.forEach((g, i) => g.groupIndex = i);\r\n            var distances;\r\n            if (this._distanceMatrix) {\r\n                // use the user specified distanceMatrix\r\n                distances = this._distanceMatrix;\r\n            }\r\n            else {\r\n                // construct an n X n distance matrix based on shortest paths through graph (with respect to edge.length).\r\n                distances = (new cola.shortestpaths.Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, function (l) { return _this.getLinkLength(l); })).DistanceMatrix();\r\n                // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\r\n                // otherwise 2. (\r\n                G = cola.Descent.createSquareMatrix(N, function () { return 2; });\r\n                this._links.forEach(function (l) {\r\n                    if (typeof l.source == \"number\")\r\n                        l.source = _this._nodes[l.source];\r\n                    if (typeof l.target == \"number\")\r\n                        l.target = _this._nodes[l.target];\r\n                });\r\n                this._links.forEach(function (e) {\r\n                    var u = Layout.getSourceIndex(e), v = Layout.getTargetIndex(e);\r\n                    G[u][v] = G[v][u] = e.weight || 1;\r\n                });\r\n            }\r\n            var D = cola.Descent.createSquareMatrix(N, function (i, j) {\r\n                return distances[i][j];\r\n            });\r\n            if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {\r\n                var i = n;\r\n                var addAttraction = function (i, j, strength, idealDistance) {\r\n                    G[i][j] = G[j][i] = strength;\r\n                    D[i][j] = D[j][i] = idealDistance;\r\n                };\r\n                this._groups.forEach(function (g) {\r\n                    addAttraction(i, i + 1, _this._groupCompactness, 0.1);\r\n                    // todo: add terms here attracting children of the group to the group dummy nodes\r\n                    //if (typeof g.leaves !== 'undefined')\r\n                    //    g.leaves.forEach(l => {\r\n                    //        addAttraction(l.index, i, 1e-4, 0.1);\r\n                    //        addAttraction(l.index, i + 1, 1e-4, 0.1);\r\n                    //    });\r\n                    //if (typeof g.groups !== 'undefined')\r\n                    //    g.groups.forEach(g => {\r\n                    //        var gid = n + g.groupIndex * 2;\r\n                    //        addAttraction(gid, i, 0.1, 0.1);\r\n                    //        addAttraction(gid + 1, i, 0.1, 0.1);\r\n                    //        addAttraction(gid, i + 1, 0.1, 0.1);\r\n                    //        addAttraction(gid + 1, i + 1, 0.1, 0.1);\r\n                    //    });\r\n                    x[i] = 0, y[i++] = 0;\r\n                    x[i] = 0, y[i++] = 0;\r\n                });\r\n            }\r\n            else\r\n                this._rootGroup = { leaves: this._nodes, groups: [] };\r\n            var curConstraints = this._constraints || [];\r\n            if (this._directedLinkConstraints) {\r\n                this.linkAccessor.getMinSeparation = this._directedLinkConstraints.getMinSeparation;\r\n                curConstraints = curConstraints.concat(cola.generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, (this.linkAccessor)));\r\n            }\r\n            this.avoidOverlaps(false);\r\n            this._descent = new cola.Descent([x, y], D);\r\n            this._descent.locks.clear();\r\n            for (var i = 0; i < n; ++i) {\r\n                var o = this._nodes[i];\r\n                if (o.fixed) {\r\n                    o.px = o.x;\r\n                    o.py = o.y;\r\n                    var p = [o.x, o.y];\r\n                    this._descent.locks.add(i, p);\r\n                }\r\n            }\r\n            this._descent.threshold = this._threshold;\r\n            // apply initialIterations without user constraints or nonoverlap constraints\r\n            // if groups are specified, dummy nodes and edges will be added to untangle\r\n            // with respect to group connectivity\r\n            this.initialLayout(initialUnconstrainedIterations, x, y);\r\n            // apply initialIterations with user constraints but no nonoverlap constraints\r\n            if (curConstraints.length > 0)\r\n                this._descent.project = new cola.vpsc.Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();\r\n            this._descent.run(initialUserConstraintIterations);\r\n            this.separateOverlappingComponents(w, h);\r\n            // subsequent iterations will apply all constraints\r\n            this.avoidOverlaps(ao);\r\n            if (ao) {\r\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\r\n                this._descent.project = new cola.vpsc.Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();\r\n                this._nodes.forEach(function (v, i) { x[i] = v.x, y[i] = v.y; });\r\n            }\r\n            // allow not immediately connected nodes to relax apart (p-stress)\r\n            this._descent.G = G;\r\n            this._descent.run(initialAllConstraintsIterations);\r\n            if (gridSnapIterations) {\r\n                this._descent.snapStrength = 1000;\r\n                this._descent.snapGridSize = this._nodes[0].width;\r\n                this._descent.numGridSnapNodes = n;\r\n                this._descent.scaleSnapByMaxH = n != N; // if we have groups then need to scale hessian so grid forces still apply\r\n                var G0 = cola.Descent.createSquareMatrix(N, function (i, j) {\r\n                    if (i >= n || j >= n)\r\n                        return G[i][j];\r\n                    return 0;\r\n                });\r\n                this._descent.G = G0;\r\n                this._descent.run(gridSnapIterations);\r\n            }\r\n            this.updateNodePositions();\r\n            this.separateOverlappingComponents(w, h);\r\n            return keepRunning ? this.resume() : this;\r\n        };\r\n        Layout.prototype.initialLayout = function (iterations, x, y) {\r\n            if (this._groups.length > 0 && iterations > 0) {\r\n                // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children\r\n                // todo: edges attached to groups are replaced with edges connected to the corresponding group dummy node\r\n                var n = this._nodes.length;\r\n                var edges = this._links.map(function (e) { return { source: e.source.index, target: e.target.index }; });\r\n                var vs = this._nodes.map(function (v) { return { index: v.index }; });\r\n                this._groups.forEach(function (g, i) {\r\n                    vs.push({ index: g.index = n + i });\r\n                });\r\n                this._groups.forEach(function (g, i) {\r\n                    if (typeof g.leaves !== 'undefined')\r\n                        g.leaves.forEach(function (v) { return edges.push({ source: g.index, target: v.index }); });\r\n                    if (typeof g.groups !== 'undefined')\r\n                        g.groups.forEach(function (gg) { return edges.push({ source: g.index, target: gg.index }); });\r\n                });\r\n                // layout the flat graph with dummy nodes and edges\r\n                new cola.Layout()\r\n                    .size(this.size())\r\n                    .nodes(vs)\r\n                    .links(edges)\r\n                    .avoidOverlaps(false)\r\n                    .linkDistance(this.linkDistance())\r\n                    .symmetricDiffLinkLengths(5)\r\n                    .convergenceThreshold(1e-4)\r\n                    .start(iterations, 0, 0, 0, false);\r\n                this._nodes.forEach(function (v) {\r\n                    x[v.index] = vs[v.index].x;\r\n                    y[v.index] = vs[v.index].y;\r\n                });\r\n            }\r\n            else {\r\n                this._descent.run(iterations);\r\n            }\r\n        };\r\n        // recalculate nodes position for disconnected graphs\r\n        Layout.prototype.separateOverlappingComponents = function (width, height) {\r\n            var _this = this;\r\n            // recalculate nodes position for disconnected graphs\r\n            if (!this._distanceMatrix && this._handleDisconnected) {\r\n                var x = this._descent.x[0], y = this._descent.x[1];\r\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\r\n                var graphs = cola.separateGraphs(this._nodes, this._links);\r\n                cola.applyPacking(graphs, width, height, this._defaultNodeSize);\r\n                this._nodes.forEach(function (v, i) {\r\n                    _this._descent.x[0][i] = v.x, _this._descent.x[1][i] = v.y;\r\n                    if (v.bounds) {\r\n                        v.bounds.setXCentre(v.x);\r\n                        v.bounds.setYCentre(v.y);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        Layout.prototype.resume = function () {\r\n            return this.alpha(0.1);\r\n        };\r\n        Layout.prototype.stop = function () {\r\n            return this.alpha(0);\r\n        };\r\n        /// find a visibility graph over the set of nodes.  assumes all nodes have a\r\n        /// bounds property (a rectangle) and that no pair of bounds overlaps.\r\n        Layout.prototype.prepareEdgeRouting = function (nodeMargin) {\r\n            if (nodeMargin === void 0) { nodeMargin = 0; }\r\n            this._visibilityGraph = new cola.geom.TangentVisibilityGraph(this._nodes.map(function (v) {\r\n                return v.bounds.inflate(-nodeMargin).vertices();\r\n            }));\r\n        };\r\n        /// find a route avoiding node bounds for the given edge.\r\n        /// assumes the visibility graph has been created (by prepareEdgeRouting method)\r\n        /// and also assumes that nodes have an index property giving their position in the\r\n        /// node array.  This index property is created by the start() method.\r\n        Layout.prototype.routeEdge = function (edge, draw) {\r\n            var lineData = [];\r\n            //if (d.source.id === 10 && d.target.id === 11) {\r\n            //    debugger;\r\n            //}\r\n            var vg2 = new cola.geom.TangentVisibilityGraph(this._visibilityGraph.P, { V: this._visibilityGraph.V, E: this._visibilityGraph.E }), port1 = { x: edge.source.x, y: edge.source.y }, port2 = { x: edge.target.x, y: edge.target.y }, start = vg2.addPoint(port1, edge.source.index), end = vg2.addPoint(port2, edge.target.index);\r\n            vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);\r\n            if (typeof draw !== 'undefined') {\r\n                draw(vg2);\r\n            }\r\n            var sourceInd = function (e) { return e.source.id; }, targetInd = function (e) { return e.target.id; }, length = function (e) { return e.length(); }, spCalc = new cola.shortestpaths.Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length), shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);\r\n            if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {\r\n                var route = cola.vpsc.makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, 5);\r\n                lineData = [route.sourceIntersection, route.arrowStart];\r\n            }\r\n            else {\r\n                var n = shortestPath.length - 2, p = vg2.V[shortestPath[n]].p, q = vg2.V[shortestPath[0]].p, lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];\r\n                for (var i = n; i >= 0; --i)\r\n                    lineData.push(vg2.V[shortestPath[i]].p);\r\n                lineData.push(cola.vpsc.makeEdgeTo(q, edge.target.innerBounds, 5));\r\n            }\r\n            //lineData.forEach((v, i) => {\r\n            //    if (i > 0) {\r\n            //        var u = lineData[i - 1];\r\n            //        this._nodes.forEach(function (node) {\r\n            //            if (node.id === getSourceIndex(d) || node.id === getTargetIndex(d)) return;\r\n            //            var ints = node.innerBounds.lineIntersections(u.x, u.y, v.x, v.y);\r\n            //            if (ints.length > 0) {\r\n            //                debugger;\r\n            //            }\r\n            //        })\r\n            //    }\r\n            //})\r\n            return lineData;\r\n        };\r\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\r\n        Layout.getSourceIndex = function (e) {\r\n            return typeof e.source === 'number' ? e.source : e.source.index;\r\n        };\r\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\r\n        Layout.getTargetIndex = function (e) {\r\n            return typeof e.target === 'number' ? e.target : e.target.index;\r\n        };\r\n        // Get a string ID for a given link.\r\n        Layout.linkId = function (e) {\r\n            return Layout.getSourceIndex(e) + \"-\" + Layout.getTargetIndex(e);\r\n        };\r\n        // The fixed property has three bits:\r\n        // Bit 1 can be set externally (e.g., d.fixed = true) and show persist.\r\n        // Bit 2 stores the dragging state, from mousedown to mouseup.\r\n        // Bit 3 stores the hover state, from mouseover to mouseout.\r\n        Layout.dragStart = function (d) {\r\n            if (isGroup(d)) {\r\n                Layout.storeOffset(d, Layout.dragOrigin(d));\r\n            }\r\n            else {\r\n                Layout.stopNode(d);\r\n                d.fixed |= 2; // set bit 2\r\n            }\r\n        };\r\n        // we clobber any existing desired positions for nodes\r\n        // in case another tick event occurs before the drag\r\n        Layout.stopNode = function (v) {\r\n            v.px = v.x;\r\n            v.py = v.y;\r\n        };\r\n        // we store offsets for each node relative to the centre of the ancestor group \r\n        // being dragged in a pair of properties on the node\r\n        Layout.storeOffset = function (d, origin) {\r\n            if (typeof d.leaves !== 'undefined') {\r\n                d.leaves.forEach(function (v) {\r\n                    v.fixed |= 2;\r\n                    Layout.stopNode(v);\r\n                    v._dragGroupOffsetX = v.x - origin.x;\r\n                    v._dragGroupOffsetY = v.y - origin.y;\r\n                });\r\n            }\r\n            if (typeof d.groups !== 'undefined') {\r\n                d.groups.forEach(function (g) { return Layout.storeOffset(g, origin); });\r\n            }\r\n        };\r\n        // the drag origin is taken as the centre of the node or group\r\n        Layout.dragOrigin = function (d) {\r\n            if (isGroup(d)) {\r\n                return {\r\n                    x: d.bounds.cx(),\r\n                    y: d.bounds.cy()\r\n                };\r\n            }\r\n            else {\r\n                return d;\r\n            }\r\n        };\r\n        // for groups, the drag translation is propagated down to all of the children of\r\n        // the group.\r\n        Layout.drag = function (d, position) {\r\n            if (isGroup(d)) {\r\n                if (typeof d.leaves !== 'undefined') {\r\n                    d.leaves.forEach(function (v) {\r\n                        d.bounds.setXCentre(position.x);\r\n                        d.bounds.setYCentre(position.y);\r\n                        v.px = v._dragGroupOffsetX + position.x;\r\n                        v.py = v._dragGroupOffsetY + position.y;\r\n                    });\r\n                }\r\n                if (typeof d.groups !== 'undefined') {\r\n                    d.groups.forEach(function (g) { return Layout.drag(g, position); });\r\n                }\r\n            }\r\n            else {\r\n                d.px = position.x;\r\n                d.py = position.y;\r\n            }\r\n        };\r\n        // we unset only bits 2 and 3 so that the user can fix nodes with another a different\r\n        // bit such that the lock persists between drags \r\n        Layout.dragEnd = function (d) {\r\n            if (isGroup(d)) {\r\n                if (typeof d.leaves !== 'undefined') {\r\n                    d.leaves.forEach(function (v) {\r\n                        Layout.dragEnd(v);\r\n                        delete v._dragGroupOffsetX;\r\n                        delete v._dragGroupOffsetY;\r\n                    });\r\n                }\r\n                if (typeof d.groups !== 'undefined') {\r\n                    d.groups.forEach(Layout.dragEnd);\r\n                }\r\n            }\r\n            else {\r\n                d.fixed &= ~6; // unset bits 2 and 3\r\n            }\r\n        };\r\n        // in d3 hover temporarily locks nodes, currently not used in cola\r\n        Layout.mouseOver = function (d) {\r\n            d.fixed |= 4; // set bit 3\r\n            d.px = d.x, d.py = d.y; // set velocity to zero\r\n        };\r\n        // in d3 hover temporarily locks nodes, currently not used in cola\r\n        Layout.mouseOut = function (d) {\r\n            d.fixed &= ~4; // unset bit 3\r\n        };\r\n        return Layout;\r\n    })();\r\n    cola.Layout = Layout;\r\n})(cola || (cola = {}));\r\n///<reference path=\"../extern/d3.d.ts\"/>\r\n///<reference path=\"layout.ts\"/>\r\nvar cola;\r\n(function (cola) {\r\n    var D3StyleLayoutAdaptor = (function (_super) {\r\n        __extends(D3StyleLayoutAdaptor, _super);\r\n        function D3StyleLayoutAdaptor() {\r\n            _super.call(this);\r\n            this.event = d3.dispatch(cola.EventType[cola.EventType.start], cola.EventType[cola.EventType.tick], cola.EventType[cola.EventType.end]);\r\n            // bit of trickyness remapping 'this' so we can reference it in the function body.\r\n            var d3layout = this;\r\n            var drag;\r\n            this.drag = function () {\r\n                if (!drag) {\r\n                    var drag = d3.behavior.drag()\r\n                        .origin(cola.Layout.dragOrigin)\r\n                        .on(\"dragstart.d3adaptor\", cola.Layout.dragStart)\r\n                        .on(\"drag.d3adaptor\", function (d) {\r\n                        cola.Layout.drag(d, d3.event);\r\n                        d3layout.resume(); // restart annealing\r\n                    })\r\n                        .on(\"dragend.d3adaptor\", cola.Layout.dragEnd);\r\n                }\r\n                if (!arguments.length)\r\n                    return drag;\r\n                // this is the context of the function, i.e. the d3 selection\r\n                this //.on(\"mouseover.adaptor\", colaMouseover)\r\n                    .call(drag);\r\n            };\r\n        }\r\n        D3StyleLayoutAdaptor.prototype.trigger = function (e) {\r\n            var d3event = { type: cola.EventType[e.type], alpha: e.alpha, stress: e.stress };\r\n            this.event[d3event.type](d3event); // via d3 dispatcher, e.g. event.start(e);\r\n        };\r\n        // iterate layout using a d3.timer, which queues calls to tick repeatedly until tick returns true\r\n        D3StyleLayoutAdaptor.prototype.kick = function () {\r\n            var _this = this;\r\n            d3.timer(function () { return _super.prototype.tick.call(_this); });\r\n        };\r\n        // a function for binding to events on the adapter\r\n        D3StyleLayoutAdaptor.prototype.on = function (eventType, listener) {\r\n            if (typeof eventType === 'string') {\r\n                this.event.on(eventType, listener);\r\n            }\r\n            else {\r\n                this.event.on(cola.EventType[eventType], listener);\r\n            }\r\n            return this;\r\n        };\r\n        return D3StyleLayoutAdaptor;\r\n    })(cola.Layout);\r\n    cola.D3StyleLayoutAdaptor = D3StyleLayoutAdaptor;\r\n    /**\r\n     * provides an interface for use with d3:\r\n     * - uses the d3 event system to dispatch layout events such as:\r\n     *   o \"start\" (start layout process)\r\n     *   o \"tick\" (after each layout iteration)\r\n     *   o \"end\" (layout converged and complete).\r\n     * - uses the d3 timer to queue layout iterations.\r\n     * - sets up d3.behavior.drag to drag nodes\r\n     *   o use `node.call(<the returned instance of Layout>.drag)` to make nodes draggable\r\n     * returns an instance of the cola.Layout itself with which the user\r\n     * can interact directly.\r\n     */\r\n    function d3adaptor() {\r\n        return new D3StyleLayoutAdaptor();\r\n    }\r\n    cola.d3adaptor = d3adaptor;\r\n})(cola || (cola = {}));\r\n/// <reference path=\"rectangle.ts\"/>\r\n/// <reference path=\"shortestpaths.ts\"/>\r\n/// <reference path=\"geom.ts\"/>\r\n/// <reference path=\"vpsc.ts\"/>\r\nvar cola;\r\n(function (cola) {\r\n    var NodeWrapper = (function () {\r\n        function NodeWrapper(id, rect, children) {\r\n            this.id = id;\r\n            this.rect = rect;\r\n            this.children = children;\r\n            this.leaf = typeof children === 'undefined' || children.length === 0;\r\n        }\r\n        return NodeWrapper;\r\n    })();\r\n    cola.NodeWrapper = NodeWrapper;\r\n    var Vert = (function () {\r\n        function Vert(id, x, y, node, line) {\r\n            if (node === void 0) { node = null; }\r\n            if (line === void 0) { line = null; }\r\n            this.id = id;\r\n            this.x = x;\r\n            this.y = y;\r\n            this.node = node;\r\n            this.line = line;\r\n        }\r\n        return Vert;\r\n    })();\r\n    cola.Vert = Vert;\r\n    var LongestCommonSubsequence = (function () {\r\n        function LongestCommonSubsequence(s, t) {\r\n            this.s = s;\r\n            this.t = t;\r\n            var mf = LongestCommonSubsequence.findMatch(s, t);\r\n            var tr = t.slice(0).reverse();\r\n            var mr = LongestCommonSubsequence.findMatch(s, tr);\r\n            if (mf.length >= mr.length) {\r\n                this.length = mf.length;\r\n                this.si = mf.si;\r\n                this.ti = mf.ti;\r\n                this.reversed = false;\r\n            }\r\n            else {\r\n                this.length = mr.length;\r\n                this.si = mr.si;\r\n                this.ti = t.length - mr.ti - mr.length;\r\n                this.reversed = true;\r\n            }\r\n        }\r\n        LongestCommonSubsequence.findMatch = function (s, t) {\r\n            var m = s.length;\r\n            var n = t.length;\r\n            var match = { length: 0, si: -1, ti: -1 };\r\n            var l = new Array(m);\r\n            for (var i = 0; i < m; i++) {\r\n                l[i] = new Array(n);\r\n                for (var j = 0; j < n; j++)\r\n                    if (s[i] === t[j]) {\r\n                        var v = l[i][j] = (i === 0 || j === 0) ? 1 : l[i - 1][j - 1] + 1;\r\n                        if (v > match.length) {\r\n                            match.length = v;\r\n                            match.si = i - v + 1;\r\n                            match.ti = j - v + 1;\r\n                        }\r\n                        ;\r\n                    }\r\n                    else\r\n                        l[i][j] = 0;\r\n            }\r\n            return match;\r\n        };\r\n        LongestCommonSubsequence.prototype.getSequence = function () {\r\n            return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];\r\n        };\r\n        return LongestCommonSubsequence;\r\n    })();\r\n    cola.LongestCommonSubsequence = LongestCommonSubsequence;\r\n    var GridRouter = (function () {\r\n        function GridRouter(originalnodes, accessor, groupPadding) {\r\n            var _this = this;\r\n            if (groupPadding === void 0) { groupPadding = 12; }\r\n            this.originalnodes = originalnodes;\r\n            this.groupPadding = groupPadding;\r\n            this.leaves = null;\r\n            this.nodes = originalnodes.map(function (v, i) { return new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v)); });\r\n            this.leaves = this.nodes.filter(function (v) { return v.leaf; });\r\n            this.groups = this.nodes.filter(function (g) { return !g.leaf; });\r\n            this.cols = this.getGridLines('x');\r\n            this.rows = this.getGridLines('y');\r\n            // create parents for each node or group that is a member of another's children \r\n            this.groups.forEach(function (v) {\r\n                return v.children.forEach(function (c) { return _this.nodes[c].parent = v; });\r\n            });\r\n            // root claims the remaining orphans\r\n            this.root = { children: [] };\r\n            this.nodes.forEach(function (v) {\r\n                if (typeof v.parent === 'undefined') {\r\n                    v.parent = _this.root;\r\n                    _this.root.children.push(v.id);\r\n                }\r\n                // each node will have grid vertices associated with it,\r\n                // some inside the node and some on the boundary\r\n                // leaf nodes will have exactly one internal node at the center\r\n                // and four boundary nodes\r\n                // groups will have potentially many of each\r\n                v.ports = [];\r\n            });\r\n            // nodes ordered by their position in the group hierarchy\r\n            this.backToFront = this.nodes.slice(0);\r\n            this.backToFront.sort(function (x, y) { return _this.getDepth(x) - _this.getDepth(y); });\r\n            // compute boundary rectangles for each group\r\n            // has to be done from front to back, i.e. inside groups to outside groups\r\n            // such that each can be made large enough to enclose its interior\r\n            var frontToBackGroups = this.backToFront.slice(0).reverse().filter(function (g) { return !g.leaf; });\r\n            frontToBackGroups.forEach(function (v) {\r\n                var r = cola.vpsc.Rectangle.empty();\r\n                v.children.forEach(function (c) { return r = r.union(_this.nodes[c].rect); });\r\n                v.rect = r.inflate(_this.groupPadding);\r\n            });\r\n            var colMids = this.midPoints(this.cols.map(function (r) { return r.pos; }));\r\n            var rowMids = this.midPoints(this.rows.map(function (r) { return r.pos; }));\r\n            // setup extents of lines\r\n            var rowx = colMids[0], rowX = colMids[colMids.length - 1];\r\n            var coly = rowMids[0], colY = rowMids[rowMids.length - 1];\r\n            // horizontal lines\r\n            var hlines = this.rows.map(function (r) { return { x1: rowx, x2: rowX, y1: r.pos, y2: r.pos }; })\r\n                .concat(rowMids.map(function (m) { return { x1: rowx, x2: rowX, y1: m, y2: m }; }));\r\n            // vertical lines\r\n            var vlines = this.cols.map(function (c) { return { x1: c.pos, x2: c.pos, y1: coly, y2: colY }; })\r\n                .concat(colMids.map(function (m) { return { x1: m, x2: m, y1: coly, y2: colY }; }));\r\n            // the full set of lines\r\n            var lines = hlines.concat(vlines);\r\n            // we record the vertices associated with each line\r\n            lines.forEach(function (l) { return l.verts = []; });\r\n            // the routing graph\r\n            this.verts = [];\r\n            this.edges = [];\r\n            // create vertices at the crossings of horizontal and vertical grid-lines\r\n            hlines.forEach(function (h) {\r\n                return vlines.forEach(function (v) {\r\n                    var p = new Vert(_this.verts.length, v.x1, h.y1);\r\n                    h.verts.push(p);\r\n                    v.verts.push(p);\r\n                    _this.verts.push(p);\r\n                    // assign vertices to the nodes immediately under them\r\n                    var i = _this.backToFront.length;\r\n                    while (i-- > 0) {\r\n                        var node = _this.backToFront[i], r = node.rect;\r\n                        var dx = Math.abs(p.x - r.cx()), dy = Math.abs(p.y - r.cy());\r\n                        if (dx < r.width() / 2 && dy < r.height() / 2) {\r\n                            p.node = node;\r\n                            break;\r\n                        }\r\n                    }\r\n                });\r\n            });\r\n            lines.forEach(function (l, li) {\r\n                // create vertices at the intersections of nodes and lines\r\n                _this.nodes.forEach(function (v, i) {\r\n                    v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach(function (intersect, j) {\r\n                        //console.log(li+','+i+','+j+':'+intersect.x + ',' + intersect.y);\r\n                        var p = new Vert(_this.verts.length, intersect.x, intersect.y, v, l);\r\n                        _this.verts.push(p);\r\n                        l.verts.push(p);\r\n                        v.ports.push(p);\r\n                    });\r\n                });\r\n                // split lines into edges joining vertices\r\n                var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;\r\n                var delta = function (a, b) { return isHoriz ? b.x - a.x : b.y - a.y; };\r\n                l.verts.sort(delta);\r\n                for (var i = 1; i < l.verts.length; i++) {\r\n                    var u = l.verts[i - 1], v = l.verts[i];\r\n                    if (u.node && u.node === v.node && u.node.leaf)\r\n                        continue;\r\n                    _this.edges.push({ source: u.id, target: v.id, length: Math.abs(delta(u, v)) });\r\n                }\r\n            });\r\n        }\r\n        GridRouter.prototype.avg = function (a) { return a.reduce(function (x, y) { return x + y; }) / a.length; };\r\n        // in the given axis, find sets of leaves overlapping in that axis\r\n        // center of each GridLine is average of all nodes in column\r\n        GridRouter.prototype.getGridLines = function (axis) {\r\n            var columns = [];\r\n            var ls = this.leaves.slice(0, this.leaves.length);\r\n            while (ls.length > 0) {\r\n                // find a column of all leaves overlapping in axis with the first leaf\r\n                var overlapping = ls.filter(function (v) { return v.rect['overlap' + axis.toUpperCase()](ls[0].rect); });\r\n                var col = {\r\n                    nodes: overlapping,\r\n                    pos: this.avg(overlapping.map(function (v) { return v.rect['c' + axis](); }))\r\n                };\r\n                columns.push(col);\r\n                col.nodes.forEach(function (v) { return ls.splice(ls.indexOf(v), 1); });\r\n            }\r\n            columns.sort(function (a, b) { return a.pos - b.pos; });\r\n            return columns;\r\n        };\r\n        // get the depth of the given node in the group hierarchy\r\n        GridRouter.prototype.getDepth = function (v) {\r\n            var depth = 0;\r\n            while (v.parent !== this.root) {\r\n                depth++;\r\n                v = v.parent;\r\n            }\r\n            return depth;\r\n        };\r\n        // medial axes between node centres and also boundary lines for the grid\r\n        GridRouter.prototype.midPoints = function (a) {\r\n            var gap = a[1] - a[0];\r\n            var mids = [a[0] - gap / 2];\r\n            for (var i = 1; i < a.length; i++) {\r\n                mids.push((a[i] + a[i - 1]) / 2);\r\n            }\r\n            mids.push(a[a.length - 1] + gap / 2);\r\n            return mids;\r\n        };\r\n        // find path from v to root including both v and root\r\n        GridRouter.prototype.findLineage = function (v) {\r\n            var lineage = [v];\r\n            do {\r\n                v = v.parent;\r\n                lineage.push(v);\r\n            } while (v !== this.root);\r\n            return lineage.reverse();\r\n        };\r\n        // find path connecting a and b through their lowest common ancestor\r\n        GridRouter.prototype.findAncestorPathBetween = function (a, b) {\r\n            var aa = this.findLineage(a), ba = this.findLineage(b), i = 0;\r\n            while (aa[i] === ba[i])\r\n                i++;\r\n            // i-1 to include common ancestor only once (as first element)\r\n            return { commonAncestor: aa[i - 1], lineages: aa.slice(i).concat(ba.slice(i)) };\r\n        };\r\n        // when finding a path between two nodes a and b, siblings of a and b on the\r\n        // paths from a and b to their least common ancestor are obstacles\r\n        GridRouter.prototype.siblingObstacles = function (a, b) {\r\n            var _this = this;\r\n            var path = this.findAncestorPathBetween(a, b);\r\n            var lineageLookup = {};\r\n            path.lineages.forEach(function (v) { return lineageLookup[v.id] = {}; });\r\n            var obstacles = path.commonAncestor.children.filter(function (v) { return !(v in lineageLookup); });\r\n            path.lineages\r\n                .filter(function (v) { return v.parent !== path.commonAncestor; })\r\n                .forEach(function (v) { return obstacles = obstacles.concat(v.parent.children.filter(function (c) { return c !== v.id; })); });\r\n            return obstacles.map(function (v) { return _this.nodes[v]; });\r\n        };\r\n        // for the given routes, extract all the segments orthogonal to the axis x\r\n        // and return all them grouped by x position\r\n        GridRouter.getSegmentSets = function (routes, x, y) {\r\n            // vsegments is a list of vertical segments sorted by x position\r\n            var vsegments = [];\r\n            for (var ei = 0; ei < routes.length; ei++) {\r\n                var route = routes[ei];\r\n                for (var si = 0; si < route.length; si++) {\r\n                    var s = route[si];\r\n                    s.edgeid = ei;\r\n                    s.i = si;\r\n                    var sdx = s[1][x] - s[0][x];\r\n                    if (Math.abs(sdx) < 0.1) {\r\n                        vsegments.push(s);\r\n                    }\r\n                }\r\n            }\r\n            vsegments.sort(function (a, b) { return a[0][x] - b[0][x]; });\r\n            // vsegmentsets is a set of sets of segments grouped by x position\r\n            var vsegmentsets = [];\r\n            var segmentset = null;\r\n            for (var i = 0; i < vsegments.length; i++) {\r\n                var s = vsegments[i];\r\n                if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {\r\n                    segmentset = { pos: s[0][x], segments: [] };\r\n                    vsegmentsets.push(segmentset);\r\n                }\r\n                segmentset.segments.push(s);\r\n            }\r\n            return vsegmentsets;\r\n        };\r\n        // for all segments in this bundle create a vpsc problem such that\r\n        // each segment's x position is a variable and separation constraints \r\n        // are given by the partial order over the edges to which the segments belong\r\n        // for each pair s1,s2 of segments in the open set:\r\n        //   e1 = edge of s1, e2 = edge of s2\r\n        //   if leftOf(e1,e2) create constraint s1.x + gap <= s2.x\r\n        //   else if leftOf(e2,e1) create cons. s2.x + gap <= s1.x\r\n        GridRouter.nudgeSegs = function (x, y, routes, segments, leftOf, gap) {\r\n            var n = segments.length;\r\n            if (n <= 1)\r\n                return;\r\n            var vs = segments.map(function (s) { return new cola.vpsc.Variable(s[0][x]); });\r\n            var cs = [];\r\n            for (var i = 0; i < n; i++) {\r\n                for (var j = 0; j < n; j++) {\r\n                    if (i === j)\r\n                        continue;\r\n                    var s1 = segments[i], s2 = segments[j], e1 = s1.edgeid, e2 = s2.edgeid, lind = -1, rind = -1;\r\n                    // in page coordinates (not cartesian) the notion of 'leftof' is flipped in the horizontal axis from the vertical axis\r\n                    // that is, when nudging vertical segments, if they increase in the y(conj) direction the segment belonging to the\r\n                    // 'left' edge actually needs to be nudged to the right\r\n                    // when nudging horizontal segments, if the segments increase in the x direction\r\n                    // then the 'left' segment needs to go higher, i.e. to have y pos less than that of the right\r\n                    if (x == 'x') {\r\n                        if (leftOf(e1, e2)) {\r\n                            //console.log('s1: ' + s1[0][x] + ',' + s1[0][y] + '-' + s1[1][x] + ',' + s1[1][y]);\r\n                            if (s1[0][y] < s1[1][y]) {\r\n                                lind = j, rind = i;\r\n                            }\r\n                            else {\r\n                                lind = i, rind = j;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (leftOf(e1, e2)) {\r\n                            if (s1[0][y] < s1[1][y]) {\r\n                                lind = i, rind = j;\r\n                            }\r\n                            else {\r\n                                lind = j, rind = i;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (lind >= 0) {\r\n                        //console.log(x+' constraint: ' + lind + '<' + rind);\r\n                        cs.push(new cola.vpsc.Constraint(vs[lind], vs[rind], gap));\r\n                    }\r\n                }\r\n            }\r\n            var solver = new cola.vpsc.Solver(vs, cs);\r\n            solver.solve();\r\n            vs.forEach(function (v, i) {\r\n                var s = segments[i];\r\n                var pos = v.position();\r\n                s[0][x] = s[1][x] = pos;\r\n                var route = routes[s.edgeid];\r\n                if (s.i > 0)\r\n                    route[s.i - 1][1][x] = pos;\r\n                if (s.i < route.length - 1)\r\n                    route[s.i + 1][0][x] = pos;\r\n            });\r\n        };\r\n        GridRouter.nudgeSegments = function (routes, x, y, leftOf, gap) {\r\n            var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);\r\n            // scan the grouped (by x) segment sets to find co-linear bundles\r\n            for (var i = 0; i < vsegmentsets.length; i++) {\r\n                var ss = vsegmentsets[i];\r\n                var events = [];\r\n                for (var j = 0; j < ss.segments.length; j++) {\r\n                    var s = ss.segments[j];\r\n                    events.push({ type: 0, s: s, pos: Math.min(s[0][y], s[1][y]) });\r\n                    events.push({ type: 1, s: s, pos: Math.max(s[0][y], s[1][y]) });\r\n                }\r\n                events.sort(function (a, b) { return a.pos - b.pos + a.type - b.type; });\r\n                var open = [];\r\n                var openCount = 0;\r\n                events.forEach(function (e) {\r\n                    if (e.type === 0) {\r\n                        open.push(e.s);\r\n                        openCount++;\r\n                    }\r\n                    else {\r\n                        openCount--;\r\n                    }\r\n                    if (openCount == 0) {\r\n                        GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);\r\n                        open = [];\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        // obtain routes for the specified edges, nicely nudged apart\r\n        // warning: edge paths may be reversed such that common paths are ordered consistently within bundles!\r\n        // @param edges list of edges\r\n        // @param nudgeGap how much to space parallel edge segements\r\n        // @param source function to retrieve the index of the source node for a given edge\r\n        // @param target function to retrieve the index of the target node for a given edge\r\n        // @returns an array giving, for each edge, an array of segments, each segment a pair of points in an array\r\n        GridRouter.prototype.routeEdges = function (edges, nudgeGap, source, target) {\r\n            var _this = this;\r\n            var routePaths = edges.map(function (e) { return _this.route(source(e), target(e)); });\r\n            var order = cola.GridRouter.orderEdges(routePaths);\r\n            var routes = routePaths.map(function (e) { return cola.GridRouter.makeSegments(e); });\r\n            cola.GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);\r\n            cola.GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);\r\n            cola.GridRouter.unreverseEdges(routes, routePaths);\r\n            return routes;\r\n        };\r\n        // path may have been reversed by the subsequence processing in orderEdges\r\n        // so now we need to restore the original order\r\n        GridRouter.unreverseEdges = function (routes, routePaths) {\r\n            routes.forEach(function (segments, i) {\r\n                var path = routePaths[i];\r\n                if (path.reversed) {\r\n                    segments.reverse(); // reverse order of segments\r\n                    segments.forEach(function (segment) {\r\n                        segment.reverse(); // reverse each segment\r\n                    });\r\n                }\r\n            });\r\n        };\r\n        GridRouter.angleBetween2Lines = function (line1, line2) {\r\n            var angle1 = Math.atan2(line1[0].y - line1[1].y, line1[0].x - line1[1].x);\r\n            var angle2 = Math.atan2(line2[0].y - line2[1].y, line2[0].x - line2[1].x);\r\n            var diff = angle1 - angle2;\r\n            if (diff > Math.PI || diff < -Math.PI) {\r\n                diff = angle2 - angle1;\r\n            }\r\n            return diff;\r\n        };\r\n        // does the path a-b-c describe a left turn?\r\n        GridRouter.isLeft = function (a, b, c) {\r\n            return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) <= 0;\r\n        };\r\n        // for the given list of ordered pairs, returns a function that (efficiently) looks-up a specific pair to\r\n        // see if it exists in the list\r\n        GridRouter.getOrder = function (pairs) {\r\n            var outgoing = {};\r\n            for (var i = 0; i < pairs.length; i++) {\r\n                var p = pairs[i];\r\n                if (typeof outgoing[p.l] === 'undefined')\r\n                    outgoing[p.l] = {};\r\n                outgoing[p.l][p.r] = true;\r\n            }\r\n            return function (l, r) { return typeof outgoing[l] !== 'undefined' && outgoing[l][r]; };\r\n        };\r\n        // returns an ordering (a lookup function) that determines the correct order to nudge the\r\n        // edge paths apart to minimize crossings\r\n        GridRouter.orderEdges = function (edges) {\r\n            var edgeOrder = [];\r\n            for (var i = 0; i < edges.length - 1; i++) {\r\n                for (var j = i + 1; j < edges.length; j++) {\r\n                    var e = edges[i], f = edges[j], lcs = new cola.LongestCommonSubsequence(e, f);\r\n                    var u, vi, vj;\r\n                    if (lcs.length === 0)\r\n                        continue; // no common subpath\r\n                    if (lcs.reversed) {\r\n                        // if we found a common subpath but one of the edges runs the wrong way, \r\n                        // then reverse f.\r\n                        f.reverse();\r\n                        f.reversed = true;\r\n                        lcs = new cola.LongestCommonSubsequence(e, f);\r\n                    }\r\n                    if ((lcs.si <= 0 || lcs.ti <= 0) &&\r\n                        (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {\r\n                        // the paths do not diverge, so make an arbitrary ordering decision\r\n                        edgeOrder.push({ l: i, r: j });\r\n                        continue;\r\n                    }\r\n                    if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {\r\n                        // if the common subsequence of the\r\n                        // two edges being considered goes all the way to the\r\n                        // end of one (or both) of the lines then we have to \r\n                        // base our ordering decision on the other end of the\r\n                        // common subsequence\r\n                        u = e[lcs.si + 1];\r\n                        vj = e[lcs.si - 1];\r\n                        vi = f[lcs.ti - 1];\r\n                    }\r\n                    else {\r\n                        u = e[lcs.si + lcs.length - 2];\r\n                        vi = e[lcs.si + lcs.length];\r\n                        vj = f[lcs.ti + lcs.length];\r\n                    }\r\n                    if (GridRouter.isLeft(u, vi, vj)) {\r\n                        edgeOrder.push({ l: j, r: i });\r\n                    }\r\n                    else {\r\n                        edgeOrder.push({ l: i, r: j });\r\n                    }\r\n                }\r\n            }\r\n            //edgeOrder.forEach(function (e) { console.log('l:' + e.l + ',r:' + e.r) });\r\n            return cola.GridRouter.getOrder(edgeOrder);\r\n        };\r\n        // for an orthogonal path described by a sequence of points, create a list of segments\r\n        // if consecutive segments would make a straight line they are merged into a single segment\r\n        // segments are over cloned points, not the original vertices\r\n        GridRouter.makeSegments = function (path) {\r\n            function copyPoint(p) {\r\n                return { x: p.x, y: p.y };\r\n            }\r\n            var isStraight = function (a, b, c) { return Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001; };\r\n            var segments = [];\r\n            var a = copyPoint(path[0]);\r\n            for (var i = 1; i < path.length; i++) {\r\n                var b = copyPoint(path[i]), c = i < path.length - 1 ? path[i + 1] : null;\r\n                if (!c || !isStraight(a, b, c)) {\r\n                    segments.push([a, b]);\r\n                    a = b;\r\n                }\r\n            }\r\n            return segments;\r\n        };\r\n        // find a route between node s and node t\r\n        // returns an array of indices to verts\r\n        GridRouter.prototype.route = function (s, t) {\r\n            var _this = this;\r\n            var source = this.nodes[s], target = this.nodes[t];\r\n            this.obstacles = this.siblingObstacles(source, target);\r\n            var obstacleLookup = {};\r\n            this.obstacles.forEach(function (o) { return obstacleLookup[o.id] = o; });\r\n            this.passableEdges = this.edges.filter(function (e) {\r\n                var u = _this.verts[e.source], v = _this.verts[e.target];\r\n                return !(u.node && u.node.id in obstacleLookup\r\n                    || v.node && v.node.id in obstacleLookup);\r\n            });\r\n            // add dummy segments linking ports inside source and target\r\n            for (var i = 1; i < source.ports.length; i++) {\r\n                var u = source.ports[0].id;\r\n                var v = source.ports[i].id;\r\n                this.passableEdges.push({\r\n                    source: u,\r\n                    target: v,\r\n                    length: 0\r\n                });\r\n            }\r\n            for (var i = 1; i < target.ports.length; i++) {\r\n                var u = target.ports[0].id;\r\n                var v = target.ports[i].id;\r\n                this.passableEdges.push({\r\n                    source: u,\r\n                    target: v,\r\n                    length: 0\r\n                });\r\n            }\r\n            var getSource = function (e) { return e.source; }, getTarget = function (e) { return e.target; }, getLength = function (e) { return e.length; };\r\n            var shortestPathCalculator = new cola.shortestpaths.Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);\r\n            var bendPenalty = function (u, v, w) {\r\n                var a = _this.verts[u], b = _this.verts[v], c = _this.verts[w];\r\n                var dx = Math.abs(c.x - a.x), dy = Math.abs(c.y - a.y);\r\n                // don't count bends from internal node edges\r\n                if (a.node === source && a.node === b.node || b.node === target && b.node === c.node)\r\n                    return 0;\r\n                return dx > 1 && dy > 1 ? 1000 : 0;\r\n            };\r\n            // get shortest path\r\n            var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(source.ports[0].id, target.ports[0].id, bendPenalty);\r\n            // shortest path is reversed and does not include the target port\r\n            var pathPoints = shortestPath.reverse().map(function (vi) { return _this.verts[vi]; });\r\n            pathPoints.push(this.nodes[target.id].ports[0]);\r\n            // filter out any extra end points that are inside the source or target (i.e. the dummy segments above)\r\n            return pathPoints.filter(function (v, i) {\r\n                return !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source\r\n                    || i > 0 && v.node === target && pathPoints[i - 1].node === target);\r\n            });\r\n        };\r\n        GridRouter.getRoutePath = function (route, cornerradius, arrowwidth, arrowheight) {\r\n            var result = {\r\n                routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',\r\n                arrowpath: ''\r\n            };\r\n            if (route.length > 1) {\r\n                for (var i = 0; i < route.length; i++) {\r\n                    var li = route[i];\r\n                    var x = li[1].x, y = li[1].y;\r\n                    var dx = x - li[0].x;\r\n                    var dy = y - li[0].y;\r\n                    if (i < route.length - 1) {\r\n                        if (Math.abs(dx) > 0) {\r\n                            x -= dx / Math.abs(dx) * cornerradius;\r\n                        }\r\n                        else {\r\n                            y -= dy / Math.abs(dy) * cornerradius;\r\n                        }\r\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\r\n                        var l = route[i + 1];\r\n                        var x0 = l[0].x, y0 = l[0].y;\r\n                        var x1 = l[1].x;\r\n                        var y1 = l[1].y;\r\n                        dx = x1 - x0;\r\n                        dy = y1 - y0;\r\n                        var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;\r\n                        //console.log(cola.GridRouter.angleBetween2Lines(li, l))\r\n                        var x2, y2;\r\n                        if (Math.abs(dx) > 0) {\r\n                            x2 = x0 + dx / Math.abs(dx) * cornerradius;\r\n                            y2 = y0;\r\n                        }\r\n                        else {\r\n                            x2 = x0;\r\n                            y2 = y0 + dy / Math.abs(dy) * cornerradius;\r\n                        }\r\n                        var cx = Math.abs(x2 - x);\r\n                        var cy = Math.abs(y2 - y);\r\n                        result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';\r\n                    }\r\n                    else {\r\n                        var arrowtip = [x, y];\r\n                        var arrowcorner1, arrowcorner2;\r\n                        if (Math.abs(dx) > 0) {\r\n                            x -= dx / Math.abs(dx) * arrowheight;\r\n                            arrowcorner1 = [x, y + arrowwidth];\r\n                            arrowcorner2 = [x, y - arrowwidth];\r\n                        }\r\n                        else {\r\n                            y -= dy / Math.abs(dy) * arrowheight;\r\n                            arrowcorner1 = [x + arrowwidth, y];\r\n                            arrowcorner2 = [x - arrowwidth, y];\r\n                        }\r\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\r\n                        if (arrowheight > 0) {\r\n                            result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\r\n                                + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                var li = route[0];\r\n                var x = li[1].x, y = li[1].y;\r\n                var dx = x - li[0].x;\r\n                var dy = y - li[0].y;\r\n                var arrowtip = [x, y];\r\n                var arrowcorner1, arrowcorner2;\r\n                if (Math.abs(dx) > 0) {\r\n                    x -= dx / Math.abs(dx) * arrowheight;\r\n                    arrowcorner1 = [x, y + arrowwidth];\r\n                    arrowcorner2 = [x, y - arrowwidth];\r\n                }\r\n                else {\r\n                    y -= dy / Math.abs(dy) * arrowheight;\r\n                    arrowcorner1 = [x + arrowwidth, y];\r\n                    arrowcorner2 = [x - arrowwidth, y];\r\n                }\r\n                result.routepath += 'L ' + x + ' ' + y + ' ';\r\n                if (arrowheight > 0) {\r\n                    result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\r\n                        + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        return GridRouter;\r\n    })();\r\n    cola.GridRouter = GridRouter;\r\n})(cola || (cola = {}));\r\n/**\r\n * Use cola to do a layout in 3D!! Yay.\r\n * Pretty simple for the moment.\r\n */\r\nvar cola;\r\n(function (cola) {\r\n    var Link3D = (function () {\r\n        function Link3D(source, target) {\r\n            this.source = source;\r\n            this.target = target;\r\n        }\r\n        Link3D.prototype.actualLength = function (x) {\r\n            var _this = this;\r\n            return Math.sqrt(x.reduce(function (c, v) {\r\n                var dx = v[_this.target] - v[_this.source];\r\n                return c + dx * dx;\r\n            }, 0));\r\n        };\r\n        return Link3D;\r\n    })();\r\n    cola.Link3D = Link3D;\r\n    var Node3D = (function () {\r\n        function Node3D(x, y, z) {\r\n            if (x === void 0) { x = 0; }\r\n            if (y === void 0) { y = 0; }\r\n            if (z === void 0) { z = 0; }\r\n            this.x = x;\r\n            this.y = y;\r\n            this.z = z;\r\n        }\r\n        return Node3D;\r\n    })();\r\n    cola.Node3D = Node3D;\r\n    var Layout3D = (function () {\r\n        function Layout3D(nodes, links, idealLinkLength) {\r\n            var _this = this;\r\n            if (idealLinkLength === void 0) { idealLinkLength = 1; }\r\n            this.nodes = nodes;\r\n            this.links = links;\r\n            this.idealLinkLength = idealLinkLength;\r\n            this.constraints = null;\r\n            this.useJaccardLinkLengths = true;\r\n            this.result = new Array(Layout3D.k);\r\n            for (var i = 0; i < Layout3D.k; ++i) {\r\n                this.result[i] = new Array(nodes.length);\r\n            }\r\n            nodes.forEach(function (v, i) {\r\n                for (var _i = 0, _a = Layout3D.dims; _i < _a.length; _i++) {\r\n                    var dim = _a[_i];\r\n                    if (typeof v[dim] == 'undefined')\r\n                        v[dim] = Math.random();\r\n                }\r\n                _this.result[0][i] = v.x;\r\n                _this.result[1][i] = v.y;\r\n                _this.result[2][i] = v.z;\r\n            });\r\n        }\r\n        ;\r\n        Layout3D.prototype.linkLength = function (l) {\r\n            return l.actualLength(this.result);\r\n        };\r\n        Layout3D.prototype.start = function (iterations) {\r\n            var _this = this;\r\n            if (iterations === void 0) { iterations = 100; }\r\n            var n = this.nodes.length;\r\n            var linkAccessor = new LinkAccessor();\r\n            if (this.useJaccardLinkLengths)\r\n                cola.jaccardLinkLengths(this.links, linkAccessor, 1.5);\r\n            this.links.forEach(function (e) { return e.length *= _this.idealLinkLength; });\r\n            // Create the distance matrix that Cola needs\r\n            var distanceMatrix = (new cola.shortestpaths.Calculator(n, this.links, function (e) { return e.source; }, function (e) { return e.target; }, function (e) { return e.length; })).DistanceMatrix();\r\n            var D = cola.Descent.createSquareMatrix(n, function (i, j) { return distanceMatrix[i][j]; });\r\n            // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\r\n            // otherwise 2.\r\n            var G = cola.Descent.createSquareMatrix(n, function () { return 2; });\r\n            this.links.forEach(function (_a) {\r\n                var source = _a.source, target = _a.target;\r\n                return G[source][target] = G[target][source] = 1;\r\n            });\r\n            this.descent = new cola.Descent(this.result, D);\r\n            this.descent.threshold = 1e-3;\r\n            this.descent.G = G;\r\n            //let constraints = this.links.map(e=> <any>{\r\n            //    axis: 'y', left: e.source, right: e.target, gap: e.length*1.5\r\n            //});\r\n            if (this.constraints)\r\n                this.descent.project = new cola.vpsc.Projection(this.nodes, null, null, this.constraints).projectFunctions();\r\n            for (var i = 0; i < this.nodes.length; i++) {\r\n                var v = this.nodes[i];\r\n                if (v.fixed) {\r\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);\r\n                }\r\n            }\r\n            this.descent.run(iterations);\r\n            return this;\r\n        };\r\n        Layout3D.prototype.tick = function () {\r\n            this.descent.locks.clear();\r\n            for (var i = 0; i < this.nodes.length; i++) {\r\n                var v = this.nodes[i];\r\n                if (v.fixed) {\r\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);\r\n                }\r\n            }\r\n            return this.descent.rungeKutta();\r\n        };\r\n        Layout3D.dims = ['x', 'y', 'z'];\r\n        Layout3D.k = Layout3D.dims.length;\r\n        return Layout3D;\r\n    })();\r\n    cola.Layout3D = Layout3D;\r\n    var LinkAccessor = (function () {\r\n        function LinkAccessor() {\r\n        }\r\n        LinkAccessor.prototype.getSourceIndex = function (e) { return e.source; };\r\n        LinkAccessor.prototype.getTargetIndex = function (e) { return e.target; };\r\n        LinkAccessor.prototype.getLength = function (e) { return e.length; };\r\n        LinkAccessor.prototype.setLength = function (e, l) { e.length = l; };\r\n        return LinkAccessor;\r\n    })();\r\n})(cola || (cola = {}));\r\n/**\r\n * When compiled, this file will build a CommonJS module for WebCola.\r\n *\r\n * Unfortunately, internal and external TypeScript modules do not get\r\n * along well. This method of converting internal modules to external\r\n * modules is a bit of a hack, but is minimally invasive (i.e., no modules\r\n * need to be rewritten as external modules and modules can still span\r\n * multiple files)\r\n *\r\n * When starting a new project from scratch where CommonJS compatibility\r\n * is desired, consider instead preferring external modules to internal\r\n * modules.\r\n */\r\n///<reference path=\"./src/d3adaptor.ts\"/>\r\n///<reference path=\"./src/descent.ts\"/>\r\n///<reference path=\"./src/geom.ts\"/>\r\n///<reference path=\"./src/gridrouter.ts\"/>\r\n///<reference path=\"./src/handledisconnected.ts\"/>\r\n///<reference path=\"./src/layout.ts\"/>\r\n///<reference path=\"./src/layout3d.ts\"/>\r\n///<reference path=\"./src/linklengths.ts\"/>\r\n///<reference path=\"./src/powergraph.ts\"/>\r\n///<reference path=\"./src/pqueue.ts\"/>\r\n///<reference path=\"./src/rectangle.ts\"/>\r\n///<reference path=\"./src/shortestpaths.ts\"/>\r\n///<reference path=\"./src/vpsc.ts\"/>\r\n///<reference path=\"./src/rbtree.ts\"/>\r\n// Export cola as a CommonJS module. Note that we're bypassing TypeScript's external\r\n// module system here. Because internal modules were written with the browser in mind,\r\n// TypeScript's model is that the current context is the global context (i.e., window.cola\r\n// === cola), so `export = cola` is transpiled as a no-op.\r\nmodule.exports = cola;\r\n"]}