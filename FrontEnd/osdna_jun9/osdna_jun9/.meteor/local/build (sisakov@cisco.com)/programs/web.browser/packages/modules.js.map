{"version":3,"sources":["meteor://ðŸ’»app/packages/modules/client.js","meteor://ðŸ’»app/packages/modules/buffer.js","meteor://ðŸ’»app/packages/modules/css.js","meteor://ðŸ’»app/packages/modules/install-packages.js","meteor://ðŸ’»app/packages/modules/process.js","meteor://ðŸ’»app/packages/modules/stubs.js","meteor://ðŸ’»app/node_modules/webcola/package.json","meteor://ðŸ’»app/node_modules/webcola/WebCola/index.js","meteor://ðŸ’»app/node_modules/meteor-node-stubs/package.json","meteor://ðŸ’»app/node_modules/meteor-node-stubs/index.js","meteor://ðŸ’»app/node_modules/meteor-node-stubs/map.json","meteor://ðŸ’»app/node_modules/meteor-node-stubs/deps/buffer.js","meteor://ðŸ’»app/node_modules/meteor-node-stubs/deps/process.js","meteor://ðŸ’»app/node_modules/meteor-node-stubs/deps/domain.js","meteor://ðŸ’»app/node_modules/meteor-node-stubs/node_modules/buffer/package.json","meteor://ðŸ’»app/node_modules/meteor-node-stubs/node_modules/buffer/index.js","meteor://ðŸ’»app/node_modules/meteor-node-stubs/node_modules/base64-js/package.json","meteor://ðŸ’»app/node_modules/meteor-node-stubs/node_modules/base64-js/lib/b64.js","meteor://ðŸ’»app/node_modules/meteor-node-stubs/node_modules/ieee754/package.json","meteor://ðŸ’»app/node_modules/meteor-node-stubs/node_modules/ieee754/index.js","meteor://ðŸ’»app/node_modules/meteor-node-stubs/node_modules/isarray/package.json","meteor://ðŸ’»app/node_modules/meteor-node-stubs/node_modules/isarray/index.js","meteor://ðŸ’»app/node_modules/meteor-node-stubs/node_modules/process/browser.js","meteor://ðŸ’»app/node_modules/meteor-node-stubs/node_modules/domain-browser/package.json","meteor://ðŸ’»app/node_modules/meteor-node-stubs/node_modules/domain-browser/index.js","meteor://ðŸ’»app/node_modules/meteor-node-stubs/node_modules/events/package.json","meteor://ðŸ’»app/node_modules/meteor-node-stubs/node_modules/events/events.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACNA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACNA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8H;;;;;;;;;;;AClyJA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;ACxCA;AACA,2H;;;;;;;;;;;ACDA;AACA,2H;;;;;;;;;;;ACDA;AACA,2H;;;;;;;;;;;ACDA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8H;;;;;;;;;;;ACt7CA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;ACnIA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;ACpFA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;AC3FA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;ACrEA;AACA;AACA;AACA,2H;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H","file":"/packages/modules.js","sourcesContent":["require(\"./install-packages.js\");\nrequire(\"./stubs.js\");\nrequire(\"./buffer.js\");\nrequire(\"./process.js\");\n\nexports.addStyles = require(\"./css\").addStyles;\n","try {\n  Buffer = global.Buffer || require(\"buffer\").Buffer;\n} catch (noBuffer) {}\n","var doc = document;\nvar head = doc.getElementsByTagName(\"head\").item(0);\n\nexports.addStyles = function (css) {\n  var style = doc.createElement(\"style\");\n\n  style.setAttribute(\"type\", \"text/css\");\n\n  // https://msdn.microsoft.com/en-us/library/ms535871(v=vs.85).aspx\n  var internetExplorerSheetObject =\n    style.sheet || // Edge/IE11.\n    style.styleSheet; // Older IEs.\n\n  if (internetExplorerSheetObject) {\n    internetExplorerSheetObject.cssText = css;\n  } else {\n    style.appendChild(doc.createTextNode(css));\n  }\n\n  return head.appendChild(style);\n};\n","function install(name) {\n  var meteorDir = {};\n\n  // Given a package name <name>, install a stub module in the\n  // /node_modules/meteor directory called <name>.js, so that\n  // require.resolve(\"meteor/<name>\") will always return\n  // /node_modules/meteor/<name>.js instead of something like\n  // /node_modules/meteor/<name>/index.js, in the rare but possible event\n  // that the package contains a file called index.js (#6590).\n  meteorDir[name + \".js\"] = function (r, e, module) {\n    module.exports = Package[name];\n  };\n\n  meteorInstall({\n    node_modules: {\n      meteor: meteorDir\n    }\n  });\n}\n\n// This file will be modified during computeJsOutputFilesMap to include\n// install(<name>) calls for every Meteor package.\n\ninstall(\"underscore\");\ninstall(\"meteor\");\ninstall(\"meteor-base\");\ninstall(\"mobile-experience\");\ninstall(\"babel-compiler\");\ninstall(\"ecmascript\");\ninstall(\"base64\");\ninstall(\"ejson\");\ninstall(\"id-map\");\ninstall(\"ordered-dict\");\ninstall(\"tracker\");\ninstall(\"modules-runtime\");\ninstall(\"modules\");\ninstall(\"es5-shim\");\ninstall(\"promise\");\ninstall(\"ecmascript-runtime\");\ninstall(\"babel-runtime\");\ninstall(\"random\");\ninstall(\"mongo-id\");\ninstall(\"diff-sequence\");\ninstall(\"geojson-utils\");\ninstall(\"minimongo\");\ninstall(\"check\");\ninstall(\"retry\");\ninstall(\"ddp-common\");\ninstall(\"reload\");\ninstall(\"ddp-client\");\ninstall(\"ddp\");\ninstall(\"ddp-server\");\ninstall(\"allow-deny\");\ninstall(\"mongo\");\ninstall(\"blaze-html-templates\");\ninstall(\"reactive-dict\");\ninstall(\"session\");\ninstall(\"jquery\");\ninstall(\"url\");\ninstall(\"http\");\ninstall(\"deps\");\ninstall(\"htmljs\");\ninstall(\"observe-sequence\");\ninstall(\"reactive-var\");\ninstall(\"blaze\");\ninstall(\"ui\");\ninstall(\"spacebars\");\ninstall(\"templating\");\ninstall(\"iron:core\");\ninstall(\"iron:dynamic-template\");\ninstall(\"iron:layout\");\ninstall(\"iron:url\");\ninstall(\"iron:middleware-stack\");\ninstall(\"iron:location\");\ninstall(\"iron:controller\");\ninstall(\"iron:router\");\ninstall(\"twbs:bootstrap\");\ninstall(\"d3js:d3\");\ninstall(\"standard-minifier-css\");\ninstall(\"standard-minifier-js\");\ninstall(\"limemakers:three\");\ninstall(\"pcel:loading\");\ninstall(\"spectrum:material-design-lite\");\ninstall(\"timmyg:wow\");\ninstall(\"ddp-rate-limiter\");\ninstall(\"localstorage\");\ninstall(\"callback-hook\");\ninstall(\"accounts-base\");\ninstall(\"service-configuration\");\ninstall(\"npm-bcrypt\");\ninstall(\"sha\");\ninstall(\"srp\");\ninstall(\"accounts-password\");\ninstall(\"less\");\ninstall(\"accounts-ui-unstyled\");\ninstall(\"accounts-ui\");\ninstall(\"webapp\");\ninstall(\"livedata\");\ninstall(\"hot-code-push\");\ninstall(\"launch-screen\");\ninstall(\"autoupdate\");\n","try {\n  // The application can run `npm install process` to provide its own\n  // process stub; otherwise this module will provide a partial stub.\n  process = global.process || require(\"process\");\n} catch (noProcess) {\n  process = {};\n}\n\nif (Meteor.isServer) {\n  // Make require(\"process\") work on the server in all versions of Node.\n  meteorInstall({\n    node_modules: {\n      \"process.js\": function (r, e, module) {\n        module.exports = process;\n      }\n    }\n  });\n} else {\n  process.platform = \"browser\";\n  process.nextTick = process.nextTick || Meteor._setImmediate;\n}\n\nif (typeof process.env !== \"object\") {\n  process.env = {};\n}\n\n_.extend(process.env, meteorEnv);\n","try {\n  // When meteor-node-stubs is installed in the application's root\n  // node_modules directory, requiring it here installs aliases for stubs\n  // for all Node built-in modules, such as fs, util, and http.\n  require(\"meteor-node-stubs\");\n} catch (noStubs) {}\n","exports.name = \"webcola\";\nexports.version = \"3.1.3\";\nexports.main = \"WebCola/index.js\";\n","var cola;\r\n(function (cola) {\r\n    var packingOptions = {\r\n        PADDING: 10,\r\n        GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,\r\n        FLOAT_EPSILON: 0.0001,\r\n        MAX_INERATIONS: 100\r\n    };\r\n    // assign x, y to nodes while using box packing algorithm for disconnected graphs\r\n    function applyPacking(graphs, w, h, node_size, desired_ratio) {\r\n        if (desired_ratio === void 0) { desired_ratio = 1; }\r\n        var init_x = 0, init_y = 0, svg_width = w, svg_height = h, desired_ratio = typeof desired_ratio !== 'undefined' ? desired_ratio : 1, node_size = typeof node_size !== 'undefined' ? node_size : 0, real_width = 0, real_height = 0, min_width = 0, global_bottom = 0, line = [];\r\n        if (graphs.length == 0)\r\n            return;\r\n        /// that would take care of single nodes problem\r\n        // graphs.forEach(function (g) {\r\n        //     if (g.array.length == 1) {\r\n        //         g.array[0].x = 0;\r\n        //         g.array[0].y = 0;\r\n        //     }\r\n        // });\r\n        calculate_bb(graphs);\r\n        apply(graphs, desired_ratio);\r\n        put_nodes_to_right_positions(graphs);\r\n        // get bounding boxes for all separate graphs\r\n        function calculate_bb(graphs) {\r\n            graphs.forEach(function (g) {\r\n                calculate_single_bb(g);\r\n            });\r\n            function calculate_single_bb(graph) {\r\n                var min_x = Number.MAX_VALUE, min_y = Number.MAX_VALUE, max_x = 0, max_y = 0;\r\n                graph.array.forEach(function (v) {\r\n                    var w = typeof v.width !== 'undefined' ? v.width : node_size;\r\n                    var h = typeof v.height !== 'undefined' ? v.height : node_size;\r\n                    w /= 2;\r\n                    h /= 2;\r\n                    max_x = Math.max(v.x + w, max_x);\r\n                    min_x = Math.min(v.x - w, min_x);\r\n                    max_y = Math.max(v.y + h, max_y);\r\n                    min_y = Math.min(v.y - h, min_y);\r\n                });\r\n                graph.width = max_x - min_x;\r\n                graph.height = max_y - min_y;\r\n            }\r\n        }\r\n        //function plot(data, left, right, opt_x, opt_y) {\r\n        //    // plot the cost function\r\n        //    var plot_svg = d3.select(\"body\").append(\"svg\")\r\n        //        .attr(\"width\", function () { return 2 * (right - left); })\r\n        //        .attr(\"height\", 200);\r\n        //    var x = d3.time.scale().range([0, 2 * (right - left)]);\r\n        //    var xAxis = d3.svg.axis().scale(x).orient(\"bottom\");\r\n        //    plot_svg.append(\"g\").attr(\"class\", \"x axis\")\r\n        //        .attr(\"transform\", \"translate(0, 199)\")\r\n        //        .call(xAxis);\r\n        //    var lastX = 0;\r\n        //    var lastY = 0;\r\n        //    var value = 0;\r\n        //    for (var r = left; r < right; r += 1) {\r\n        //        value = step(data, r);\r\n        //        // value = 1;\r\n        //        plot_svg.append(\"line\").attr(\"x1\", 2 * (lastX - left))\r\n        //            .attr(\"y1\", 200 - 30 * lastY)\r\n        //            .attr(\"x2\", 2 * r - 2 * left)\r\n        //            .attr(\"y2\", 200 - 30 * value)\r\n        //            .style(\"stroke\", \"rgb(6,120,155)\");\r\n        //        lastX = r;\r\n        //        lastY = value;\r\n        //    }\r\n        //    plot_svg.append(\"circle\").attr(\"cx\", 2 * opt_x - 2 * left).attr(\"cy\", 200 - 30 * opt_y)\r\n        //        .attr(\"r\", 5).style('fill', \"rgba(0,0,0,0.5)\");\r\n        //}\r\n        // actual assigning of position to nodes\r\n        function put_nodes_to_right_positions(graphs) {\r\n            graphs.forEach(function (g) {\r\n                // calculate current graph center:\r\n                var center = { x: 0, y: 0 };\r\n                g.array.forEach(function (node) {\r\n                    center.x += node.x;\r\n                    center.y += node.y;\r\n                });\r\n                center.x /= g.array.length;\r\n                center.y /= g.array.length;\r\n                // calculate current top left corner:\r\n                var corner = { x: center.x - g.width / 2, y: center.y - g.height / 2 };\r\n                var offset = { x: g.x - corner.x + svg_width / 2 - real_width / 2, y: g.y - corner.y + svg_height / 2 - real_height / 2 };\r\n                // put nodes:\r\n                g.array.forEach(function (node) {\r\n                    node.x += offset.x;\r\n                    node.y += offset.y;\r\n                });\r\n            });\r\n        }\r\n        // starts box packing algorithm\r\n        // desired ratio is 1 by default\r\n        function apply(data, desired_ratio) {\r\n            var curr_best_f = Number.POSITIVE_INFINITY;\r\n            var curr_best = 0;\r\n            data.sort(function (a, b) { return b.height - a.height; });\r\n            min_width = data.reduce(function (a, b) {\r\n                return a.width < b.width ? a.width : b.width;\r\n            });\r\n            var left = x1 = min_width;\r\n            var right = x2 = get_entire_width(data);\r\n            var iterationCounter = 0;\r\n            var f_x1 = Number.MAX_VALUE;\r\n            var f_x2 = Number.MAX_VALUE;\r\n            var flag = -1; // determines which among f_x1 and f_x2 to recompute\r\n            var dx = Number.MAX_VALUE;\r\n            var df = Number.MAX_VALUE;\r\n            while ((dx > min_width) || df > packingOptions.FLOAT_EPSILON) {\r\n                if (flag != 1) {\r\n                    var x1 = right - (right - left) / packingOptions.GOLDEN_SECTION;\r\n                    var f_x1 = step(data, x1);\r\n                }\r\n                if (flag != 0) {\r\n                    var x2 = left + (right - left) / packingOptions.GOLDEN_SECTION;\r\n                    var f_x2 = step(data, x2);\r\n                }\r\n                dx = Math.abs(x1 - x2);\r\n                df = Math.abs(f_x1 - f_x2);\r\n                if (f_x1 < curr_best_f) {\r\n                    curr_best_f = f_x1;\r\n                    curr_best = x1;\r\n                }\r\n                if (f_x2 < curr_best_f) {\r\n                    curr_best_f = f_x2;\r\n                    curr_best = x2;\r\n                }\r\n                if (f_x1 > f_x2) {\r\n                    left = x1;\r\n                    x1 = x2;\r\n                    f_x1 = f_x2;\r\n                    flag = 1;\r\n                }\r\n                else {\r\n                    right = x2;\r\n                    x2 = x1;\r\n                    f_x2 = f_x1;\r\n                    flag = 0;\r\n                }\r\n                if (iterationCounter++ > 100) {\r\n                    break;\r\n                }\r\n            }\r\n            // plot(data, min_width, get_entire_width(data), curr_best, curr_best_f);\r\n            step(data, curr_best);\r\n        }\r\n        // one iteration of the optimization method\r\n        // (gives a proper, but not necessarily optimal packing)\r\n        function step(data, max_width) {\r\n            line = [];\r\n            real_width = 0;\r\n            real_height = 0;\r\n            global_bottom = init_y;\r\n            for (var i = 0; i < data.length; i++) {\r\n                var o = data[i];\r\n                put_rect(o, max_width);\r\n            }\r\n            return Math.abs(get_real_ratio() - desired_ratio);\r\n        }\r\n        // looking for a position to one box \r\n        function put_rect(rect, max_width) {\r\n            var parent = undefined;\r\n            for (var i = 0; i < line.length; i++) {\r\n                if ((line[i].space_left >= rect.height) && (line[i].x + line[i].width + rect.width + packingOptions.PADDING - max_width) <= packingOptions.FLOAT_EPSILON) {\r\n                    parent = line[i];\r\n                    break;\r\n                }\r\n            }\r\n            line.push(rect);\r\n            if (parent !== undefined) {\r\n                rect.x = parent.x + parent.width + packingOptions.PADDING;\r\n                rect.y = parent.bottom;\r\n                rect.space_left = rect.height;\r\n                rect.bottom = rect.y;\r\n                parent.space_left -= rect.height + packingOptions.PADDING;\r\n                parent.bottom += rect.height + packingOptions.PADDING;\r\n            }\r\n            else {\r\n                rect.y = global_bottom;\r\n                global_bottom += rect.height + packingOptions.PADDING;\r\n                rect.x = init_x;\r\n                rect.bottom = rect.y;\r\n                rect.space_left = rect.height;\r\n            }\r\n            if (rect.y + rect.height - real_height > -packingOptions.FLOAT_EPSILON)\r\n                real_height = rect.y + rect.height - init_y;\r\n            if (rect.x + rect.width - real_width > -packingOptions.FLOAT_EPSILON)\r\n                real_width = rect.x + rect.width - init_x;\r\n        }\r\n        ;\r\n        function get_entire_width(data) {\r\n            var width = 0;\r\n            data.forEach(function (d) { return width += d.width + packingOptions.PADDING; });\r\n            return width;\r\n        }\r\n        function get_real_ratio() {\r\n            return (real_width / real_height);\r\n        }\r\n    }\r\n    cola.applyPacking = applyPacking;\r\n    /**\r\n     * connected components of graph\r\n     * returns an array of {}\r\n     */\r\n    function separateGraphs(nodes, links) {\r\n        var marks = {};\r\n        var ways = {};\r\n        var graphs = [];\r\n        var clusters = 0;\r\n        for (var i = 0; i < links.length; i++) {\r\n            var link = links[i];\r\n            var n1 = link.source;\r\n            var n2 = link.target;\r\n            if (ways[n1.index])\r\n                ways[n1.index].push(n2);\r\n            else\r\n                ways[n1.index] = [n2];\r\n            if (ways[n2.index])\r\n                ways[n2.index].push(n1);\r\n            else\r\n                ways[n2.index] = [n1];\r\n        }\r\n        for (var i = 0; i < nodes.length; i++) {\r\n            var node = nodes[i];\r\n            if (marks[node.index])\r\n                continue;\r\n            explore_node(node, true);\r\n        }\r\n        function explore_node(n, is_new) {\r\n            if (marks[n.index] !== undefined)\r\n                return;\r\n            if (is_new) {\r\n                clusters++;\r\n                graphs.push({ array: [] });\r\n            }\r\n            marks[n.index] = clusters;\r\n            graphs[clusters - 1].array.push(n);\r\n            var adjacent = ways[n.index];\r\n            if (!adjacent)\r\n                return;\r\n            for (var j = 0; j < adjacent.length; j++) {\r\n                explore_node(adjacent[j], false);\r\n            }\r\n        }\r\n        return graphs;\r\n    }\r\n    cola.separateGraphs = separateGraphs;\r\n})(cola || (cola = {}));\r\nvar cola;\r\n(function (cola) {\r\n    var vpsc;\r\n    (function (vpsc) {\r\n        var PositionStats = (function () {\r\n            function PositionStats(scale) {\r\n                this.scale = scale;\r\n                this.AB = 0;\r\n                this.AD = 0;\r\n                this.A2 = 0;\r\n            }\r\n            PositionStats.prototype.addVariable = function (v) {\r\n                var ai = this.scale / v.scale;\r\n                var bi = v.offset / v.scale;\r\n                var wi = v.weight;\r\n                this.AB += wi * ai * bi;\r\n                this.AD += wi * ai * v.desiredPosition;\r\n                this.A2 += wi * ai * ai;\r\n            };\r\n            PositionStats.prototype.getPosn = function () {\r\n                return (this.AD - this.AB) / this.A2;\r\n            };\r\n            return PositionStats;\r\n        })();\r\n        vpsc.PositionStats = PositionStats;\r\n        var Constraint = (function () {\r\n            function Constraint(left, right, gap, equality) {\r\n                if (equality === void 0) { equality = false; }\r\n                this.left = left;\r\n                this.right = right;\r\n                this.gap = gap;\r\n                this.equality = equality;\r\n                this.active = false;\r\n                this.unsatisfiable = false;\r\n                this.left = left;\r\n                this.right = right;\r\n                this.gap = gap;\r\n                this.equality = equality;\r\n            }\r\n            Constraint.prototype.slack = function () {\r\n                return this.unsatisfiable ? Number.MAX_VALUE\r\n                    : this.right.scale * this.right.position() - this.gap\r\n                        - this.left.scale * this.left.position();\r\n            };\r\n            return Constraint;\r\n        })();\r\n        vpsc.Constraint = Constraint;\r\n        var Variable = (function () {\r\n            function Variable(desiredPosition, weight, scale) {\r\n                if (weight === void 0) { weight = 1; }\r\n                if (scale === void 0) { scale = 1; }\r\n                this.desiredPosition = desiredPosition;\r\n                this.weight = weight;\r\n                this.scale = scale;\r\n                this.offset = 0;\r\n            }\r\n            Variable.prototype.dfdv = function () {\r\n                return 2.0 * this.weight * (this.position() - this.desiredPosition);\r\n            };\r\n            Variable.prototype.position = function () {\r\n                return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;\r\n            };\r\n            // visit neighbours by active constraints within the same block\r\n            Variable.prototype.visitNeighbours = function (prev, f) {\r\n                var ff = function (c, next) { return c.active && prev !== next && f(c, next); };\r\n                this.cOut.forEach(function (c) { return ff(c, c.right); });\r\n                this.cIn.forEach(function (c) { return ff(c, c.left); });\r\n            };\r\n            return Variable;\r\n        })();\r\n        vpsc.Variable = Variable;\r\n        var Block = (function () {\r\n            function Block(v) {\r\n                this.vars = [];\r\n                v.offset = 0;\r\n                this.ps = new PositionStats(v.scale);\r\n                this.addVariable(v);\r\n            }\r\n            Block.prototype.addVariable = function (v) {\r\n                v.block = this;\r\n                this.vars.push(v);\r\n                this.ps.addVariable(v);\r\n                this.posn = this.ps.getPosn();\r\n            };\r\n            // move the block where it needs to be to minimize cost\r\n            Block.prototype.updateWeightedPosition = function () {\r\n                this.ps.AB = this.ps.AD = this.ps.A2 = 0;\r\n                for (var i = 0, n = this.vars.length; i < n; ++i)\r\n                    this.ps.addVariable(this.vars[i]);\r\n                this.posn = this.ps.getPosn();\r\n            };\r\n            Block.prototype.compute_lm = function (v, u, postAction) {\r\n                var _this = this;\r\n                var dfdv = v.dfdv();\r\n                v.visitNeighbours(u, function (c, next) {\r\n                    var _dfdv = _this.compute_lm(next, v, postAction);\r\n                    if (next === c.right) {\r\n                        dfdv += _dfdv * c.left.scale;\r\n                        c.lm = _dfdv;\r\n                    }\r\n                    else {\r\n                        dfdv += _dfdv * c.right.scale;\r\n                        c.lm = -_dfdv;\r\n                    }\r\n                    postAction(c);\r\n                });\r\n                return dfdv / v.scale;\r\n            };\r\n            Block.prototype.populateSplitBlock = function (v, prev) {\r\n                var _this = this;\r\n                v.visitNeighbours(prev, function (c, next) {\r\n                    next.offset = v.offset + (next === c.right ? c.gap : -c.gap);\r\n                    _this.addVariable(next);\r\n                    _this.populateSplitBlock(next, v);\r\n                });\r\n            };\r\n            // traverse the active constraint tree applying visit to each active constraint\r\n            Block.prototype.traverse = function (visit, acc, v, prev) {\r\n                var _this = this;\r\n                if (v === void 0) { v = this.vars[0]; }\r\n                if (prev === void 0) { prev = null; }\r\n                v.visitNeighbours(prev, function (c, next) {\r\n                    acc.push(visit(c));\r\n                    _this.traverse(visit, acc, next, v);\r\n                });\r\n            };\r\n            // calculate lagrangian multipliers on constraints and\r\n            // find the active constraint in this block with the smallest lagrangian.\r\n            // if the lagrangian is negative, then the constraint is a split candidate.  \r\n            Block.prototype.findMinLM = function () {\r\n                var m = null;\r\n                this.compute_lm(this.vars[0], null, function (c) {\r\n                    if (!c.equality && (m === null || c.lm < m.lm))\r\n                        m = c;\r\n                });\r\n                return m;\r\n            };\r\n            Block.prototype.findMinLMBetween = function (lv, rv) {\r\n                this.compute_lm(lv, null, function () { });\r\n                var m = null;\r\n                this.findPath(lv, null, rv, function (c, next) {\r\n                    if (!c.equality && c.right === next && (m === null || c.lm < m.lm))\r\n                        m = c;\r\n                });\r\n                return m;\r\n            };\r\n            Block.prototype.findPath = function (v, prev, to, visit) {\r\n                var _this = this;\r\n                var endFound = false;\r\n                v.visitNeighbours(prev, function (c, next) {\r\n                    if (!endFound && (next === to || _this.findPath(next, v, to, visit))) {\r\n                        endFound = true;\r\n                        visit(c, next);\r\n                    }\r\n                });\r\n                return endFound;\r\n            };\r\n            // Search active constraint tree from u to see if there is a directed path to v.\r\n            // Returns true if path is found.\r\n            Block.prototype.isActiveDirectedPathBetween = function (u, v) {\r\n                if (u === v)\r\n                    return true;\r\n                var i = u.cOut.length;\r\n                while (i--) {\r\n                    var c = u.cOut[i];\r\n                    if (c.active && this.isActiveDirectedPathBetween(c.right, v))\r\n                        return true;\r\n                }\r\n                return false;\r\n            };\r\n            // split the block into two by deactivating the specified constraint\r\n            Block.split = function (c) {\r\n                /* DEBUG\r\n                            console.log(\"split on \" + c);\r\n                            console.assert(c.active, \"attempt to split on inactive constraint\");\r\n                DEBUG */\r\n                c.active = false;\r\n                return [Block.createSplitBlock(c.left), Block.createSplitBlock(c.right)];\r\n            };\r\n            Block.createSplitBlock = function (startVar) {\r\n                var b = new Block(startVar);\r\n                b.populateSplitBlock(startVar, null);\r\n                return b;\r\n            };\r\n            // find a split point somewhere between the specified variables\r\n            Block.prototype.splitBetween = function (vl, vr) {\r\n                /* DEBUG\r\n                            console.assert(vl.block === this);\r\n                            console.assert(vr.block === this);\r\n                DEBUG */\r\n                var c = this.findMinLMBetween(vl, vr);\r\n                if (c !== null) {\r\n                    var bs = Block.split(c);\r\n                    return { constraint: c, lb: bs[0], rb: bs[1] };\r\n                }\r\n                // couldn't find a split point - for example the active path is all equality constraints\r\n                return null;\r\n            };\r\n            Block.prototype.mergeAcross = function (b, c, dist) {\r\n                c.active = true;\r\n                for (var i = 0, n = b.vars.length; i < n; ++i) {\r\n                    var v = b.vars[i];\r\n                    v.offset += dist;\r\n                    this.addVariable(v);\r\n                }\r\n                this.posn = this.ps.getPosn();\r\n            };\r\n            Block.prototype.cost = function () {\r\n                var sum = 0, i = this.vars.length;\r\n                while (i--) {\r\n                    var v = this.vars[i], d = v.position() - v.desiredPosition;\r\n                    sum += d * d * v.weight;\r\n                }\r\n                return sum;\r\n            };\r\n            return Block;\r\n        })();\r\n        vpsc.Block = Block;\r\n        var Blocks = (function () {\r\n            function Blocks(vs) {\r\n                this.vs = vs;\r\n                var n = vs.length;\r\n                this.list = new Array(n);\r\n                while (n--) {\r\n                    var b = new Block(vs[n]);\r\n                    this.list[n] = b;\r\n                    b.blockInd = n;\r\n                }\r\n            }\r\n            Blocks.prototype.cost = function () {\r\n                var sum = 0, i = this.list.length;\r\n                while (i--)\r\n                    sum += this.list[i].cost();\r\n                return sum;\r\n            };\r\n            Blocks.prototype.insert = function (b) {\r\n                /* DEBUG\r\n                            console.assert(!this.contains(b), \"blocks error: tried to reinsert block \" + b.blockInd)\r\n                DEBUG */\r\n                b.blockInd = this.list.length;\r\n                this.list.push(b);\r\n                /* DEBUG\r\n                            console.log(\"insert block: \" + b.blockInd);\r\n                            this.contains(b);\r\n                DEBUG */\r\n            };\r\n            Blocks.prototype.remove = function (b) {\r\n                /* DEBUG\r\n                            console.log(\"remove block: \" + b.blockInd);\r\n                            console.assert(this.contains(b));\r\n                DEBUG */\r\n                var last = this.list.length - 1;\r\n                var swapBlock = this.list[last];\r\n                this.list.length = last;\r\n                if (b !== swapBlock) {\r\n                    this.list[b.blockInd] = swapBlock;\r\n                    swapBlock.blockInd = b.blockInd;\r\n                }\r\n            };\r\n            // merge the blocks on either side of the specified constraint, by copying the smaller block into the larger\r\n            // and deleting the smaller.\r\n            Blocks.prototype.merge = function (c) {\r\n                var l = c.left.block, r = c.right.block;\r\n                /* DEBUG\r\n                            console.assert(l!==r, \"attempt to merge within the same block\");\r\n                DEBUG */\r\n                var dist = c.right.offset - c.left.offset - c.gap;\r\n                if (l.vars.length < r.vars.length) {\r\n                    r.mergeAcross(l, c, dist);\r\n                    this.remove(l);\r\n                }\r\n                else {\r\n                    l.mergeAcross(r, c, -dist);\r\n                    this.remove(r);\r\n                }\r\n                /* DEBUG\r\n                            console.assert(Math.abs(c.slack()) < 1e-6, \"Error: Constraint should be at equality after merge!\");\r\n                            console.log(\"merged on \" + c);\r\n                DEBUG */\r\n            };\r\n            Blocks.prototype.forEach = function (f) {\r\n                this.list.forEach(f);\r\n            };\r\n            // useful, for example, after variable desired positions change.\r\n            Blocks.prototype.updateBlockPositions = function () {\r\n                this.list.forEach(function (b) { return b.updateWeightedPosition(); });\r\n            };\r\n            // split each block across its constraint with the minimum lagrangian \r\n            Blocks.prototype.split = function (inactive) {\r\n                var _this = this;\r\n                this.updateBlockPositions();\r\n                this.list.forEach(function (b) {\r\n                    var v = b.findMinLM();\r\n                    if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {\r\n                        b = v.left.block;\r\n                        Block.split(v).forEach(function (nb) { return _this.insert(nb); });\r\n                        _this.remove(b);\r\n                        inactive.push(v);\r\n                    }\r\n                });\r\n            };\r\n            return Blocks;\r\n        })();\r\n        vpsc.Blocks = Blocks;\r\n        var Solver = (function () {\r\n            function Solver(vs, cs) {\r\n                this.vs = vs;\r\n                this.cs = cs;\r\n                this.vs = vs;\r\n                vs.forEach(function (v) {\r\n                    v.cIn = [], v.cOut = [];\r\n                    /* DEBUG\r\n                                    v.toString = () => \"v\" + vs.indexOf(v);\r\n                    DEBUG */\r\n                });\r\n                this.cs = cs;\r\n                cs.forEach(function (c) {\r\n                    c.left.cOut.push(c);\r\n                    c.right.cIn.push(c);\r\n                    /* DEBUG\r\n                                    c.toString = () => c.left + \"+\" + c.gap + \"<=\" + c.right + \" slack=\" + c.slack() + \" active=\" + c.active;\r\n                    DEBUG */\r\n                });\r\n                this.inactive = cs.map(function (c) { c.active = false; return c; });\r\n                this.bs = null;\r\n            }\r\n            Solver.prototype.cost = function () {\r\n                return this.bs.cost();\r\n            };\r\n            // set starting positions without changing desired positions.\r\n            // Note: it throws away any previous block structure.\r\n            Solver.prototype.setStartingPositions = function (ps) {\r\n                this.inactive = this.cs.map(function (c) { c.active = false; return c; });\r\n                this.bs = new Blocks(this.vs);\r\n                this.bs.forEach(function (b, i) { return b.posn = ps[i]; });\r\n            };\r\n            Solver.prototype.setDesiredPositions = function (ps) {\r\n                this.vs.forEach(function (v, i) { return v.desiredPosition = ps[i]; });\r\n            };\r\n            /* DEBUG\r\n                    private getId(v: Variable): number {\r\n                        return this.vs.indexOf(v);\r\n                    }\r\n            \r\n                    // sanity check of the index integrity of the inactive list\r\n                    checkInactive(): void {\r\n                        var inactiveCount = 0;\r\n                        this.cs.forEach(c=> {\r\n                            var i = this.inactive.indexOf(c);\r\n                            console.assert(!c.active && i >= 0 || c.active && i < 0, \"constraint should be in the inactive list if it is not active: \" + c);\r\n                            if (i >= 0) {\r\n                                inactiveCount++;\r\n                            } else {\r\n                                console.assert(c.active, \"inactive constraint not found in inactive list: \" + c);\r\n                            }\r\n                        });\r\n                        console.assert(inactiveCount === this.inactive.length, inactiveCount + \" inactive constraints found, \" + this.inactive.length + \"in inactive list\");\r\n                    }\r\n                    // after every call to satisfy the following should check should pass\r\n                    checkSatisfied(): void {\r\n                        this.cs.forEach(c=>console.assert(c.slack() >= vpsc.Solver.ZERO_UPPERBOUND, \"Error: Unsatisfied constraint! \"+c));\r\n                    }\r\n            DEBUG */\r\n            Solver.prototype.mostViolated = function () {\r\n                var minSlack = Number.MAX_VALUE, v = null, l = this.inactive, n = l.length, deletePoint = n;\r\n                for (var i = 0; i < n; ++i) {\r\n                    var c = l[i];\r\n                    if (c.unsatisfiable)\r\n                        continue;\r\n                    var slack = c.slack();\r\n                    if (c.equality || slack < minSlack) {\r\n                        minSlack = slack;\r\n                        v = c;\r\n                        deletePoint = i;\r\n                        if (c.equality)\r\n                            break;\r\n                    }\r\n                }\r\n                if (deletePoint !== n &&\r\n                    (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality)) {\r\n                    l[deletePoint] = l[n - 1];\r\n                    l.length = n - 1;\r\n                }\r\n                return v;\r\n            };\r\n            // satisfy constraints by building block structure over violated constraints\r\n            // and moving the blocks to their desired positions\r\n            Solver.prototype.satisfy = function () {\r\n                if (this.bs == null) {\r\n                    this.bs = new Blocks(this.vs);\r\n                }\r\n                /* DEBUG\r\n                            console.log(\"satisfy: \" + this.bs);\r\n                DEBUG */\r\n                this.bs.split(this.inactive);\r\n                var v = null;\r\n                while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {\r\n                    var lb = v.left.block, rb = v.right.block;\r\n                    /* DEBUG\r\n                                    console.log(\"most violated is: \" + v);\r\n                                    this.bs.contains(lb);\r\n                                    this.bs.contains(rb);\r\n                    DEBUG */\r\n                    if (lb !== rb) {\r\n                        this.bs.merge(v);\r\n                    }\r\n                    else {\r\n                        if (lb.isActiveDirectedPathBetween(v.right, v.left)) {\r\n                            // cycle found!\r\n                            v.unsatisfiable = true;\r\n                            continue;\r\n                        }\r\n                        // constraint is within block, need to split first\r\n                        var split = lb.splitBetween(v.left, v.right);\r\n                        if (split !== null) {\r\n                            this.bs.insert(split.lb);\r\n                            this.bs.insert(split.rb);\r\n                            this.bs.remove(lb);\r\n                            this.inactive.push(split.constraint);\r\n                        }\r\n                        else {\r\n                            /* DEBUG\r\n                                                    console.log(\"unsatisfiable constraint found\");\r\n                            DEBUG */\r\n                            v.unsatisfiable = true;\r\n                            continue;\r\n                        }\r\n                        if (v.slack() >= 0) {\r\n                            /* DEBUG\r\n                                                    console.log(\"violated constraint indirectly satisfied: \" + v);\r\n                            DEBUG */\r\n                            // v was satisfied by the above split!\r\n                            this.inactive.push(v);\r\n                        }\r\n                        else {\r\n                            /* DEBUG\r\n                                                    console.log(\"merge after split:\");\r\n                            DEBUG */\r\n                            this.bs.merge(v);\r\n                        }\r\n                    }\r\n                }\r\n                /* DEBUG\r\n                            this.checkSatisfied();\r\n                DEBUG */\r\n            };\r\n            // repeatedly build and split block structure until we converge to an optimal solution\r\n            Solver.prototype.solve = function () {\r\n                this.satisfy();\r\n                var lastcost = Number.MAX_VALUE, cost = this.bs.cost();\r\n                while (Math.abs(lastcost - cost) > 0.0001) {\r\n                    this.satisfy();\r\n                    lastcost = cost;\r\n                    cost = this.bs.cost();\r\n                }\r\n                return cost;\r\n            };\r\n            Solver.LAGRANGIAN_TOLERANCE = -1e-4;\r\n            Solver.ZERO_UPPERBOUND = -1e-10;\r\n            return Solver;\r\n        })();\r\n        vpsc.Solver = Solver;\r\n    })(vpsc = cola.vpsc || (cola.vpsc = {}));\r\n})(cola || (cola = {}));\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar cola;\r\n(function (cola) {\r\n    var vpsc;\r\n    (function (vpsc) {\r\n        //Based on js_es:\r\n        //\r\n        //https://github.com/vadimg/js_bintrees\r\n        //\r\n        //Copyright (C) 2011 by Vadim Graboys\r\n        //\r\n        //Permission is hereby granted, free of charge, to any person obtaining a copy\r\n        //of this software and associated documentation files (the \"Software\"), to deal\r\n        //in the Software without restriction, including without limitation the rights\r\n        //to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n        //copies of the Software, and to permit persons to whom the Software is\r\n        //furnished to do so, subject to the following conditions:\r\n        //\r\n        //The above copyright notice and this permission notice shall be included in\r\n        //all copies or substantial portions of the Software.\r\n        //\r\n        //THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n        //IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n        //FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n        //AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n        //LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n        //OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n        //THE SOFTWARE.\r\n        var TreeBase = (function () {\r\n            function TreeBase() {\r\n                // returns iterator to node if found, null otherwise\r\n                this.findIter = function (data) {\r\n                    var res = this._root;\r\n                    var iter = this.iterator();\r\n                    while (res !== null) {\r\n                        var c = this._comparator(data, res.data);\r\n                        if (c === 0) {\r\n                            iter._cursor = res;\r\n                            return iter;\r\n                        }\r\n                        else {\r\n                            iter._ancestors.push(res);\r\n                            res = res.get_child(c > 0);\r\n                        }\r\n                    }\r\n                    return null;\r\n                };\r\n            }\r\n            // removes all nodes from the tree\r\n            TreeBase.prototype.clear = function () {\r\n                this._root = null;\r\n                this.size = 0;\r\n            };\r\n            ;\r\n            // returns node data if found, null otherwise\r\n            TreeBase.prototype.find = function (data) {\r\n                var res = this._root;\r\n                while (res !== null) {\r\n                    var c = this._comparator(data, res.data);\r\n                    if (c === 0) {\r\n                        return res.data;\r\n                    }\r\n                    else {\r\n                        res = res.get_child(c > 0);\r\n                    }\r\n                }\r\n                return null;\r\n            };\r\n            ;\r\n            // Returns an interator to the tree node immediately before (or at) the element\r\n            TreeBase.prototype.lowerBound = function (data) {\r\n                return this._bound(data, this._comparator);\r\n            };\r\n            ;\r\n            // Returns an interator to the tree node immediately after (or at) the element\r\n            TreeBase.prototype.upperBound = function (data) {\r\n                var cmp = this._comparator;\r\n                function reverse_cmp(a, b) {\r\n                    return cmp(b, a);\r\n                }\r\n                return this._bound(data, reverse_cmp);\r\n            };\r\n            ;\r\n            // returns null if tree is empty\r\n            TreeBase.prototype.min = function () {\r\n                var res = this._root;\r\n                if (res === null) {\r\n                    return null;\r\n                }\r\n                while (res.left !== null) {\r\n                    res = res.left;\r\n                }\r\n                return res.data;\r\n            };\r\n            ;\r\n            // returns null if tree is empty\r\n            TreeBase.prototype.max = function () {\r\n                var res = this._root;\r\n                if (res === null) {\r\n                    return null;\r\n                }\r\n                while (res.right !== null) {\r\n                    res = res.right;\r\n                }\r\n                return res.data;\r\n            };\r\n            ;\r\n            // returns a null iterator\r\n            // call next() or prev() to point to an element\r\n            TreeBase.prototype.iterator = function () {\r\n                return new Iterator(this);\r\n            };\r\n            ;\r\n            // calls cb on each node's data, in order\r\n            TreeBase.prototype.each = function (cb) {\r\n                var it = this.iterator(), data;\r\n                while ((data = it.next()) !== null) {\r\n                    cb(data);\r\n                }\r\n            };\r\n            ;\r\n            // calls cb on each node's data, in reverse order\r\n            TreeBase.prototype.reach = function (cb) {\r\n                var it = this.iterator(), data;\r\n                while ((data = it.prev()) !== null) {\r\n                    cb(data);\r\n                }\r\n            };\r\n            ;\r\n            // used for lowerBound and upperBound\r\n            TreeBase.prototype._bound = function (data, cmp) {\r\n                var cur = this._root;\r\n                var iter = this.iterator();\r\n                while (cur !== null) {\r\n                    var c = this._comparator(data, cur.data);\r\n                    if (c === 0) {\r\n                        iter._cursor = cur;\r\n                        return iter;\r\n                    }\r\n                    iter._ancestors.push(cur);\r\n                    cur = cur.get_child(c > 0);\r\n                }\r\n                for (var i = iter._ancestors.length - 1; i >= 0; --i) {\r\n                    cur = iter._ancestors[i];\r\n                    if (cmp(data, cur.data) > 0) {\r\n                        iter._cursor = cur;\r\n                        iter._ancestors.length = i;\r\n                        return iter;\r\n                    }\r\n                }\r\n                iter._ancestors.length = 0;\r\n                return iter;\r\n            };\r\n            ;\r\n            return TreeBase;\r\n        })();\r\n        vpsc.TreeBase = TreeBase;\r\n        var Iterator = (function () {\r\n            function Iterator(tree) {\r\n                this._tree = tree;\r\n                this._ancestors = [];\r\n                this._cursor = null;\r\n            }\r\n            Iterator.prototype.data = function () {\r\n                return this._cursor !== null ? this._cursor.data : null;\r\n            };\r\n            ;\r\n            // if null-iterator, returns first node\r\n            // otherwise, returns next node\r\n            Iterator.prototype.next = function () {\r\n                if (this._cursor === null) {\r\n                    var root = this._tree._root;\r\n                    if (root !== null) {\r\n                        this._minNode(root);\r\n                    }\r\n                }\r\n                else {\r\n                    if (this._cursor.right === null) {\r\n                        // no greater node in subtree, go up to parent\r\n                        // if coming from a right child, continue up the stack\r\n                        var save;\r\n                        do {\r\n                            save = this._cursor;\r\n                            if (this._ancestors.length) {\r\n                                this._cursor = this._ancestors.pop();\r\n                            }\r\n                            else {\r\n                                this._cursor = null;\r\n                                break;\r\n                            }\r\n                        } while (this._cursor.right === save);\r\n                    }\r\n                    else {\r\n                        // get the next node from the subtree\r\n                        this._ancestors.push(this._cursor);\r\n                        this._minNode(this._cursor.right);\r\n                    }\r\n                }\r\n                return this._cursor !== null ? this._cursor.data : null;\r\n            };\r\n            ;\r\n            // if null-iterator, returns last node\r\n            // otherwise, returns previous node\r\n            Iterator.prototype.prev = function () {\r\n                if (this._cursor === null) {\r\n                    var root = this._tree._root;\r\n                    if (root !== null) {\r\n                        this._maxNode(root);\r\n                    }\r\n                }\r\n                else {\r\n                    if (this._cursor.left === null) {\r\n                        var save;\r\n                        do {\r\n                            save = this._cursor;\r\n                            if (this._ancestors.length) {\r\n                                this._cursor = this._ancestors.pop();\r\n                            }\r\n                            else {\r\n                                this._cursor = null;\r\n                                break;\r\n                            }\r\n                        } while (this._cursor.left === save);\r\n                    }\r\n                    else {\r\n                        this._ancestors.push(this._cursor);\r\n                        this._maxNode(this._cursor.left);\r\n                    }\r\n                }\r\n                return this._cursor !== null ? this._cursor.data : null;\r\n            };\r\n            ;\r\n            Iterator.prototype._minNode = function (start) {\r\n                while (start.left !== null) {\r\n                    this._ancestors.push(start);\r\n                    start = start.left;\r\n                }\r\n                this._cursor = start;\r\n            };\r\n            ;\r\n            Iterator.prototype._maxNode = function (start) {\r\n                while (start.right !== null) {\r\n                    this._ancestors.push(start);\r\n                    start = start.right;\r\n                }\r\n                this._cursor = start;\r\n            };\r\n            ;\r\n            return Iterator;\r\n        })();\r\n        vpsc.Iterator = Iterator;\r\n        var Node = (function () {\r\n            function Node(data) {\r\n                this.data = data;\r\n                this.left = null;\r\n                this.right = null;\r\n                this.red = true;\r\n            }\r\n            Node.prototype.get_child = function (dir) {\r\n                return dir ? this.right : this.left;\r\n            };\r\n            ;\r\n            Node.prototype.set_child = function (dir, val) {\r\n                if (dir) {\r\n                    this.right = val;\r\n                }\r\n                else {\r\n                    this.left = val;\r\n                }\r\n            };\r\n            ;\r\n            return Node;\r\n        })();\r\n        var RBTree = (function (_super) {\r\n            __extends(RBTree, _super);\r\n            function RBTree(comparator) {\r\n                _super.call(this);\r\n                this._root = null;\r\n                this._comparator = comparator;\r\n                this.size = 0;\r\n            }\r\n            // returns true if inserted, false if duplicate\r\n            RBTree.prototype.insert = function (data) {\r\n                var ret = false;\r\n                if (this._root === null) {\r\n                    // empty tree\r\n                    this._root = new Node(data);\r\n                    ret = true;\r\n                    this.size++;\r\n                }\r\n                else {\r\n                    var head = new Node(undefined); // fake tree root\r\n                    var dir = false;\r\n                    var last = false;\r\n                    // setup\r\n                    var gp = null; // grandparent\r\n                    var ggp = head; // grand-grand-parent\r\n                    var p = null; // parent\r\n                    var node = this._root;\r\n                    ggp.right = this._root;\r\n                    // search down\r\n                    while (true) {\r\n                        if (node === null) {\r\n                            // insert new node at the bottom\r\n                            node = new Node(data);\r\n                            p.set_child(dir, node);\r\n                            ret = true;\r\n                            this.size++;\r\n                        }\r\n                        else if (RBTree.is_red(node.left) && RBTree.is_red(node.right)) {\r\n                            // color flip\r\n                            node.red = true;\r\n                            node.left.red = false;\r\n                            node.right.red = false;\r\n                        }\r\n                        // fix red violation\r\n                        if (RBTree.is_red(node) && RBTree.is_red(p)) {\r\n                            var dir2 = ggp.right === gp;\r\n                            if (node === p.get_child(last)) {\r\n                                ggp.set_child(dir2, RBTree.single_rotate(gp, !last));\r\n                            }\r\n                            else {\r\n                                ggp.set_child(dir2, RBTree.double_rotate(gp, !last));\r\n                            }\r\n                        }\r\n                        var cmp = this._comparator(node.data, data);\r\n                        // stop if found\r\n                        if (cmp === 0) {\r\n                            break;\r\n                        }\r\n                        last = dir;\r\n                        dir = cmp < 0;\r\n                        // update helpers\r\n                        if (gp !== null) {\r\n                            ggp = gp;\r\n                        }\r\n                        gp = p;\r\n                        p = node;\r\n                        node = node.get_child(dir);\r\n                    }\r\n                    // update root\r\n                    this._root = head.right;\r\n                }\r\n                // make root black\r\n                this._root.red = false;\r\n                return ret;\r\n            };\r\n            ;\r\n            // returns true if removed, false if not found\r\n            RBTree.prototype.remove = function (data) {\r\n                if (this._root === null) {\r\n                    return false;\r\n                }\r\n                var head = new Node(undefined); // fake tree root\r\n                var node = head;\r\n                node.right = this._root;\r\n                var p = null; // parent\r\n                var gp = null; // grand parent\r\n                var found = null; // found item\r\n                var dir = true;\r\n                while (node.get_child(dir) !== null) {\r\n                    var last = dir;\r\n                    // update helpers\r\n                    gp = p;\r\n                    p = node;\r\n                    node = node.get_child(dir);\r\n                    var cmp = this._comparator(data, node.data);\r\n                    dir = cmp > 0;\r\n                    // save found node\r\n                    if (cmp === 0) {\r\n                        found = node;\r\n                    }\r\n                    // push the red node down\r\n                    if (!RBTree.is_red(node) && !RBTree.is_red(node.get_child(dir))) {\r\n                        if (RBTree.is_red(node.get_child(!dir))) {\r\n                            var sr = RBTree.single_rotate(node, dir);\r\n                            p.set_child(last, sr);\r\n                            p = sr;\r\n                        }\r\n                        else if (!RBTree.is_red(node.get_child(!dir))) {\r\n                            var sibling = p.get_child(!last);\r\n                            if (sibling !== null) {\r\n                                if (!RBTree.is_red(sibling.get_child(!last)) && !RBTree.is_red(sibling.get_child(last))) {\r\n                                    // color flip\r\n                                    p.red = false;\r\n                                    sibling.red = true;\r\n                                    node.red = true;\r\n                                }\r\n                                else {\r\n                                    var dir2 = gp.right === p;\r\n                                    if (RBTree.is_red(sibling.get_child(last))) {\r\n                                        gp.set_child(dir2, RBTree.double_rotate(p, last));\r\n                                    }\r\n                                    else if (RBTree.is_red(sibling.get_child(!last))) {\r\n                                        gp.set_child(dir2, RBTree.single_rotate(p, last));\r\n                                    }\r\n                                    // ensure correct coloring\r\n                                    var gpc = gp.get_child(dir2);\r\n                                    gpc.red = true;\r\n                                    node.red = true;\r\n                                    gpc.left.red = false;\r\n                                    gpc.right.red = false;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // replace and remove if found\r\n                if (found !== null) {\r\n                    found.data = node.data;\r\n                    p.set_child(p.right === node, node.get_child(node.left === null));\r\n                    this.size--;\r\n                }\r\n                // update root and make it black\r\n                this._root = head.right;\r\n                if (this._root !== null) {\r\n                    this._root.red = false;\r\n                }\r\n                return found !== null;\r\n            };\r\n            ;\r\n            RBTree.is_red = function (node) {\r\n                return node !== null && node.red;\r\n            };\r\n            RBTree.single_rotate = function (root, dir) {\r\n                var save = root.get_child(!dir);\r\n                root.set_child(!dir, save.get_child(dir));\r\n                save.set_child(dir, root);\r\n                root.red = true;\r\n                save.red = false;\r\n                return save;\r\n            };\r\n            RBTree.double_rotate = function (root, dir) {\r\n                root.set_child(!dir, RBTree.single_rotate(root.get_child(!dir), !dir));\r\n                return RBTree.single_rotate(root, dir);\r\n            };\r\n            return RBTree;\r\n        })(TreeBase);\r\n        vpsc.RBTree = RBTree;\r\n    })(vpsc = cola.vpsc || (cola.vpsc = {}));\r\n})(cola || (cola = {}));\r\n///<reference path=\"vpsc.ts\"/>\r\n///<reference path=\"rbtree.ts\"/>\r\nvar cola;\r\n(function (cola) {\r\n    var vpsc;\r\n    (function (vpsc) {\r\n        function computeGroupBounds(g) {\r\n            g.bounds = typeof g.leaves !== \"undefined\" ?\r\n                g.leaves.reduce(function (r, c) { return c.bounds.union(r); }, Rectangle.empty()) :\r\n                Rectangle.empty();\r\n            if (typeof g.groups !== \"undefined\")\r\n                g.bounds = g.groups.reduce(function (r, c) { return computeGroupBounds(c).union(r); }, g.bounds);\r\n            g.bounds = g.bounds.inflate(g.padding);\r\n            return g.bounds;\r\n        }\r\n        vpsc.computeGroupBounds = computeGroupBounds;\r\n        var Rectangle = (function () {\r\n            function Rectangle(x, X, y, Y) {\r\n                this.x = x;\r\n                this.X = X;\r\n                this.y = y;\r\n                this.Y = Y;\r\n            }\r\n            Rectangle.empty = function () { return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY); };\r\n            Rectangle.prototype.cx = function () { return (this.x + this.X) / 2; };\r\n            Rectangle.prototype.cy = function () { return (this.y + this.Y) / 2; };\r\n            Rectangle.prototype.overlapX = function (r) {\r\n                var ux = this.cx(), vx = r.cx();\r\n                if (ux <= vx && r.x < this.X)\r\n                    return this.X - r.x;\r\n                if (vx <= ux && this.x < r.X)\r\n                    return r.X - this.x;\r\n                return 0;\r\n            };\r\n            Rectangle.prototype.overlapY = function (r) {\r\n                var uy = this.cy(), vy = r.cy();\r\n                if (uy <= vy && r.y < this.Y)\r\n                    return this.Y - r.y;\r\n                if (vy <= uy && this.y < r.Y)\r\n                    return r.Y - this.y;\r\n                return 0;\r\n            };\r\n            Rectangle.prototype.setXCentre = function (cx) {\r\n                var dx = cx - this.cx();\r\n                this.x += dx;\r\n                this.X += dx;\r\n            };\r\n            Rectangle.prototype.setYCentre = function (cy) {\r\n                var dy = cy - this.cy();\r\n                this.y += dy;\r\n                this.Y += dy;\r\n            };\r\n            Rectangle.prototype.width = function () {\r\n                return this.X - this.x;\r\n            };\r\n            Rectangle.prototype.height = function () {\r\n                return this.Y - this.y;\r\n            };\r\n            Rectangle.prototype.union = function (r) {\r\n                return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));\r\n            };\r\n            /**\r\n             * return any intersection points between the given line and the sides of this rectangle\r\n             * @method lineIntersection\r\n             * @param x1 number first x coord of line\r\n             * @param y1 number first y coord of line\r\n             * @param x2 number second x coord of line\r\n             * @param y2 number second y coord of line\r\n             * @return any intersection points found\r\n             */\r\n            Rectangle.prototype.lineIntersections = function (x1, y1, x2, y2) {\r\n                var sides = [[this.x, this.y, this.X, this.y],\r\n                    [this.X, this.y, this.X, this.Y],\r\n                    [this.X, this.Y, this.x, this.Y],\r\n                    [this.x, this.Y, this.x, this.y]];\r\n                var intersections = [];\r\n                for (var i = 0; i < 4; ++i) {\r\n                    var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);\r\n                    if (r !== null)\r\n                        intersections.push({ x: r.x, y: r.y });\r\n                }\r\n                return intersections;\r\n            };\r\n            /**\r\n             * return any intersection points between a line extending from the centre of this rectangle to the given point,\r\n             *  and the sides of this rectangle\r\n             * @method lineIntersection\r\n             * @param x2 number second x coord of line\r\n             * @param y2 number second y coord of line\r\n             * @return any intersection points found\r\n             */\r\n            Rectangle.prototype.rayIntersection = function (x2, y2) {\r\n                var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);\r\n                return ints.length > 0 ? ints[0] : null;\r\n            };\r\n            Rectangle.prototype.vertices = function () {\r\n                return [\r\n                    { x: this.x, y: this.y },\r\n                    { x: this.X, y: this.y },\r\n                    { x: this.X, y: this.Y },\r\n                    { x: this.x, y: this.Y },\r\n                    { x: this.x, y: this.y }];\r\n            };\r\n            Rectangle.lineIntersection = function (x1, y1, x2, y2, x3, y3, x4, y4) {\r\n                var dx12 = x2 - x1, dx34 = x4 - x3, dy12 = y2 - y1, dy34 = y4 - y3, denominator = dy34 * dx12 - dx34 * dy12;\r\n                if (denominator == 0)\r\n                    return null;\r\n                var dx31 = x1 - x3, dy31 = y1 - y3, numa = dx34 * dy31 - dy34 * dx31, a = numa / denominator, numb = dx12 * dy31 - dy12 * dx31, b = numb / denominator;\r\n                if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {\r\n                    return {\r\n                        x: x1 + a * dx12,\r\n                        y: y1 + a * dy12\r\n                    };\r\n                }\r\n                return null;\r\n            };\r\n            Rectangle.prototype.inflate = function (pad) {\r\n                return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);\r\n            };\r\n            return Rectangle;\r\n        })();\r\n        vpsc.Rectangle = Rectangle;\r\n        function makeEdgeBetween(source, target, ah) {\r\n            var si = source.rayIntersection(target.cx(), target.cy()) || { x: source.cx(), y: source.cy() }, ti = target.rayIntersection(source.cx(), source.cy()) || { x: target.cx(), y: target.cy() }, dx = ti.x - si.x, dy = ti.y - si.y, l = Math.sqrt(dx * dx + dy * dy), al = l - ah;\r\n            return {\r\n                sourceIntersection: si,\r\n                targetIntersection: ti,\r\n                arrowStart: { x: si.x + al * dx / l, y: si.y + al * dy / l }\r\n            };\r\n        }\r\n        vpsc.makeEdgeBetween = makeEdgeBetween;\r\n        function makeEdgeTo(s, target, ah) {\r\n            var ti = target.rayIntersection(s.x, s.y);\r\n            if (!ti)\r\n                ti = { x: target.cx(), y: target.cy() };\r\n            var dx = ti.x - s.x, dy = ti.y - s.y, l = Math.sqrt(dx * dx + dy * dy);\r\n            return { x: ti.x - ah * dx / l, y: ti.y - ah * dy / l };\r\n        }\r\n        vpsc.makeEdgeTo = makeEdgeTo;\r\n        var Node = (function () {\r\n            function Node(v, r, pos) {\r\n                this.v = v;\r\n                this.r = r;\r\n                this.pos = pos;\r\n                this.prev = makeRBTree();\r\n                this.next = makeRBTree();\r\n            }\r\n            return Node;\r\n        })();\r\n        var Event = (function () {\r\n            function Event(isOpen, v, pos) {\r\n                this.isOpen = isOpen;\r\n                this.v = v;\r\n                this.pos = pos;\r\n            }\r\n            return Event;\r\n        })();\r\n        function compareEvents(a, b) {\r\n            if (a.pos > b.pos) {\r\n                return 1;\r\n            }\r\n            if (a.pos < b.pos) {\r\n                return -1;\r\n            }\r\n            if (a.isOpen) {\r\n                // open must come before close\r\n                return -1;\r\n            }\r\n            if (b.isOpen) {\r\n                // open must come before close\r\n                return 1;\r\n            }\r\n            return 0;\r\n        }\r\n        function makeRBTree() {\r\n            return new vpsc.RBTree(function (a, b) { return a.pos - b.pos; });\r\n        }\r\n        var xRect = {\r\n            getCentre: function (r) { return r.cx(); },\r\n            getOpen: function (r) { return r.y; },\r\n            getClose: function (r) { return r.Y; },\r\n            getSize: function (r) { return r.width(); },\r\n            makeRect: function (open, close, center, size) { return new Rectangle(center - size / 2, center + size / 2, open, close); },\r\n            findNeighbours: findXNeighbours\r\n        };\r\n        var yRect = {\r\n            getCentre: function (r) { return r.cy(); },\r\n            getOpen: function (r) { return r.x; },\r\n            getClose: function (r) { return r.X; },\r\n            getSize: function (r) { return r.height(); },\r\n            makeRect: function (open, close, center, size) { return new Rectangle(open, close, center - size / 2, center + size / 2); },\r\n            findNeighbours: findYNeighbours\r\n        };\r\n        function generateGroupConstraints(root, f, minSep, isContained) {\r\n            if (isContained === void 0) { isContained = false; }\r\n            var padding = root.padding, gn = typeof root.groups !== 'undefined' ? root.groups.length : 0, ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0, childConstraints = !gn ? []\r\n                : root.groups.reduce(function (ccs, g) { return ccs.concat(generateGroupConstraints(g, f, minSep, true)); }, []), n = (isContained ? 2 : 0) + ln + gn, vs = new Array(n), rs = new Array(n), i = 0, add = function (r, v) { rs[i] = r; vs[i++] = v; };\r\n            if (isContained) {\r\n                // if this group is contained by another, then we add two dummy vars and rectangles for the borders\r\n                var b = root.bounds, c = f.getCentre(b), s = f.getSize(b) / 2, open = f.getOpen(b), close = f.getClose(b), min = c - s + padding / 2, max = c + s - padding / 2;\r\n                root.minVar.desiredPosition = min;\r\n                add(f.makeRect(open, close, min, padding), root.minVar);\r\n                root.maxVar.desiredPosition = max;\r\n                add(f.makeRect(open, close, max, padding), root.maxVar);\r\n            }\r\n            if (ln)\r\n                root.leaves.forEach(function (l) { return add(l.bounds, l.variable); });\r\n            if (gn)\r\n                root.groups.forEach(function (g) {\r\n                    var b = g.bounds;\r\n                    add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);\r\n                });\r\n            var cs = generateConstraints(rs, vs, f, minSep);\r\n            if (gn) {\r\n                vs.forEach(function (v) { v.cOut = [], v.cIn = []; });\r\n                cs.forEach(function (c) { c.left.cOut.push(c), c.right.cIn.push(c); });\r\n                root.groups.forEach(function (g) {\r\n                    var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;\r\n                    g.minVar.cIn.forEach(function (c) { return c.gap += gapAdjustment; });\r\n                    g.minVar.cOut.forEach(function (c) { c.left = g.maxVar; c.gap += gapAdjustment; });\r\n                });\r\n            }\r\n            return childConstraints.concat(cs);\r\n        }\r\n        function generateConstraints(rs, vars, rect, minSep) {\r\n            var i, n = rs.length;\r\n            var N = 2 * n;\r\n            console.assert(vars.length >= n);\r\n            var events = new Array(N);\r\n            for (i = 0; i < n; ++i) {\r\n                var r = rs[i];\r\n                var v = new Node(vars[i], r, rect.getCentre(r));\r\n                events[i] = new Event(true, v, rect.getOpen(r));\r\n                events[i + n] = new Event(false, v, rect.getClose(r));\r\n            }\r\n            events.sort(compareEvents);\r\n            var cs = new Array();\r\n            var scanline = makeRBTree();\r\n            for (i = 0; i < N; ++i) {\r\n                var e = events[i];\r\n                var v = e.v;\r\n                if (e.isOpen) {\r\n                    scanline.insert(v);\r\n                    rect.findNeighbours(v, scanline);\r\n                }\r\n                else {\r\n                    // close event\r\n                    scanline.remove(v);\r\n                    var makeConstraint = function (l, r) {\r\n                        var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;\r\n                        cs.push(new vpsc.Constraint(l.v, r.v, sep));\r\n                    };\r\n                    var visitNeighbours = function (forward, reverse, mkcon) {\r\n                        var u, it = v[forward].iterator();\r\n                        while ((u = it[forward]()) !== null) {\r\n                            mkcon(u, v);\r\n                            u[reverse].remove(v);\r\n                        }\r\n                    };\r\n                    visitNeighbours(\"prev\", \"next\", function (u, v) { return makeConstraint(u, v); });\r\n                    visitNeighbours(\"next\", \"prev\", function (u, v) { return makeConstraint(v, u); });\r\n                }\r\n            }\r\n            console.assert(scanline.size === 0);\r\n            return cs;\r\n        }\r\n        function findXNeighbours(v, scanline) {\r\n            var f = function (forward, reverse) {\r\n                var it = scanline.findIter(v);\r\n                var u;\r\n                while ((u = it[forward]()) !== null) {\r\n                    var uovervX = u.r.overlapX(v.r);\r\n                    if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {\r\n                        v[forward].insert(u);\r\n                        u[reverse].insert(v);\r\n                    }\r\n                    if (uovervX <= 0) {\r\n                        break;\r\n                    }\r\n                }\r\n            };\r\n            f(\"next\", \"prev\");\r\n            f(\"prev\", \"next\");\r\n        }\r\n        function findYNeighbours(v, scanline) {\r\n            var f = function (forward, reverse) {\r\n                var u = scanline.findIter(v)[forward]();\r\n                if (u !== null && u.r.overlapX(v.r) > 0) {\r\n                    v[forward].insert(u);\r\n                    u[reverse].insert(v);\r\n                }\r\n            };\r\n            f(\"next\", \"prev\");\r\n            f(\"prev\", \"next\");\r\n        }\r\n        function generateXConstraints(rs, vars) {\r\n            return generateConstraints(rs, vars, xRect, 1e-6);\r\n        }\r\n        vpsc.generateXConstraints = generateXConstraints;\r\n        function generateYConstraints(rs, vars) {\r\n            return generateConstraints(rs, vars, yRect, 1e-6);\r\n        }\r\n        vpsc.generateYConstraints = generateYConstraints;\r\n        function generateXGroupConstraints(root) {\r\n            return generateGroupConstraints(root, xRect, 1e-6);\r\n        }\r\n        vpsc.generateXGroupConstraints = generateXGroupConstraints;\r\n        function generateYGroupConstraints(root) {\r\n            return generateGroupConstraints(root, yRect, 1e-6);\r\n        }\r\n        vpsc.generateYGroupConstraints = generateYGroupConstraints;\r\n        function removeOverlaps(rs) {\r\n            var vs = rs.map(function (r) { return new vpsc.Variable(r.cx()); });\r\n            var cs = vpsc.generateXConstraints(rs, vs);\r\n            var solver = new vpsc.Solver(vs, cs);\r\n            solver.solve();\r\n            vs.forEach(function (v, i) { return rs[i].setXCentre(v.position()); });\r\n            vs = rs.map(function (r) { return new vpsc.Variable(r.cy()); });\r\n            cs = vpsc.generateYConstraints(rs, vs);\r\n            solver = new vpsc.Solver(vs, cs);\r\n            solver.solve();\r\n            vs.forEach(function (v, i) { return rs[i].setYCentre(v.position()); });\r\n        }\r\n        vpsc.removeOverlaps = removeOverlaps;\r\n        var IndexedVariable = (function (_super) {\r\n            __extends(IndexedVariable, _super);\r\n            function IndexedVariable(index, w) {\r\n                _super.call(this, 0, w);\r\n                this.index = index;\r\n            }\r\n            return IndexedVariable;\r\n        })(vpsc.Variable);\r\n        vpsc.IndexedVariable = IndexedVariable;\r\n        var Projection = (function () {\r\n            function Projection(nodes, groups, rootGroup, constraints, avoidOverlaps) {\r\n                var _this = this;\r\n                if (rootGroup === void 0) { rootGroup = null; }\r\n                if (constraints === void 0) { constraints = null; }\r\n                if (avoidOverlaps === void 0) { avoidOverlaps = false; }\r\n                this.nodes = nodes;\r\n                this.groups = groups;\r\n                this.rootGroup = rootGroup;\r\n                this.avoidOverlaps = avoidOverlaps;\r\n                this.variables = nodes.map(function (v, i) {\r\n                    return v.variable = new IndexedVariable(i, 1);\r\n                });\r\n                if (constraints)\r\n                    this.createConstraints(constraints);\r\n                if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {\r\n                    nodes.forEach(function (v) {\r\n                        if (!v.width || !v.height) {\r\n                            //If undefined, default to nothing\r\n                            v.bounds = new vpsc.Rectangle(v.x, v.x, v.y, v.y);\r\n                            return;\r\n                        }\r\n                        var w2 = v.width / 2, h2 = v.height / 2;\r\n                        v.bounds = new vpsc.Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);\r\n                    });\r\n                    computeGroupBounds(rootGroup);\r\n                    var i = nodes.length;\r\n                    groups.forEach(function (g) {\r\n                        _this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\r\n                        _this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\r\n                    });\r\n                }\r\n            }\r\n            Projection.prototype.createSeparation = function (c) {\r\n                return new vpsc.Constraint(this.nodes[c.left].variable, this.nodes[c.right].variable, c.gap, typeof c.equality !== \"undefined\" ? c.equality : false);\r\n            };\r\n            Projection.prototype.makeFeasible = function (c) {\r\n                var _this = this;\r\n                if (!this.avoidOverlaps)\r\n                    return;\r\n                var axis = 'x', dim = 'width';\r\n                if (c.axis === 'x')\r\n                    axis = 'y', dim = 'height';\r\n                var vs = c.offsets.map(function (o) { return _this.nodes[o.node]; }).sort(function (a, b) { return a[axis] - b[axis]; });\r\n                var p = null;\r\n                vs.forEach(function (v) {\r\n                    if (p)\r\n                        v[axis] = p[axis] + p[dim] + 1;\r\n                    p = v;\r\n                });\r\n            };\r\n            Projection.prototype.createAlignment = function (c) {\r\n                var _this = this;\r\n                var u = this.nodes[c.offsets[0].node].variable;\r\n                this.makeFeasible(c);\r\n                var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;\r\n                c.offsets.slice(1).forEach(function (o) {\r\n                    var v = _this.nodes[o.node].variable;\r\n                    cs.push(new vpsc.Constraint(u, v, o.offset, true));\r\n                });\r\n            };\r\n            Projection.prototype.createConstraints = function (constraints) {\r\n                var _this = this;\r\n                var isSep = function (c) { return typeof c.type === 'undefined' || c.type === 'separation'; };\r\n                this.xConstraints = constraints\r\n                    .filter(function (c) { return c.axis === \"x\" && isSep(c); })\r\n                    .map(function (c) { return _this.createSeparation(c); });\r\n                this.yConstraints = constraints\r\n                    .filter(function (c) { return c.axis === \"y\" && isSep(c); })\r\n                    .map(function (c) { return _this.createSeparation(c); });\r\n                constraints\r\n                    .filter(function (c) { return c.type === 'alignment'; })\r\n                    .forEach(function (c) { return _this.createAlignment(c); });\r\n            };\r\n            Projection.prototype.setupVariablesAndBounds = function (x0, y0, desired, getDesired) {\r\n                this.nodes.forEach(function (v, i) {\r\n                    if (v.fixed) {\r\n                        v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;\r\n                        desired[i] = getDesired(v);\r\n                    }\r\n                    else {\r\n                        v.variable.weight = 1;\r\n                    }\r\n                    var w = (v.width || 0) / 2, h = (v.height || 0) / 2;\r\n                    var ix = x0[i], iy = y0[i];\r\n                    v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);\r\n                });\r\n            };\r\n            Projection.prototype.xProject = function (x0, y0, x) {\r\n                if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints))\r\n                    return;\r\n                this.project(x0, y0, x0, x, function (v) { return v.px; }, this.xConstraints, generateXGroupConstraints, function (v) { return v.bounds.setXCentre(x[v.variable.index] = v.variable.position()); }, function (g) {\r\n                    var xmin = x[g.minVar.index] = g.minVar.position();\r\n                    var xmax = x[g.maxVar.index] = g.maxVar.position();\r\n                    var p2 = g.padding / 2;\r\n                    g.bounds.x = xmin - p2;\r\n                    g.bounds.X = xmax + p2;\r\n                });\r\n            };\r\n            Projection.prototype.yProject = function (x0, y0, y) {\r\n                if (!this.rootGroup && !this.yConstraints)\r\n                    return;\r\n                this.project(x0, y0, y0, y, function (v) { return v.py; }, this.yConstraints, generateYGroupConstraints, function (v) { return v.bounds.setYCentre(y[v.variable.index] = v.variable.position()); }, function (g) {\r\n                    var ymin = y[g.minVar.index] = g.minVar.position();\r\n                    var ymax = y[g.maxVar.index] = g.maxVar.position();\r\n                    var p2 = g.padding / 2;\r\n                    g.bounds.y = ymin - p2;\r\n                    ;\r\n                    g.bounds.Y = ymax + p2;\r\n                });\r\n            };\r\n            Projection.prototype.projectFunctions = function () {\r\n                var _this = this;\r\n                return [\r\n                    function (x0, y0, x) { return _this.xProject(x0, y0, x); },\r\n                    function (x0, y0, y) { return _this.yProject(x0, y0, y); }\r\n                ];\r\n            };\r\n            Projection.prototype.project = function (x0, y0, start, desired, getDesired, cs, generateConstraints, updateNodeBounds, updateGroupBounds) {\r\n                this.setupVariablesAndBounds(x0, y0, desired, getDesired);\r\n                if (this.rootGroup && this.avoidOverlaps) {\r\n                    computeGroupBounds(this.rootGroup);\r\n                    cs = cs.concat(generateConstraints(this.rootGroup));\r\n                }\r\n                this.solve(this.variables, cs, start, desired);\r\n                this.nodes.forEach(updateNodeBounds);\r\n                if (this.rootGroup && this.avoidOverlaps) {\r\n                    this.groups.forEach(updateGroupBounds);\r\n                    computeGroupBounds(this.rootGroup);\r\n                }\r\n            };\r\n            Projection.prototype.solve = function (vs, cs, starting, desired) {\r\n                var solver = new vpsc.Solver(vs, cs);\r\n                solver.setStartingPositions(starting);\r\n                solver.setDesiredPositions(desired);\r\n                solver.solve();\r\n            };\r\n            return Projection;\r\n        })();\r\n        vpsc.Projection = Projection;\r\n    })(vpsc = cola.vpsc || (cola.vpsc = {}));\r\n})(cola || (cola = {}));\r\n///<reference path=\"vpsc.ts\"/>\r\n///<reference path=\"rectangle.ts\"/>\r\nvar cola;\r\n(function (cola) {\r\n    var geom;\r\n    (function (geom) {\r\n        var Point = (function () {\r\n            function Point() {\r\n            }\r\n            return Point;\r\n        })();\r\n        geom.Point = Point;\r\n        var LineSegment = (function () {\r\n            function LineSegment(x1, y1, x2, y2) {\r\n                this.x1 = x1;\r\n                this.y1 = y1;\r\n                this.x2 = x2;\r\n                this.y2 = y2;\r\n            }\r\n            return LineSegment;\r\n        })();\r\n        geom.LineSegment = LineSegment;\r\n        var PolyPoint = (function (_super) {\r\n            __extends(PolyPoint, _super);\r\n            function PolyPoint() {\r\n                _super.apply(this, arguments);\r\n            }\r\n            return PolyPoint;\r\n        })(Point);\r\n        geom.PolyPoint = PolyPoint;\r\n        /** tests if a point is Left|On|Right of an infinite line.\r\n         * @param points P0, P1, and P2\r\n         * @return >0 for P2 left of the line through P0 and P1\r\n         *            =0 for P2 on the line\r\n         *            <0 for P2 right of the line\r\n         */\r\n        function isLeft(P0, P1, P2) {\r\n            return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);\r\n        }\r\n        geom.isLeft = isLeft;\r\n        function above(p, vi, vj) {\r\n            return isLeft(p, vi, vj) > 0;\r\n        }\r\n        function below(p, vi, vj) {\r\n            return isLeft(p, vi, vj) < 0;\r\n        }\r\n        /**\r\n         * returns the convex hull of a set of points using Andrew's monotone chain algorithm\r\n         * see: http://geomalgorithms.com/a10-_hull-1.html#Monotone%20Chain\r\n         * @param S array of points\r\n         * @return the convex hull as an array of points\r\n         */\r\n        function ConvexHull(S) {\r\n            var P = S.slice(0).sort(function (a, b) { return a.x !== b.x ? b.x - a.x : b.y - a.y; });\r\n            var n = S.length, i;\r\n            var minmin = 0;\r\n            var xmin = P[0].x;\r\n            for (i = 1; i < n; ++i) {\r\n                if (P[i].x !== xmin)\r\n                    break;\r\n            }\r\n            var minmax = i - 1;\r\n            var H = [];\r\n            H.push(P[minmin]); // push minmin point onto stack\r\n            if (minmax === n - 1) {\r\n                if (P[minmax].y !== P[minmin].y)\r\n                    H.push(P[minmax]);\r\n            }\r\n            else {\r\n                // Get the indices of points with max x-coord and min|max y-coord\r\n                var maxmin, maxmax = n - 1;\r\n                var xmax = P[n - 1].x;\r\n                for (i = n - 2; i >= 0; i--)\r\n                    if (P[i].x !== xmax)\r\n                        break;\r\n                maxmin = i + 1;\r\n                // Compute the lower hull on the stack H\r\n                i = minmax;\r\n                while (++i <= maxmin) {\r\n                    // the lower line joins P[minmin]  with P[maxmin]\r\n                    if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin)\r\n                        continue; // ignore P[i] above or on the lower line\r\n                    while (H.length > 1) {\r\n                        // test if  P[i] is left of the line at the stack top\r\n                        if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\r\n                            break; // P[i] is a new hull  vertex\r\n                        else\r\n                            H.length -= 1; // pop top point off  stack\r\n                    }\r\n                    if (i != minmin)\r\n                        H.push(P[i]);\r\n                }\r\n                // Next, compute the upper hull on the stack H above the bottom hull\r\n                if (maxmax != maxmin)\r\n                    H.push(P[maxmax]); // push maxmax point onto stack\r\n                var bot = H.length; // the bottom point of the upper hull stack\r\n                i = maxmin;\r\n                while (--i >= minmax) {\r\n                    // the upper line joins P[maxmax]  with P[minmax]\r\n                    if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax)\r\n                        continue; // ignore P[i] below or on the upper line\r\n                    while (H.length > bot) {\r\n                        // test if  P[i] is left of the line at the stack top\r\n                        if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\r\n                            break; // P[i] is a new hull  vertex\r\n                        else\r\n                            H.length -= 1; // pop top point off  stack\r\n                    }\r\n                    if (i != minmin)\r\n                        H.push(P[i]); // push P[i] onto stack\r\n                }\r\n            }\r\n            return H;\r\n        }\r\n        geom.ConvexHull = ConvexHull;\r\n        // apply f to the points in P in clockwise order around the point p\r\n        function clockwiseRadialSweep(p, P, f) {\r\n            P.slice(0).sort(function (a, b) { return Math.atan2(a.y - p.y, a.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x); }).forEach(f);\r\n        }\r\n        geom.clockwiseRadialSweep = clockwiseRadialSweep;\r\n        function nextPolyPoint(p, ps) {\r\n            if (p.polyIndex === ps.length - 1)\r\n                return ps[0];\r\n            return ps[p.polyIndex + 1];\r\n        }\r\n        function prevPolyPoint(p, ps) {\r\n            if (p.polyIndex === 0)\r\n                return ps[ps.length - 1];\r\n            return ps[p.polyIndex - 1];\r\n        }\r\n        // tangent_PointPolyC(): fast binary search for tangents to a convex polygon\r\n        //    Input:  P = a 2D point (exterior to the polygon)\r\n        //            n = number of polygon vertices\r\n        //            V = array of vertices for a 2D convex polygon with V[n] = V[0]\r\n        //    Output: rtan = index of rightmost tangent point V[rtan]\r\n        //            ltan = index of leftmost tangent point V[ltan]\r\n        function tangent_PointPolyC(P, V) {\r\n            return { rtan: Rtangent_PointPolyC(P, V), ltan: Ltangent_PointPolyC(P, V) };\r\n        }\r\n        // Rtangent_PointPolyC(): binary search for convex polygon right tangent\r\n        //    Input:  P = a 2D point (exterior to the polygon)\r\n        //            n = number of polygon vertices\r\n        //            V = array of vertices for a 2D convex polygon with V[n] = V[0]\r\n        //    Return: index \"i\" of rightmost tangent point V[i]\r\n        function Rtangent_PointPolyC(P, V) {\r\n            var n = V.length - 1;\r\n            // use binary search for large convex polygons\r\n            var a, b, c; // indices for edge chain endpoints\r\n            var upA, dnC; // test for up direction of edges a and c\r\n            // rightmost tangent = maximum for the isLeft() ordering\r\n            // test if V[0] is a local maximum\r\n            if (below(P, V[1], V[0]) && !above(P, V[n - 1], V[0]))\r\n                return 0; // V[0] is the maximum tangent point\r\n            for (a = 0, b = n;;) {\r\n                if (b - a === 1)\r\n                    if (above(P, V[a], V[b]))\r\n                        return a;\r\n                    else\r\n                        return b;\r\n                c = Math.floor((a + b) / 2); // midpoint of [a,b], and 0<c<n\r\n                dnC = below(P, V[c + 1], V[c]);\r\n                if (dnC && !above(P, V[c - 1], V[c]))\r\n                    return c; // V[c] is the maximum tangent point\r\n                // no max yet, so continue with the binary search\r\n                // pick one of the two subchains [a,c] or [c,b]\r\n                upA = above(P, V[a + 1], V[a]);\r\n                if (upA) {\r\n                    if (dnC)\r\n                        b = c; // select [a,c]\r\n                    else {\r\n                        if (above(P, V[a], V[c]))\r\n                            b = c; // select [a,c]\r\n                        else\r\n                            a = c; // select [c,b]\r\n                    }\r\n                }\r\n                else {\r\n                    if (!dnC)\r\n                        a = c; // select [c,b]\r\n                    else {\r\n                        if (below(P, V[a], V[c]))\r\n                            b = c; // select [a,c]\r\n                        else\r\n                            a = c; // select [c,b]\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Ltangent_PointPolyC(): binary search for convex polygon left tangent\r\n        //    Input:  P = a 2D point (exterior to the polygon)\r\n        //            n = number of polygon vertices\r\n        //            V = array of vertices for a 2D convex polygon with V[n]=V[0]\r\n        //    Return: index \"i\" of leftmost tangent point V[i]\r\n        function Ltangent_PointPolyC(P, V) {\r\n            var n = V.length - 1;\r\n            // use binary search for large convex polygons\r\n            var a, b, c; // indices for edge chain endpoints\r\n            var dnA, dnC; // test for down direction of edges a and c\r\n            // leftmost tangent = minimum for the isLeft() ordering\r\n            // test if V[0] is a local minimum\r\n            if (above(P, V[n - 1], V[0]) && !below(P, V[1], V[0]))\r\n                return 0; // V[0] is the minimum tangent point\r\n            for (a = 0, b = n;;) {\r\n                if (b - a === 1)\r\n                    if (below(P, V[a], V[b]))\r\n                        return a;\r\n                    else\r\n                        return b;\r\n                c = Math.floor((a + b) / 2); // midpoint of [a,b], and 0<c<n\r\n                dnC = below(P, V[c + 1], V[c]);\r\n                if (above(P, V[c - 1], V[c]) && !dnC)\r\n                    return c; // V[c] is the minimum tangent point\r\n                // no min yet, so continue with the binary search\r\n                // pick one of the two subchains [a,c] or [c,b]\r\n                dnA = below(P, V[a + 1], V[a]);\r\n                if (dnA) {\r\n                    if (!dnC)\r\n                        b = c; // select [a,c]\r\n                    else {\r\n                        if (below(P, V[a], V[c]))\r\n                            b = c; // select [a,c]\r\n                        else\r\n                            a = c; // select [c,b]\r\n                    }\r\n                }\r\n                else {\r\n                    if (dnC)\r\n                        a = c; // select [c,b]\r\n                    else {\r\n                        if (above(P, V[a], V[c]))\r\n                            b = c; // select [a,c]\r\n                        else\r\n                            a = c; // select [c,b]\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // RLtangent_PolyPolyC(): get the RL tangent between two convex polygons\r\n        //    Input:  m = number of vertices in polygon 1\r\n        //            V = array of vertices for convex polygon 1 with V[m]=V[0]\r\n        //            n = number of vertices in polygon 2\r\n        //            W = array of vertices for convex polygon 2 with W[n]=W[0]\r\n        //    Output: *t1 = index of tangent point V[t1] for polygon 1\r\n        //            *t2 = index of tangent point W[t2] for polygon 2\r\n        function tangent_PolyPolyC(V, W, t1, t2, cmp1, cmp2) {\r\n            var ix1, ix2; // search indices for polygons 1 and 2\r\n            // first get the initial vertex on each polygon\r\n            ix1 = t1(W[0], V); // right tangent from W[0] to V\r\n            ix2 = t2(V[ix1], W); // left tangent from V[ix1] to W\r\n            // ping-pong linear search until it stabilizes\r\n            var done = false; // flag when done\r\n            while (!done) {\r\n                done = true; // assume done until...\r\n                while (true) {\r\n                    if (ix1 === V.length - 1)\r\n                        ix1 = 0;\r\n                    if (cmp1(W[ix2], V[ix1], V[ix1 + 1]))\r\n                        break;\r\n                    ++ix1; // get Rtangent from W[ix2] to V\r\n                }\r\n                while (true) {\r\n                    if (ix2 === 0)\r\n                        ix2 = W.length - 1;\r\n                    if (cmp2(V[ix1], W[ix2], W[ix2 - 1]))\r\n                        break;\r\n                    --ix2; // get Ltangent from V[ix1] to W\r\n                    done = false; // not done if had to adjust this\r\n                }\r\n            }\r\n            return { t1: ix1, t2: ix2 };\r\n        }\r\n        geom.tangent_PolyPolyC = tangent_PolyPolyC;\r\n        function LRtangent_PolyPolyC(V, W) {\r\n            var rl = RLtangent_PolyPolyC(W, V);\r\n            return { t1: rl.t2, t2: rl.t1 };\r\n        }\r\n        geom.LRtangent_PolyPolyC = LRtangent_PolyPolyC;\r\n        function RLtangent_PolyPolyC(V, W) {\r\n            return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above, below);\r\n        }\r\n        geom.RLtangent_PolyPolyC = RLtangent_PolyPolyC;\r\n        function LLtangent_PolyPolyC(V, W) {\r\n            return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);\r\n        }\r\n        geom.LLtangent_PolyPolyC = LLtangent_PolyPolyC;\r\n        function RRtangent_PolyPolyC(V, W) {\r\n            return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above, above);\r\n        }\r\n        geom.RRtangent_PolyPolyC = RRtangent_PolyPolyC;\r\n        var BiTangent = (function () {\r\n            function BiTangent(t1, t2) {\r\n                this.t1 = t1;\r\n                this.t2 = t2;\r\n            }\r\n            return BiTangent;\r\n        })();\r\n        geom.BiTangent = BiTangent;\r\n        var BiTangents = (function () {\r\n            function BiTangents() {\r\n            }\r\n            return BiTangents;\r\n        })();\r\n        geom.BiTangents = BiTangents;\r\n        var TVGPoint = (function (_super) {\r\n            __extends(TVGPoint, _super);\r\n            function TVGPoint() {\r\n                _super.apply(this, arguments);\r\n            }\r\n            return TVGPoint;\r\n        })(Point);\r\n        geom.TVGPoint = TVGPoint;\r\n        var VisibilityVertex = (function () {\r\n            function VisibilityVertex(id, polyid, polyvertid, p) {\r\n                this.id = id;\r\n                this.polyid = polyid;\r\n                this.polyvertid = polyvertid;\r\n                this.p = p;\r\n                p.vv = this;\r\n            }\r\n            return VisibilityVertex;\r\n        })();\r\n        geom.VisibilityVertex = VisibilityVertex;\r\n        var VisibilityEdge = (function () {\r\n            function VisibilityEdge(source, target) {\r\n                this.source = source;\r\n                this.target = target;\r\n            }\r\n            VisibilityEdge.prototype.length = function () {\r\n                var dx = this.source.p.x - this.target.p.x;\r\n                var dy = this.source.p.y - this.target.p.y;\r\n                return Math.sqrt(dx * dx + dy * dy);\r\n            };\r\n            return VisibilityEdge;\r\n        })();\r\n        geom.VisibilityEdge = VisibilityEdge;\r\n        var TangentVisibilityGraph = (function () {\r\n            function TangentVisibilityGraph(P, g0) {\r\n                this.P = P;\r\n                this.V = [];\r\n                this.E = [];\r\n                if (!g0) {\r\n                    var n = P.length;\r\n                    for (var i = 0; i < n; i++) {\r\n                        var p = P[i];\r\n                        for (var j = 0; j < p.length; ++j) {\r\n                            var pj = p[j], vv = new VisibilityVertex(this.V.length, i, j, pj);\r\n                            this.V.push(vv);\r\n                            if (j > 0)\r\n                                this.E.push(new VisibilityEdge(p[j - 1].vv, vv));\r\n                        }\r\n                    }\r\n                    for (var i = 0; i < n - 1; i++) {\r\n                        var Pi = P[i];\r\n                        for (var j = i + 1; j < n; j++) {\r\n                            var Pj = P[j], t = geom.tangents(Pi, Pj);\r\n                            for (var q in t) {\r\n                                var c = t[q], source = Pi[c.t1], target = Pj[c.t2];\r\n                                this.addEdgeIfVisible(source, target, i, j);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    this.V = g0.V.slice(0);\r\n                    this.E = g0.E.slice(0);\r\n                }\r\n            }\r\n            TangentVisibilityGraph.prototype.addEdgeIfVisible = function (u, v, i1, i2) {\r\n                if (!this.intersectsPolys(new LineSegment(u.x, u.y, v.x, v.y), i1, i2)) {\r\n                    this.E.push(new VisibilityEdge(u.vv, v.vv));\r\n                }\r\n            };\r\n            TangentVisibilityGraph.prototype.addPoint = function (p, i1) {\r\n                var n = this.P.length;\r\n                this.V.push(new VisibilityVertex(this.V.length, n, 0, p));\r\n                for (var i = 0; i < n; ++i) {\r\n                    if (i === i1)\r\n                        continue;\r\n                    var poly = this.P[i], t = tangent_PointPolyC(p, poly);\r\n                    this.addEdgeIfVisible(p, poly[t.ltan], i1, i);\r\n                    this.addEdgeIfVisible(p, poly[t.rtan], i1, i);\r\n                }\r\n                return p.vv;\r\n            };\r\n            TangentVisibilityGraph.prototype.intersectsPolys = function (l, i1, i2) {\r\n                for (var i = 0, n = this.P.length; i < n; ++i) {\r\n                    if (i != i1 && i != i2 && intersects(l, this.P[i]).length > 0) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            };\r\n            return TangentVisibilityGraph;\r\n        })();\r\n        geom.TangentVisibilityGraph = TangentVisibilityGraph;\r\n        function intersects(l, P) {\r\n            var ints = [];\r\n            for (var i = 1, n = P.length; i < n; ++i) {\r\n                var int = cola.vpsc.Rectangle.lineIntersection(l.x1, l.y1, l.x2, l.y2, P[i - 1].x, P[i - 1].y, P[i].x, P[i].y);\r\n                if (int)\r\n                    ints.push(int);\r\n            }\r\n            return ints;\r\n        }\r\n        function tangents(V, W) {\r\n            var m = V.length - 1, n = W.length - 1;\r\n            var bt = new BiTangents();\r\n            for (var i = 0; i < m; ++i) {\r\n                for (var j = 0; j < n; ++j) {\r\n                    var v1 = V[i == 0 ? m - 1 : i - 1];\r\n                    var v2 = V[i];\r\n                    var v3 = V[i + 1];\r\n                    var w1 = W[j == 0 ? n - 1 : j - 1];\r\n                    var w2 = W[j];\r\n                    var w3 = W[j + 1];\r\n                    var v1v2w2 = isLeft(v1, v2, w2);\r\n                    var v2w1w2 = isLeft(v2, w1, w2);\r\n                    var v2w2w3 = isLeft(v2, w2, w3);\r\n                    var w1w2v2 = isLeft(w1, w2, v2);\r\n                    var w2v1v2 = isLeft(w2, v1, v2);\r\n                    var w2v2v3 = isLeft(w2, v2, v3);\r\n                    if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0\r\n                        && w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {\r\n                        bt.ll = new BiTangent(i, j);\r\n                    }\r\n                    else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0\r\n                        && w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {\r\n                        bt.rr = new BiTangent(i, j);\r\n                    }\r\n                    else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0\r\n                        && w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {\r\n                        bt.rl = new BiTangent(i, j);\r\n                    }\r\n                    else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0\r\n                        && w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {\r\n                        bt.lr = new BiTangent(i, j);\r\n                    }\r\n                }\r\n            }\r\n            return bt;\r\n        }\r\n        geom.tangents = tangents;\r\n        function isPointInsidePoly(p, poly) {\r\n            for (var i = 1, n = poly.length; i < n; ++i)\r\n                if (below(poly[i - 1], poly[i], p))\r\n                    return false;\r\n            return true;\r\n        }\r\n        function isAnyPInQ(p, q) {\r\n            return !p.every(function (v) { return !isPointInsidePoly(v, q); });\r\n        }\r\n        function polysOverlap(p, q) {\r\n            if (isAnyPInQ(p, q))\r\n                return true;\r\n            if (isAnyPInQ(q, p))\r\n                return true;\r\n            for (var i = 1, n = p.length; i < n; ++i) {\r\n                var v = p[i], u = p[i - 1];\r\n                if (intersects(new LineSegment(u.x, u.y, v.x, v.y), q).length > 0)\r\n                    return true;\r\n            }\r\n            return false;\r\n        }\r\n        geom.polysOverlap = polysOverlap;\r\n    })(geom = cola.geom || (cola.geom = {}));\r\n})(cola || (cola = {}));\r\n/**\r\n * @module cola\r\n */\r\nvar cola;\r\n(function (cola) {\r\n    /**\r\n     * Descent respects a collection of locks over nodes that should not move\r\n     * @class Locks\r\n     */\r\n    var Locks = (function () {\r\n        function Locks() {\r\n            this.locks = {};\r\n        }\r\n        /**\r\n         * add a lock on the node at index id\r\n         * @method add\r\n         * @param id index of node to be locked\r\n         * @param x required position for node\r\n         */\r\n        Locks.prototype.add = function (id, x) {\r\n            /* DEBUG\r\n                        if (isNaN(x[0]) || isNaN(x[1])) debugger;\r\n            DEBUG */\r\n            this.locks[id] = x;\r\n        };\r\n        /**\r\n         * @method clear clear all locks\r\n         */\r\n        Locks.prototype.clear = function () {\r\n            this.locks = {};\r\n        };\r\n        /**\r\n         * @isEmpty\r\n         * @returns false if no locks exist\r\n         */\r\n        Locks.prototype.isEmpty = function () {\r\n            for (var l in this.locks)\r\n                return false;\r\n            return true;\r\n        };\r\n        /**\r\n         * perform an operation on each lock\r\n         * @apply\r\n         */\r\n        Locks.prototype.apply = function (f) {\r\n            for (var l in this.locks) {\r\n                f(l, this.locks[l]);\r\n            }\r\n        };\r\n        return Locks;\r\n    })();\r\n    cola.Locks = Locks;\r\n    /**\r\n     * Uses a gradient descent approach to reduce a stress or p-stress goal function over a graph with specified ideal edge lengths or a square matrix of dissimilarities.\r\n     * The standard stress function over a graph nodes with position vectors x,y,z is (mathematica input):\r\n     *   stress[x_,y_,z_,D_,w_]:=Sum[w[[i,j]] (length[x[[i]],y[[i]],z[[i]],x[[j]],y[[j]],z[[j]]]-d[[i,j]])^2,{i,Length[x]-1},{j,i+1,Length[x]}]\r\n     * where: D is a square matrix of ideal separations between nodes, w is matrix of weights for those separations\r\n     *        length[x1_, y1_, z1_, x2_, y2_, z2_] = Sqrt[(x1 - x2)^2 + (y1 - y2)^2 + (z1 - z2)^2]\r\n     * below, we use wij = 1/(Dij^2)\r\n     *\r\n     * @class Descent\r\n     */\r\n    var Descent = (function () {\r\n        /**\r\n         * @method constructor\r\n         * @param x {number[][]} initial coordinates for nodes\r\n         * @param D {number[][]} matrix of desired distances between pairs of nodes\r\n         * @param G {number[][]} [default=null] if specified, G is a matrix of weights for goal terms between pairs of nodes.\r\n         * If G[i][j] > 1 and the separation between nodes i and j is greater than their ideal distance, then there is no contribution for this pair to the goal\r\n         * If G[i][j] <= 1 then it is used as a weighting on the contribution of the variance between ideal and actual separation between i and j to the goal function\r\n         */\r\n        function Descent(x, D, G) {\r\n            if (G === void 0) { G = null; }\r\n            this.D = D;\r\n            this.G = G;\r\n            this.threshold = 0.0001;\r\n            // Parameters for grid snap stress.\r\n            // TODO: Make a pluggable \"StressTerm\" class instead of this\r\n            // mess.\r\n            this.numGridSnapNodes = 0;\r\n            this.snapGridSize = 100;\r\n            this.snapStrength = 1000;\r\n            this.scaleSnapByMaxH = false;\r\n            this.random = new PseudoRandom();\r\n            this.project = null;\r\n            this.x = x;\r\n            this.k = x.length; // dimensionality\r\n            var n = this.n = x[0].length; // number of nodes\r\n            this.H = new Array(this.k);\r\n            this.g = new Array(this.k);\r\n            this.Hd = new Array(this.k);\r\n            this.a = new Array(this.k);\r\n            this.b = new Array(this.k);\r\n            this.c = new Array(this.k);\r\n            this.d = new Array(this.k);\r\n            this.e = new Array(this.k);\r\n            this.ia = new Array(this.k);\r\n            this.ib = new Array(this.k);\r\n            this.xtmp = new Array(this.k);\r\n            this.locks = new Locks();\r\n            this.minD = Number.MAX_VALUE;\r\n            var i = n, j;\r\n            while (i--) {\r\n                j = n;\r\n                while (--j > i) {\r\n                    var d = D[i][j];\r\n                    if (d > 0 && d < this.minD) {\r\n                        this.minD = d;\r\n                    }\r\n                }\r\n            }\r\n            if (this.minD === Number.MAX_VALUE)\r\n                this.minD = 1;\r\n            i = this.k;\r\n            while (i--) {\r\n                this.g[i] = new Array(n);\r\n                this.H[i] = new Array(n);\r\n                j = n;\r\n                while (j--) {\r\n                    this.H[i][j] = new Array(n);\r\n                }\r\n                this.Hd[i] = new Array(n);\r\n                this.a[i] = new Array(n);\r\n                this.b[i] = new Array(n);\r\n                this.c[i] = new Array(n);\r\n                this.d[i] = new Array(n);\r\n                this.e[i] = new Array(n);\r\n                this.ia[i] = new Array(n);\r\n                this.ib[i] = new Array(n);\r\n                this.xtmp[i] = new Array(n);\r\n            }\r\n        }\r\n        Descent.createSquareMatrix = function (n, f) {\r\n            var M = new Array(n);\r\n            for (var i = 0; i < n; ++i) {\r\n                M[i] = new Array(n);\r\n                for (var j = 0; j < n; ++j) {\r\n                    M[i][j] = f(i, j);\r\n                }\r\n            }\r\n            return M;\r\n        };\r\n        Descent.prototype.offsetDir = function () {\r\n            var _this = this;\r\n            var u = new Array(this.k);\r\n            var l = 0;\r\n            for (var i = 0; i < this.k; ++i) {\r\n                var x = u[i] = this.random.getNextBetween(0.01, 1) - 0.5;\r\n                l += x * x;\r\n            }\r\n            l = Math.sqrt(l);\r\n            return u.map(function (x) { return x *= _this.minD / l; });\r\n        };\r\n        // compute first and second derivative information storing results in this.g and this.H\r\n        Descent.prototype.computeDerivatives = function (x) {\r\n            var _this = this;\r\n            var n = this.n;\r\n            if (n < 1)\r\n                return;\r\n            var i;\r\n            /* DEBUG\r\n                        for (var u: number = 0; u < n; ++u)\r\n                            for (i = 0; i < this.k; ++i)\r\n                                if (isNaN(x[i][u])) debugger;\r\n            DEBUG */\r\n            var d = new Array(this.k);\r\n            var d2 = new Array(this.k);\r\n            var Huu = new Array(this.k);\r\n            var maxH = 0;\r\n            for (var u = 0; u < n; ++u) {\r\n                for (i = 0; i < this.k; ++i)\r\n                    Huu[i] = this.g[i][u] = 0;\r\n                for (var v = 0; v < n; ++v) {\r\n                    if (u === v)\r\n                        continue;\r\n                    // The following loop randomly displaces nodes that are at identical positions\r\n                    var maxDisplaces = n; // avoid infinite loop in the case of numerical issues, such as huge values\r\n                    while (maxDisplaces--) {\r\n                        var sd2 = 0;\r\n                        for (i = 0; i < this.k; ++i) {\r\n                            var dx = d[i] = x[i][u] - x[i][v];\r\n                            sd2 += d2[i] = dx * dx;\r\n                        }\r\n                        if (sd2 > 1e-9)\r\n                            break;\r\n                        var rd = this.offsetDir();\r\n                        for (i = 0; i < this.k; ++i)\r\n                            x[i][v] += rd[i];\r\n                    }\r\n                    var l = Math.sqrt(sd2);\r\n                    var D = this.D[u][v];\r\n                    var weight = this.G != null ? this.G[u][v] : 1;\r\n                    if (weight > 1 && l > D || !isFinite(D)) {\r\n                        for (i = 0; i < this.k; ++i)\r\n                            this.H[i][u][v] = 0;\r\n                        continue;\r\n                    }\r\n                    if (weight > 1) {\r\n                        weight = 1;\r\n                    }\r\n                    var D2 = D * D;\r\n                    var gs = 2 * weight * (l - D) / (D2 * l);\r\n                    var l3 = l * l * l;\r\n                    var hs = 2 * -weight / (D2 * l3);\r\n                    if (!isFinite(gs))\r\n                        console.log(gs);\r\n                    for (i = 0; i < this.k; ++i) {\r\n                        this.g[i][u] += d[i] * gs;\r\n                        Huu[i] -= this.H[i][u][v] = hs * (l3 + D * (d2[i] - sd2) + l * sd2);\r\n                    }\r\n                }\r\n                for (i = 0; i < this.k; ++i)\r\n                    maxH = Math.max(maxH, this.H[i][u][u] = Huu[i]);\r\n            }\r\n            // Grid snap forces\r\n            var r = this.snapGridSize / 2;\r\n            var g = this.snapGridSize;\r\n            var w = this.snapStrength;\r\n            var k = w / (r * r);\r\n            var numNodes = this.numGridSnapNodes;\r\n            //var numNodes = n;\r\n            for (var u = 0; u < numNodes; ++u) {\r\n                for (i = 0; i < this.k; ++i) {\r\n                    var xiu = this.x[i][u];\r\n                    var m = xiu / g;\r\n                    var f = m % 1;\r\n                    var q = m - f;\r\n                    var a = Math.abs(f);\r\n                    var dx = (a <= 0.5) ? xiu - q * g :\r\n                        (xiu > 0) ? xiu - (q + 1) * g : xiu - (q - 1) * g;\r\n                    if (-r < dx && dx <= r) {\r\n                        if (this.scaleSnapByMaxH) {\r\n                            this.g[i][u] += maxH * k * dx;\r\n                            this.H[i][u][u] += maxH * k;\r\n                        }\r\n                        else {\r\n                            this.g[i][u] += k * dx;\r\n                            this.H[i][u][u] += k;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!this.locks.isEmpty()) {\r\n                this.locks.apply(function (u, p) {\r\n                    for (i = 0; i < _this.k; ++i) {\r\n                        _this.H[i][u][u] += maxH;\r\n                        _this.g[i][u] -= maxH * (p[i] - x[i][u]);\r\n                    }\r\n                });\r\n            }\r\n            /* DEBUG\r\n                        for (var u: number = 0; u < n; ++u)\r\n                            for (i = 0; i < this.k; ++i) {\r\n                                if (isNaN(this.g[i][u])) debugger;\r\n                                for (var v: number = 0; v < n; ++v)\r\n                                    if (isNaN(this.H[i][u][v])) debugger;\r\n                            }\r\n            DEBUG */\r\n        };\r\n        Descent.dotProd = function (a, b) {\r\n            var x = 0, i = a.length;\r\n            while (i--)\r\n                x += a[i] * b[i];\r\n            return x;\r\n        };\r\n        // result r = matrix m * vector v\r\n        Descent.rightMultiply = function (m, v, r) {\r\n            var i = m.length;\r\n            while (i--)\r\n                r[i] = Descent.dotProd(m[i], v);\r\n        };\r\n        // computes the optimal step size to take in direction d using the\r\n        // derivative information in this.g and this.H\r\n        // returns the scalar multiplier to apply to d to get the optimal step\r\n        Descent.prototype.computeStepSize = function (d) {\r\n            var numerator = 0, denominator = 0;\r\n            for (var i = 0; i < this.k; ++i) {\r\n                numerator += Descent.dotProd(this.g[i], d[i]);\r\n                Descent.rightMultiply(this.H[i], d[i], this.Hd[i]);\r\n                denominator += Descent.dotProd(d[i], this.Hd[i]);\r\n            }\r\n            if (denominator === 0 || !isFinite(denominator))\r\n                return 0;\r\n            return 1 * numerator / denominator;\r\n        };\r\n        Descent.prototype.reduceStress = function () {\r\n            this.computeDerivatives(this.x);\r\n            var alpha = this.computeStepSize(this.g);\r\n            for (var i = 0; i < this.k; ++i) {\r\n                this.takeDescentStep(this.x[i], this.g[i], alpha);\r\n            }\r\n            return this.computeStress();\r\n        };\r\n        Descent.copy = function (a, b) {\r\n            var m = a.length, n = b[0].length;\r\n            for (var i = 0; i < m; ++i) {\r\n                for (var j = 0; j < n; ++j) {\r\n                    b[i][j] = a[i][j];\r\n                }\r\n            }\r\n        };\r\n        // takes a step of stepSize * d from x0, and then project against any constraints.\r\n        // result is returned in r.\r\n        // x0: starting positions\r\n        // r: result positions will be returned here\r\n        // d: unconstrained descent vector\r\n        // stepSize: amount to step along d\r\n        Descent.prototype.stepAndProject = function (x0, r, d, stepSize) {\r\n            Descent.copy(x0, r);\r\n            this.takeDescentStep(r[0], d[0], stepSize);\r\n            if (this.project)\r\n                this.project[0](x0[0], x0[1], r[0]);\r\n            this.takeDescentStep(r[1], d[1], stepSize);\r\n            if (this.project)\r\n                this.project[1](r[0], x0[1], r[1]);\r\n            // todo: allow projection against constraints in higher dimensions\r\n            for (var i = 2; i < this.k; i++)\r\n                this.takeDescentStep(r[i], d[i], stepSize);\r\n            // the following makes locks extra sticky... but hides the result of the projection from the consumer\r\n            //if (!this.locks.isEmpty()) {\r\n            //    this.locks.apply((u, p) => {\r\n            //        for (var i = 0; i < this.k; i++) {\r\n            //            r[i][u] = p[i];\r\n            //        }\r\n            //    });\r\n            //}\r\n        };\r\n        Descent.mApply = function (m, n, f) {\r\n            var i = m;\r\n            while (i-- > 0) {\r\n                var j = n;\r\n                while (j-- > 0)\r\n                    f(i, j);\r\n            }\r\n        };\r\n        Descent.prototype.matrixApply = function (f) {\r\n            Descent.mApply(this.k, this.n, f);\r\n        };\r\n        Descent.prototype.computeNextPosition = function (x0, r) {\r\n            var _this = this;\r\n            this.computeDerivatives(x0);\r\n            var alpha = this.computeStepSize(this.g);\r\n            this.stepAndProject(x0, r, this.g, alpha);\r\n            /* DEBUG\r\n                        for (var u: number = 0; u < this.n; ++u)\r\n                            for (var i = 0; i < this.k; ++i)\r\n                                if (isNaN(r[i][u])) debugger;\r\n            DEBUG */\r\n            if (this.project) {\r\n                this.matrixApply(function (i, j) { return _this.e[i][j] = x0[i][j] - r[i][j]; });\r\n                var beta = this.computeStepSize(this.e);\r\n                beta = Math.max(0.2, Math.min(beta, 1));\r\n                this.stepAndProject(x0, r, this.e, beta);\r\n            }\r\n        };\r\n        Descent.prototype.run = function (iterations) {\r\n            var stress = Number.MAX_VALUE, converged = false;\r\n            while (!converged && iterations-- > 0) {\r\n                var s = this.rungeKutta();\r\n                converged = Math.abs(stress / s - 1) < this.threshold;\r\n                stress = s;\r\n            }\r\n            return stress;\r\n        };\r\n        Descent.prototype.rungeKutta = function () {\r\n            var _this = this;\r\n            this.computeNextPosition(this.x, this.a);\r\n            Descent.mid(this.x, this.a, this.ia);\r\n            this.computeNextPosition(this.ia, this.b);\r\n            Descent.mid(this.x, this.b, this.ib);\r\n            this.computeNextPosition(this.ib, this.c);\r\n            this.computeNextPosition(this.c, this.d);\r\n            var disp = 0;\r\n            this.matrixApply(function (i, j) {\r\n                var x = (_this.a[i][j] + 2.0 * _this.b[i][j] + 2.0 * _this.c[i][j] + _this.d[i][j]) / 6.0, d = _this.x[i][j] - x;\r\n                disp += d * d;\r\n                _this.x[i][j] = x;\r\n            });\r\n            return disp;\r\n        };\r\n        Descent.mid = function (a, b, m) {\r\n            Descent.mApply(a.length, a[0].length, function (i, j) {\r\n                return m[i][j] = a[i][j] + (b[i][j] - a[i][j]) / 2.0;\r\n            });\r\n        };\r\n        Descent.prototype.takeDescentStep = function (x, d, stepSize) {\r\n            for (var i = 0; i < this.n; ++i) {\r\n                x[i] = x[i] - stepSize * d[i];\r\n            }\r\n        };\r\n        Descent.prototype.computeStress = function () {\r\n            var stress = 0;\r\n            for (var u = 0, nMinus1 = this.n - 1; u < nMinus1; ++u) {\r\n                for (var v = u + 1, n = this.n; v < n; ++v) {\r\n                    var l = 0;\r\n                    for (var i = 0; i < this.k; ++i) {\r\n                        var dx = this.x[i][u] - this.x[i][v];\r\n                        l += dx * dx;\r\n                    }\r\n                    l = Math.sqrt(l);\r\n                    var d = this.D[u][v];\r\n                    if (!isFinite(d))\r\n                        continue;\r\n                    var rl = d - l;\r\n                    var d2 = d * d;\r\n                    stress += rl * rl / d2;\r\n                }\r\n            }\r\n            return stress;\r\n        };\r\n        Descent.zeroDistance = 1e-10;\r\n        return Descent;\r\n    })();\r\n    cola.Descent = Descent;\r\n    // Linear congruential pseudo random number generator\r\n    var PseudoRandom = (function () {\r\n        function PseudoRandom(seed) {\r\n            if (seed === void 0) { seed = 1; }\r\n            this.seed = seed;\r\n            this.a = 214013;\r\n            this.c = 2531011;\r\n            this.m = 2147483648;\r\n            this.range = 32767;\r\n        }\r\n        // random real between 0 and 1\r\n        PseudoRandom.prototype.getNext = function () {\r\n            this.seed = (this.seed * this.a + this.c) % this.m;\r\n            return (this.seed >> 16) / this.range;\r\n        };\r\n        // random real between min and max\r\n        PseudoRandom.prototype.getNextBetween = function (min, max) {\r\n            return min + this.getNext() * (max - min);\r\n        };\r\n        return PseudoRandom;\r\n    })();\r\n    cola.PseudoRandom = PseudoRandom;\r\n})(cola || (cola = {}));\r\nvar cola;\r\n(function (cola) {\r\n    var powergraph;\r\n    (function (powergraph) {\r\n        var PowerEdge = (function () {\r\n            function PowerEdge(source, target, type) {\r\n                this.source = source;\r\n                this.target = target;\r\n                this.type = type;\r\n            }\r\n            return PowerEdge;\r\n        })();\r\n        powergraph.PowerEdge = PowerEdge;\r\n        var Configuration = (function () {\r\n            function Configuration(n, edges, linkAccessor, rootGroup) {\r\n                var _this = this;\r\n                this.linkAccessor = linkAccessor;\r\n                this.modules = new Array(n);\r\n                this.roots = [];\r\n                if (rootGroup) {\r\n                    this.initModulesFromGroup(rootGroup);\r\n                }\r\n                else {\r\n                    this.roots.push(new ModuleSet());\r\n                    for (var i = 0; i < n; ++i)\r\n                        this.roots[0].add(this.modules[i] = new Module(i));\r\n                }\r\n                this.R = edges.length;\r\n                edges.forEach(function (e) {\r\n                    var s = _this.modules[linkAccessor.getSourceIndex(e)], t = _this.modules[linkAccessor.getTargetIndex(e)], type = linkAccessor.getType(e);\r\n                    s.outgoing.add(type, t);\r\n                    t.incoming.add(type, s);\r\n                });\r\n            }\r\n            Configuration.prototype.initModulesFromGroup = function (group) {\r\n                var moduleSet = new ModuleSet();\r\n                this.roots.push(moduleSet);\r\n                for (var i = 0; i < group.leaves.length; ++i) {\r\n                    var node = group.leaves[i];\r\n                    var module = new Module(node.id);\r\n                    this.modules[node.id] = module;\r\n                    moduleSet.add(module);\r\n                }\r\n                if (group.groups) {\r\n                    for (var j = 0; j < group.groups.length; ++j) {\r\n                        var child = group.groups[j];\r\n                        // Propagate group properties (like padding, stiffness, ...) as module definition so that the generated power graph group will inherit it\r\n                        var definition = {};\r\n                        for (var prop in child)\r\n                            if (prop !== \"leaves\" && prop !== \"groups\" && child.hasOwnProperty(prop))\r\n                                definition[prop] = child[prop];\r\n                        // Use negative module id to avoid clashes between predefined and generated modules\r\n                        moduleSet.add(new Module(-1 - j, new LinkSets(), new LinkSets(), this.initModulesFromGroup(child), definition));\r\n                    }\r\n                }\r\n                return moduleSet;\r\n            };\r\n            // merge modules a and b keeping track of their power edges and removing the from roots\r\n            Configuration.prototype.merge = function (a, b, k) {\r\n                if (k === void 0) { k = 0; }\r\n                var inInt = a.incoming.intersection(b.incoming), outInt = a.outgoing.intersection(b.outgoing);\r\n                var children = new ModuleSet();\r\n                children.add(a);\r\n                children.add(b);\r\n                var m = new Module(this.modules.length, outInt, inInt, children);\r\n                this.modules.push(m);\r\n                var update = function (s, i, o) {\r\n                    s.forAll(function (ms, linktype) {\r\n                        ms.forAll(function (n) {\r\n                            var nls = n[i];\r\n                            nls.add(linktype, m);\r\n                            nls.remove(linktype, a);\r\n                            nls.remove(linktype, b);\r\n                            a[o].remove(linktype, n);\r\n                            b[o].remove(linktype, n);\r\n                        });\r\n                    });\r\n                };\r\n                update(outInt, \"incoming\", \"outgoing\");\r\n                update(inInt, \"outgoing\", \"incoming\");\r\n                this.R -= inInt.count() + outInt.count();\r\n                this.roots[k].remove(a);\r\n                this.roots[k].remove(b);\r\n                this.roots[k].add(m);\r\n                return m;\r\n            };\r\n            Configuration.prototype.rootMerges = function (k) {\r\n                if (k === void 0) { k = 0; }\r\n                var rs = this.roots[k].modules();\r\n                var n = rs.length;\r\n                var merges = new Array(n * (n - 1));\r\n                var ctr = 0;\r\n                for (var i = 0, i_ = n - 1; i < i_; ++i) {\r\n                    for (var j = i + 1; j < n; ++j) {\r\n                        var a = rs[i], b = rs[j];\r\n                        merges[ctr] = { id: ctr, nEdges: this.nEdges(a, b), a: a, b: b };\r\n                        ctr++;\r\n                    }\r\n                }\r\n                return merges;\r\n            };\r\n            Configuration.prototype.greedyMerge = function () {\r\n                for (var i = 0; i < this.roots.length; ++i) {\r\n                    // Handle single nested module case\r\n                    if (this.roots[i].modules().length < 2)\r\n                        continue;\r\n                    // find the merge that allows for the most edges to be removed.  secondary ordering based on arbitrary id (for predictability)\r\n                    var ms = this.rootMerges(i).sort(function (a, b) { return a.nEdges == b.nEdges ? a.id - b.id : a.nEdges - b.nEdges; });\r\n                    var m = ms[0];\r\n                    if (m.nEdges >= this.R)\r\n                        continue;\r\n                    this.merge(m.a, m.b, i);\r\n                    return true;\r\n                }\r\n            };\r\n            Configuration.prototype.nEdges = function (a, b) {\r\n                var inInt = a.incoming.intersection(b.incoming), outInt = a.outgoing.intersection(b.outgoing);\r\n                return this.R - inInt.count() - outInt.count();\r\n            };\r\n            Configuration.prototype.getGroupHierarchy = function (retargetedEdges) {\r\n                var _this = this;\r\n                var groups = [];\r\n                var root = {};\r\n                toGroups(this.roots[0], root, groups);\r\n                var es = this.allEdges();\r\n                es.forEach(function (e) {\r\n                    var a = _this.modules[e.source];\r\n                    var b = _this.modules[e.target];\r\n                    retargetedEdges.push(new PowerEdge(typeof a.gid === \"undefined\" ? e.source : groups[a.gid], typeof b.gid === \"undefined\" ? e.target : groups[b.gid], e.type));\r\n                });\r\n                return groups;\r\n            };\r\n            Configuration.prototype.allEdges = function () {\r\n                var es = [];\r\n                Configuration.getEdges(this.roots[0], es);\r\n                return es;\r\n            };\r\n            Configuration.getEdges = function (modules, es) {\r\n                modules.forAll(function (m) {\r\n                    m.getEdges(es);\r\n                    Configuration.getEdges(m.children, es);\r\n                });\r\n            };\r\n            return Configuration;\r\n        })();\r\n        powergraph.Configuration = Configuration;\r\n        function toGroups(modules, group, groups) {\r\n            modules.forAll(function (m) {\r\n                if (m.isLeaf()) {\r\n                    if (!group.leaves)\r\n                        group.leaves = [];\r\n                    group.leaves.push(m.id);\r\n                }\r\n                else {\r\n                    var g = group;\r\n                    m.gid = groups.length;\r\n                    if (!m.isIsland() || m.isPredefined()) {\r\n                        g = { id: m.gid };\r\n                        if (m.isPredefined())\r\n                            // Apply original group properties\r\n                            for (var prop in m.definition)\r\n                                g[prop] = m.definition[prop];\r\n                        if (!group.groups)\r\n                            group.groups = [];\r\n                        group.groups.push(m.gid);\r\n                        groups.push(g);\r\n                    }\r\n                    toGroups(m.children, g, groups);\r\n                }\r\n            });\r\n        }\r\n        var Module = (function () {\r\n            function Module(id, outgoing, incoming, children, definition) {\r\n                if (outgoing === void 0) { outgoing = new LinkSets(); }\r\n                if (incoming === void 0) { incoming = new LinkSets(); }\r\n                if (children === void 0) { children = new ModuleSet(); }\r\n                this.id = id;\r\n                this.outgoing = outgoing;\r\n                this.incoming = incoming;\r\n                this.children = children;\r\n                this.definition = definition;\r\n            }\r\n            Module.prototype.getEdges = function (es) {\r\n                var _this = this;\r\n                this.outgoing.forAll(function (ms, edgetype) {\r\n                    ms.forAll(function (target) {\r\n                        es.push(new PowerEdge(_this.id, target.id, edgetype));\r\n                    });\r\n                });\r\n            };\r\n            Module.prototype.isLeaf = function () {\r\n                return this.children.count() === 0;\r\n            };\r\n            Module.prototype.isIsland = function () {\r\n                return this.outgoing.count() === 0 && this.incoming.count() === 0;\r\n            };\r\n            Module.prototype.isPredefined = function () {\r\n                return typeof this.definition !== \"undefined\";\r\n            };\r\n            return Module;\r\n        })();\r\n        powergraph.Module = Module;\r\n        function intersection(m, n) {\r\n            var i = {};\r\n            for (var v in m)\r\n                if (v in n)\r\n                    i[v] = m[v];\r\n            return i;\r\n        }\r\n        var ModuleSet = (function () {\r\n            function ModuleSet() {\r\n                this.table = {};\r\n            }\r\n            ModuleSet.prototype.count = function () {\r\n                return Object.keys(this.table).length;\r\n            };\r\n            ModuleSet.prototype.intersection = function (other) {\r\n                var result = new ModuleSet();\r\n                result.table = intersection(this.table, other.table);\r\n                return result;\r\n            };\r\n            ModuleSet.prototype.intersectionCount = function (other) {\r\n                return this.intersection(other).count();\r\n            };\r\n            ModuleSet.prototype.contains = function (id) {\r\n                return id in this.table;\r\n            };\r\n            ModuleSet.prototype.add = function (m) {\r\n                this.table[m.id] = m;\r\n            };\r\n            ModuleSet.prototype.remove = function (m) {\r\n                delete this.table[m.id];\r\n            };\r\n            ModuleSet.prototype.forAll = function (f) {\r\n                for (var mid in this.table) {\r\n                    f(this.table[mid]);\r\n                }\r\n            };\r\n            ModuleSet.prototype.modules = function () {\r\n                var vs = [];\r\n                this.forAll(function (m) {\r\n                    if (!m.isPredefined())\r\n                        vs.push(m);\r\n                });\r\n                return vs;\r\n            };\r\n            return ModuleSet;\r\n        })();\r\n        powergraph.ModuleSet = ModuleSet;\r\n        var LinkSets = (function () {\r\n            function LinkSets() {\r\n                this.sets = {};\r\n                this.n = 0;\r\n            }\r\n            LinkSets.prototype.count = function () {\r\n                return this.n;\r\n            };\r\n            LinkSets.prototype.contains = function (id) {\r\n                var result = false;\r\n                this.forAllModules(function (m) {\r\n                    if (!result && m.id == id) {\r\n                        result = true;\r\n                    }\r\n                });\r\n                return result;\r\n            };\r\n            LinkSets.prototype.add = function (linktype, m) {\r\n                var s = linktype in this.sets ? this.sets[linktype] : this.sets[linktype] = new ModuleSet();\r\n                s.add(m);\r\n                ++this.n;\r\n            };\r\n            LinkSets.prototype.remove = function (linktype, m) {\r\n                var ms = this.sets[linktype];\r\n                ms.remove(m);\r\n                if (ms.count() === 0) {\r\n                    delete this.sets[linktype];\r\n                }\r\n                --this.n;\r\n            };\r\n            LinkSets.prototype.forAll = function (f) {\r\n                for (var linktype in this.sets) {\r\n                    f(this.sets[linktype], linktype);\r\n                }\r\n            };\r\n            LinkSets.prototype.forAllModules = function (f) {\r\n                this.forAll(function (ms, lt) { return ms.forAll(f); });\r\n            };\r\n            LinkSets.prototype.intersection = function (other) {\r\n                var result = new LinkSets();\r\n                this.forAll(function (ms, lt) {\r\n                    if (lt in other.sets) {\r\n                        var i = ms.intersection(other.sets[lt]), n = i.count();\r\n                        if (n > 0) {\r\n                            result.sets[lt] = i;\r\n                            result.n += n;\r\n                        }\r\n                    }\r\n                });\r\n                return result;\r\n            };\r\n            return LinkSets;\r\n        })();\r\n        powergraph.LinkSets = LinkSets;\r\n        function intersectionCount(m, n) {\r\n            return Object.keys(intersection(m, n)).length;\r\n        }\r\n        function getGroups(nodes, links, la, rootGroup) {\r\n            var n = nodes.length, c = new powergraph.Configuration(n, links, la, rootGroup);\r\n            while (c.greedyMerge())\r\n                ;\r\n            var powerEdges = [];\r\n            var g = c.getGroupHierarchy(powerEdges);\r\n            powerEdges.forEach(function (e) {\r\n                var f = function (end) {\r\n                    var g = e[end];\r\n                    if (typeof g == \"number\")\r\n                        e[end] = nodes[g];\r\n                };\r\n                f(\"source\");\r\n                f(\"target\");\r\n            });\r\n            return { groups: g, powerEdges: powerEdges };\r\n        }\r\n        powergraph.getGroups = getGroups;\r\n    })(powergraph = cola.powergraph || (cola.powergraph = {}));\r\n})(cola || (cola = {}));\r\n/**\r\n * @module cola\r\n */\r\nvar cola;\r\n(function (cola) {\r\n    // compute the size of the union of two sets a and b\r\n    function unionCount(a, b) {\r\n        var u = {};\r\n        for (var i in a)\r\n            u[i] = {};\r\n        for (var i in b)\r\n            u[i] = {};\r\n        return Object.keys(u).length;\r\n    }\r\n    // compute the size of the intersection of two sets a and b\r\n    function intersectionCount(a, b) {\r\n        var n = 0;\r\n        for (var i in a)\r\n            if (typeof b[i] !== 'undefined')\r\n                ++n;\r\n        return n;\r\n    }\r\n    function getNeighbours(links, la) {\r\n        var neighbours = {};\r\n        var addNeighbours = function (u, v) {\r\n            if (typeof neighbours[u] === 'undefined')\r\n                neighbours[u] = {};\r\n            neighbours[u][v] = {};\r\n        };\r\n        links.forEach(function (e) {\r\n            var u = la.getSourceIndex(e), v = la.getTargetIndex(e);\r\n            addNeighbours(u, v);\r\n            addNeighbours(v, u);\r\n        });\r\n        return neighbours;\r\n    }\r\n    // modify the lengths of the specified links by the result of function f weighted by w\r\n    function computeLinkLengths(links, w, f, la) {\r\n        var neighbours = getNeighbours(links, la);\r\n        links.forEach(function (l) {\r\n            var a = neighbours[la.getSourceIndex(l)];\r\n            var b = neighbours[la.getTargetIndex(l)];\r\n            la.setLength(l, 1 + w * f(a, b));\r\n        });\r\n    }\r\n    /** modify the specified link lengths based on the symmetric difference of their neighbours\r\n     * @class symmetricDiffLinkLengths\r\n     */\r\n    function symmetricDiffLinkLengths(links, la, w) {\r\n        if (w === void 0) { w = 1; }\r\n        computeLinkLengths(links, w, function (a, b) { return Math.sqrt(unionCount(a, b) - intersectionCount(a, b)); }, la);\r\n    }\r\n    cola.symmetricDiffLinkLengths = symmetricDiffLinkLengths;\r\n    /** modify the specified links lengths based on the jaccard difference between their neighbours\r\n     * @class jaccardLinkLengths\r\n     */\r\n    function jaccardLinkLengths(links, la, w) {\r\n        if (w === void 0) { w = 1; }\r\n        computeLinkLengths(links, w, function (a, b) {\r\n            return Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b);\r\n        }, la);\r\n    }\r\n    cola.jaccardLinkLengths = jaccardLinkLengths;\r\n    /** generate separation constraints for all edges unless both their source and sink are in the same strongly connected component\r\n     * @class generateDirectedEdgeConstraints\r\n     */\r\n    function generateDirectedEdgeConstraints(n, links, axis, la) {\r\n        var components = stronglyConnectedComponents(n, links, la);\r\n        var nodes = {};\r\n        components.forEach(function (c, i) {\r\n            return c.forEach(function (v) { return nodes[v] = i; });\r\n        });\r\n        var constraints = [];\r\n        links.forEach(function (l) {\r\n            var ui = la.getSourceIndex(l), vi = la.getTargetIndex(l), u = nodes[ui], v = nodes[vi];\r\n            if (u !== v) {\r\n                constraints.push({\r\n                    axis: axis,\r\n                    left: ui,\r\n                    right: vi,\r\n                    gap: la.getMinSeparation(l)\r\n                });\r\n            }\r\n        });\r\n        return constraints;\r\n    }\r\n    cola.generateDirectedEdgeConstraints = generateDirectedEdgeConstraints;\r\n    /**\r\n     * Tarjan's strongly connected components algorithm for directed graphs\r\n     * returns an array of arrays of node indicies in each of the strongly connected components.\r\n     * a vertex not in a SCC of two or more nodes is it's own SCC.\r\n     * adaptation of https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\r\n     */\r\n    function stronglyConnectedComponents(numVertices, edges, la) {\r\n        var nodes = [];\r\n        var index = 0;\r\n        var stack = [];\r\n        var components = [];\r\n        function strongConnect(v) {\r\n            // Set the depth index for v to the smallest unused index\r\n            v.index = v.lowlink = index++;\r\n            stack.push(v);\r\n            v.onStack = true;\r\n            // Consider successors of v\r\n            for (var _i = 0, _a = v.out; _i < _a.length; _i++) {\r\n                var w = _a[_i];\r\n                if (typeof w.index === 'undefined') {\r\n                    // Successor w has not yet been visited; recurse on it\r\n                    strongConnect(w);\r\n                    v.lowlink = Math.min(v.lowlink, w.lowlink);\r\n                }\r\n                else if (w.onStack) {\r\n                    // Successor w is in stack S and hence in the current SCC\r\n                    v.lowlink = Math.min(v.lowlink, w.index);\r\n                }\r\n            }\r\n            // If v is a root node, pop the stack and generate an SCC\r\n            if (v.lowlink === v.index) {\r\n                // start a new strongly connected component\r\n                var component = [];\r\n                while (stack.length) {\r\n                    w = stack.pop();\r\n                    w.onStack = false;\r\n                    //add w to current strongly connected component\r\n                    component.push(w);\r\n                    if (w === v)\r\n                        break;\r\n                }\r\n                // output the current strongly connected component\r\n                components.push(component.map(function (v) { return v.id; }));\r\n            }\r\n        }\r\n        for (var i = 0; i < numVertices; i++) {\r\n            nodes.push({ id: i, out: [] });\r\n        }\r\n        for (var _i = 0; _i < edges.length; _i++) {\r\n            var e = edges[_i];\r\n            var v_1 = nodes[la.getSourceIndex(e)], w = nodes[la.getTargetIndex(e)];\r\n            v_1.out.push(w);\r\n        }\r\n        for (var _a = 0; _a < nodes.length; _a++) {\r\n            var v = nodes[_a];\r\n            if (typeof v.index === 'undefined')\r\n                strongConnect(v);\r\n        }\r\n        return components;\r\n    }\r\n    cola.stronglyConnectedComponents = stronglyConnectedComponents;\r\n})(cola || (cola = {}));\r\nvar PairingHeap = (function () {\r\n    // from: https://gist.github.com/nervoussystem\r\n    //{elem:object, subheaps:[array of heaps]}\r\n    function PairingHeap(elem) {\r\n        this.elem = elem;\r\n        this.subheaps = [];\r\n    }\r\n    PairingHeap.prototype.toString = function (selector) {\r\n        var str = \"\", needComma = false;\r\n        for (var i = 0; i < this.subheaps.length; ++i) {\r\n            var subheap = this.subheaps[i];\r\n            if (!subheap.elem) {\r\n                needComma = false;\r\n                continue;\r\n            }\r\n            if (needComma) {\r\n                str = str + \",\";\r\n            }\r\n            str = str + subheap.toString(selector);\r\n            needComma = true;\r\n        }\r\n        if (str !== \"\") {\r\n            str = \"(\" + str + \")\";\r\n        }\r\n        return (this.elem ? selector(this.elem) : \"\") + str;\r\n    };\r\n    PairingHeap.prototype.forEach = function (f) {\r\n        if (!this.empty()) {\r\n            f(this.elem, this);\r\n            this.subheaps.forEach(function (s) { return s.forEach(f); });\r\n        }\r\n    };\r\n    PairingHeap.prototype.count = function () {\r\n        return this.empty() ? 0 : 1 + this.subheaps.reduce(function (n, h) {\r\n            return n + h.count();\r\n        }, 0);\r\n    };\r\n    PairingHeap.prototype.min = function () {\r\n        return this.elem;\r\n    };\r\n    PairingHeap.prototype.empty = function () {\r\n        return this.elem == null;\r\n    };\r\n    PairingHeap.prototype.contains = function (h) {\r\n        if (this === h)\r\n            return true;\r\n        for (var i = 0; i < this.subheaps.length; i++) {\r\n            if (this.subheaps[i].contains(h))\r\n                return true;\r\n        }\r\n        return false;\r\n    };\r\n    PairingHeap.prototype.isHeap = function (lessThan) {\r\n        var _this = this;\r\n        return this.subheaps.every(function (h) { return lessThan(_this.elem, h.elem) && h.isHeap(lessThan); });\r\n    };\r\n    PairingHeap.prototype.insert = function (obj, lessThan) {\r\n        return this.merge(new PairingHeap(obj), lessThan);\r\n    };\r\n    PairingHeap.prototype.merge = function (heap2, lessThan) {\r\n        if (this.empty())\r\n            return heap2;\r\n        else if (heap2.empty())\r\n            return this;\r\n        else if (lessThan(this.elem, heap2.elem)) {\r\n            this.subheaps.push(heap2);\r\n            return this;\r\n        }\r\n        else {\r\n            heap2.subheaps.push(this);\r\n            return heap2;\r\n        }\r\n    };\r\n    PairingHeap.prototype.removeMin = function (lessThan) {\r\n        if (this.empty())\r\n            return null;\r\n        else\r\n            return this.mergePairs(lessThan);\r\n    };\r\n    PairingHeap.prototype.mergePairs = function (lessThan) {\r\n        if (this.subheaps.length == 0)\r\n            return new PairingHeap(null);\r\n        else if (this.subheaps.length == 1) {\r\n            return this.subheaps[0];\r\n        }\r\n        else {\r\n            var firstPair = this.subheaps.pop().merge(this.subheaps.pop(), lessThan);\r\n            var remaining = this.mergePairs(lessThan);\r\n            return firstPair.merge(remaining, lessThan);\r\n        }\r\n    };\r\n    PairingHeap.prototype.decreaseKey = function (subheap, newValue, setHeapNode, lessThan) {\r\n        var newHeap = subheap.removeMin(lessThan);\r\n        //reassign subheap values to preserve tree\r\n        subheap.elem = newHeap.elem;\r\n        subheap.subheaps = newHeap.subheaps;\r\n        if (setHeapNode !== null && newHeap.elem !== null) {\r\n            setHeapNode(subheap.elem, subheap);\r\n        }\r\n        var pairingNode = new PairingHeap(newValue);\r\n        if (setHeapNode !== null) {\r\n            setHeapNode(newValue, pairingNode);\r\n        }\r\n        return this.merge(pairingNode, lessThan);\r\n    };\r\n    return PairingHeap;\r\n})();\r\n/**\r\n * @class PriorityQueue a min priority queue backed by a pairing heap\r\n */\r\nvar PriorityQueue = (function () {\r\n    function PriorityQueue(lessThan) {\r\n        this.lessThan = lessThan;\r\n    }\r\n    /**\r\n     * @method top\r\n     * @return the top element (the min element as defined by lessThan)\r\n     */\r\n    PriorityQueue.prototype.top = function () {\r\n        if (this.empty()) {\r\n            return null;\r\n        }\r\n        return this.root.elem;\r\n    };\r\n    /**\r\n     * @method push\r\n     * put things on the heap\r\n     */\r\n    PriorityQueue.prototype.push = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i - 0] = arguments[_i];\r\n        }\r\n        var pairingNode;\r\n        for (var i = 0, arg; arg = args[i]; ++i) {\r\n            pairingNode = new PairingHeap(arg);\r\n            this.root = this.empty() ?\r\n                pairingNode : this.root.merge(pairingNode, this.lessThan);\r\n        }\r\n        return pairingNode;\r\n    };\r\n    /**\r\n     * @method empty\r\n     * @return true if no more elements in queue\r\n     */\r\n    PriorityQueue.prototype.empty = function () {\r\n        return !this.root || !this.root.elem;\r\n    };\r\n    /**\r\n     * @method isHeap check heap condition (for testing)\r\n     * @return true if queue is in valid state\r\n     */\r\n    PriorityQueue.prototype.isHeap = function () {\r\n        return this.root.isHeap(this.lessThan);\r\n    };\r\n    /**\r\n     * @method forEach apply f to each element of the queue\r\n     * @param f function to apply\r\n     */\r\n    PriorityQueue.prototype.forEach = function (f) {\r\n        this.root.forEach(f);\r\n    };\r\n    /**\r\n     * @method pop remove and return the min element from the queue\r\n     */\r\n    PriorityQueue.prototype.pop = function () {\r\n        if (this.empty()) {\r\n            return null;\r\n        }\r\n        var obj = this.root.min();\r\n        this.root = this.root.removeMin(this.lessThan);\r\n        return obj;\r\n    };\r\n    /**\r\n     * @method reduceKey reduce the key value of the specified heap node\r\n     */\r\n    PriorityQueue.prototype.reduceKey = function (heapNode, newKey, setHeapNode) {\r\n        if (setHeapNode === void 0) { setHeapNode = null; }\r\n        this.root = this.root.decreaseKey(heapNode, newKey, setHeapNode, this.lessThan);\r\n    };\r\n    PriorityQueue.prototype.toString = function (selector) {\r\n        return this.root.toString(selector);\r\n    };\r\n    /**\r\n     * @method count\r\n     * @return number of elements in queue\r\n     */\r\n    PriorityQueue.prototype.count = function () {\r\n        return this.root.count();\r\n    };\r\n    return PriorityQueue;\r\n})();\r\n///<reference path=\"pqueue.ts\"/>\r\n/**\r\n * @module shortestpaths\r\n */\r\nvar cola;\r\n(function (cola) {\r\n    var shortestpaths;\r\n    (function (shortestpaths) {\r\n        var Neighbour = (function () {\r\n            function Neighbour(id, distance) {\r\n                this.id = id;\r\n                this.distance = distance;\r\n            }\r\n            return Neighbour;\r\n        })();\r\n        var Node = (function () {\r\n            function Node(id) {\r\n                this.id = id;\r\n                this.neighbours = [];\r\n            }\r\n            return Node;\r\n        })();\r\n        var QueueEntry = (function () {\r\n            function QueueEntry(node, prev, d) {\r\n                this.node = node;\r\n                this.prev = prev;\r\n                this.d = d;\r\n            }\r\n            return QueueEntry;\r\n        })();\r\n        /**\r\n         * calculates all-pairs shortest paths or shortest paths from a single node\r\n         * @class Calculator\r\n         * @constructor\r\n         * @param n {number} number of nodes\r\n         * @param es {Edge[]} array of edges\r\n         */\r\n        var Calculator = (function () {\r\n            function Calculator(n, es, getSourceIndex, getTargetIndex, getLength) {\r\n                this.n = n;\r\n                this.es = es;\r\n                this.neighbours = new Array(this.n);\r\n                var i = this.n;\r\n                while (i--)\r\n                    this.neighbours[i] = new Node(i);\r\n                i = this.es.length;\r\n                while (i--) {\r\n                    var e = this.es[i];\r\n                    var u = getSourceIndex(e), v = getTargetIndex(e);\r\n                    var d = getLength(e);\r\n                    this.neighbours[u].neighbours.push(new Neighbour(v, d));\r\n                    this.neighbours[v].neighbours.push(new Neighbour(u, d));\r\n                }\r\n            }\r\n            /**\r\n             * compute shortest paths for graph over n nodes with edges an array of source/target pairs\r\n             * edges may optionally have a length attribute.  1 is the default.\r\n             * Uses Johnson's algorithm.\r\n             *\r\n             * @method DistanceMatrix\r\n             * @return the distance matrix\r\n             */\r\n            Calculator.prototype.DistanceMatrix = function () {\r\n                var D = new Array(this.n);\r\n                for (var i = 0; i < this.n; ++i) {\r\n                    D[i] = this.dijkstraNeighbours(i);\r\n                }\r\n                return D;\r\n            };\r\n            /**\r\n             * get shortest paths from a specified start node\r\n             * @method DistancesFromNode\r\n             * @param start node index\r\n             * @return array of path lengths\r\n             */\r\n            Calculator.prototype.DistancesFromNode = function (start) {\r\n                return this.dijkstraNeighbours(start);\r\n            };\r\n            Calculator.prototype.PathFromNodeToNode = function (start, end) {\r\n                return this.dijkstraNeighbours(start, end);\r\n            };\r\n            // find shortest path from start to end, with the opportunity at \r\n            // each edge traversal to compute a custom cost based on the \r\n            // previous edge.  For example, to penalise bends.\r\n            Calculator.prototype.PathFromNodeToNodeWithPrevCost = function (start, end, prevCost) {\r\n                var q = new PriorityQueue(function (a, b) { return a.d <= b.d; }), u = this.neighbours[start], qu = new QueueEntry(u, null, 0), visitedFrom = {};\r\n                q.push(qu);\r\n                while (!q.empty()) {\r\n                    qu = q.pop();\r\n                    u = qu.node;\r\n                    if (u.id === end) {\r\n                        break;\r\n                    }\r\n                    var i = u.neighbours.length;\r\n                    while (i--) {\r\n                        var neighbour = u.neighbours[i], v = this.neighbours[neighbour.id];\r\n                        // don't double back\r\n                        if (qu.prev && v.id === qu.prev.node.id)\r\n                            continue;\r\n                        // don't retraverse an edge if it has already been explored\r\n                        // from a lower cost route\r\n                        var viduid = v.id + ',' + u.id;\r\n                        if (viduid in visitedFrom && visitedFrom[viduid] <= qu.d)\r\n                            continue;\r\n                        var cc = qu.prev ? prevCost(qu.prev.node.id, u.id, v.id) : 0, t = qu.d + neighbour.distance + cc;\r\n                        // store cost of this traversal\r\n                        visitedFrom[viduid] = t;\r\n                        q.push(new QueueEntry(v, qu, t));\r\n                    }\r\n                }\r\n                var path = [];\r\n                while (qu.prev) {\r\n                    qu = qu.prev;\r\n                    path.push(qu.node.id);\r\n                }\r\n                return path;\r\n            };\r\n            Calculator.prototype.dijkstraNeighbours = function (start, dest) {\r\n                if (dest === void 0) { dest = -1; }\r\n                var q = new PriorityQueue(function (a, b) { return a.d <= b.d; }), i = this.neighbours.length, d = new Array(i);\r\n                while (i--) {\r\n                    var node = this.neighbours[i];\r\n                    node.d = i === start ? 0 : Number.POSITIVE_INFINITY;\r\n                    node.q = q.push(node);\r\n                }\r\n                while (!q.empty()) {\r\n                    // console.log(q.toString(function (u) { return u.id + \"=\" + (u.d === Number.POSITIVE_INFINITY ? \"\\u221E\" : u.d.toFixed(2) )}));\r\n                    var u = q.pop();\r\n                    d[u.id] = u.d;\r\n                    if (u.id === dest) {\r\n                        var path = [];\r\n                        var v = u;\r\n                        while (typeof v.prev !== 'undefined') {\r\n                            path.push(v.prev.id);\r\n                            v = v.prev;\r\n                        }\r\n                        return path;\r\n                    }\r\n                    i = u.neighbours.length;\r\n                    while (i--) {\r\n                        var neighbour = u.neighbours[i];\r\n                        var v = this.neighbours[neighbour.id];\r\n                        var t = u.d + neighbour.distance;\r\n                        if (u.d !== Number.MAX_VALUE && v.d > t) {\r\n                            v.d = t;\r\n                            v.prev = u;\r\n                            q.reduceKey(v.q, v, function (e, q) { return e.q = q; });\r\n                        }\r\n                    }\r\n                }\r\n                return d;\r\n            };\r\n            return Calculator;\r\n        })();\r\n        shortestpaths.Calculator = Calculator;\r\n    })(shortestpaths = cola.shortestpaths || (cola.shortestpaths = {}));\r\n})(cola || (cola = {}));\r\n///<reference path=\"handledisconnected.ts\"/>\r\n///<reference path=\"geom.ts\"/>\r\n///<reference path=\"descent.ts\"/>\r\n///<reference path=\"powergraph.ts\"/>\r\n///<reference path=\"linklengths.ts\"/>\r\n///<reference path=\"shortestpaths.ts\"/>\r\n/**\r\n * @module cola\r\n */\r\nvar cola;\r\n(function (cola) {\r\n    /**\r\n     * The layout process fires three events:\r\n     *  - start: layout iterations started\r\n     *  - tick: fired once per iteration, listen to this to animate\r\n     *  - end: layout converged, you might like to zoom-to-fit or something at notification of this event\r\n     */\r\n    (function (EventType) {\r\n        EventType[EventType[\"start\"] = 0] = \"start\";\r\n        EventType[EventType[\"tick\"] = 1] = \"tick\";\r\n        EventType[EventType[\"end\"] = 2] = \"end\";\r\n    })(cola.EventType || (cola.EventType = {}));\r\n    var EventType = cola.EventType;\r\n    ;\r\n    function isGroup(g) {\r\n        return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';\r\n    }\r\n    /**\r\n     * Main interface to cola layout.\r\n     * @class Layout\r\n     */\r\n    var Layout = (function () {\r\n        function Layout() {\r\n            var _this = this;\r\n            this._canvasSize = [1, 1];\r\n            this._linkDistance = 20;\r\n            this._defaultNodeSize = 10;\r\n            this._linkLengthCalculator = null;\r\n            this._linkType = null;\r\n            this._avoidOverlaps = false;\r\n            this._handleDisconnected = true;\r\n            this._running = false;\r\n            this._nodes = [];\r\n            this._groups = [];\r\n            this._rootGroup = null;\r\n            this._links = [];\r\n            this._constraints = [];\r\n            this._distanceMatrix = null;\r\n            this._descent = null;\r\n            this._directedLinkConstraints = null;\r\n            this._threshold = 0.01;\r\n            this._visibilityGraph = null;\r\n            this._groupCompactness = 1e-6;\r\n            // sub-class and override this property to replace with a more sophisticated eventing mechanism\r\n            this.event = null;\r\n            this.linkAccessor = {\r\n                getSourceIndex: Layout.getSourceIndex,\r\n                getTargetIndex: Layout.getTargetIndex,\r\n                setLength: Layout.setLinkLength,\r\n                getType: function (l) { return typeof _this._linkType === \"function\" ? _this._linkType(l) : 0; }\r\n            };\r\n        }\r\n        // subscribe a listener to an event\r\n        // sub-class and override this method to replace with a more sophisticated eventing mechanism\r\n        Layout.prototype.on = function (e, listener) {\r\n            // override me!\r\n            if (!this.event)\r\n                this.event = {};\r\n            if (typeof e === 'string') {\r\n                this.event[EventType[e]] = listener;\r\n            }\r\n            else {\r\n                this.event[e] = listener;\r\n            }\r\n            return this;\r\n        };\r\n        // a function that is notified of events like \"tick\"\r\n        // sub-class and override this method to replace with a more sophisticated eventing mechanism\r\n        Layout.prototype.trigger = function (e) {\r\n            if (this.event && typeof this.event[e.type] !== 'undefined') {\r\n                this.event[e.type](e);\r\n            }\r\n        };\r\n        // a function that kicks off the iteration tick loop\r\n        // it calls tick() repeatedly until tick returns true (is converged)\r\n        // subclass and override it with something fancier (e.g. dispatch tick on a timer)\r\n        Layout.prototype.kick = function () {\r\n            while (!this.tick())\r\n                ;\r\n        };\r\n        /**\r\n         * iterate the layout.  Returns true when layout converged.\r\n         */\r\n        Layout.prototype.tick = function () {\r\n            if (this._alpha < this._threshold) {\r\n                this._running = false;\r\n                this.trigger({ type: EventType.end, alpha: this._alpha = 0, stress: this._lastStress });\r\n                return true;\r\n            }\r\n            var n = this._nodes.length, m = this._links.length;\r\n            var o, i;\r\n            this._descent.locks.clear();\r\n            for (i = 0; i < n; ++i) {\r\n                o = this._nodes[i];\r\n                if (o.fixed) {\r\n                    if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {\r\n                        o.px = o.x;\r\n                        o.py = o.y;\r\n                    }\r\n                    var p = [o.px, o.py];\r\n                    this._descent.locks.add(i, p);\r\n                }\r\n            }\r\n            var s1 = this._descent.rungeKutta();\r\n            //var s1 = descent.reduceStress();\r\n            if (s1 === 0) {\r\n                this._alpha = 0;\r\n            }\r\n            else if (typeof this._lastStress !== 'undefined') {\r\n                this._alpha = s1; //Math.abs(Math.abs(this._lastStress / s1) - 1);\r\n            }\r\n            this._lastStress = s1;\r\n            this.updateNodePositions();\r\n            this.trigger({ type: EventType.tick, alpha: this._alpha, stress: this._lastStress });\r\n            return false;\r\n        };\r\n        // copy positions out of descent instance into each of the nodes' center coords\r\n        Layout.prototype.updateNodePositions = function () {\r\n            var x = this._descent.x[0], y = this._descent.x[1];\r\n            var o, i = this._nodes.length;\r\n            while (i--) {\r\n                o = this._nodes[i];\r\n                o.x = x[i];\r\n                o.y = y[i];\r\n            }\r\n        };\r\n        Layout.prototype.nodes = function (v) {\r\n            if (!v) {\r\n                if (this._nodes.length === 0 && this._links.length > 0) {\r\n                    // if we have links but no nodes, create the nodes array now with empty objects for the links to point at.\r\n                    // in this case the links are expected to be numeric indices for nodes in the range 0..n-1 where n is the number of nodes\r\n                    var n = 0;\r\n                    this._links.forEach(function (l) {\r\n                        n = Math.max(n, l.source, l.target);\r\n                    });\r\n                    this._nodes = new Array(++n);\r\n                    for (var i = 0; i < n; ++i) {\r\n                        this._nodes[i] = {};\r\n                    }\r\n                }\r\n                return this._nodes;\r\n            }\r\n            this._nodes = v;\r\n            return this;\r\n        };\r\n        Layout.prototype.groups = function (x) {\r\n            var _this = this;\r\n            if (!x)\r\n                return this._groups;\r\n            this._groups = x;\r\n            this._rootGroup = {};\r\n            this._groups.forEach(function (g) {\r\n                if (typeof g.padding === \"undefined\")\r\n                    g.padding = 1;\r\n                if (typeof g.leaves !== \"undefined\")\r\n                    g.leaves.forEach(function (v, i) { (g.leaves[i] = _this._nodes[v]).parent = g; });\r\n                if (typeof g.groups !== \"undefined\")\r\n                    g.groups.forEach(function (gi, i) { (g.groups[i] = _this._groups[gi]).parent = g; });\r\n            });\r\n            this._rootGroup.leaves = this._nodes.filter(function (v) { return typeof v.parent === 'undefined'; });\r\n            this._rootGroup.groups = this._groups.filter(function (g) { return typeof g.parent === 'undefined'; });\r\n            return this;\r\n        };\r\n        Layout.prototype.powerGraphGroups = function (f) {\r\n            var g = cola.powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);\r\n            this.groups(g.groups);\r\n            f(g);\r\n            return this;\r\n        };\r\n        Layout.prototype.avoidOverlaps = function (v) {\r\n            if (!arguments.length)\r\n                return this._avoidOverlaps;\r\n            this._avoidOverlaps = v;\r\n            return this;\r\n        };\r\n        Layout.prototype.handleDisconnected = function (v) {\r\n            if (!arguments.length)\r\n                return this._handleDisconnected;\r\n            this._handleDisconnected = v;\r\n            return this;\r\n        };\r\n        /**\r\n         * causes constraints to be generated such that directed graphs are laid out either from left-to-right or top-to-bottom.\r\n         * a separation constraint is generated in the selected axis for each edge that is not involved in a cycle (part of a strongly connected component)\r\n         * @param axis {string} 'x' for left-to-right, 'y' for top-to-bottom\r\n         * @param minSeparation {number|link=>number} either a number specifying a minimum spacing required across all links or a function to return the minimum spacing for each link\r\n         */\r\n        Layout.prototype.flowLayout = function (axis, minSeparation) {\r\n            if (!arguments.length)\r\n                axis = 'y';\r\n            this._directedLinkConstraints = {\r\n                axis: axis,\r\n                getMinSeparation: typeof minSeparation === 'number' ? function () { return minSeparation; } : minSeparation\r\n            };\r\n            return this;\r\n        };\r\n        Layout.prototype.links = function (x) {\r\n            if (!arguments.length)\r\n                return this._links;\r\n            this._links = x;\r\n            return this;\r\n        };\r\n        Layout.prototype.constraints = function (c) {\r\n            if (!arguments.length)\r\n                return this._constraints;\r\n            this._constraints = c;\r\n            return this;\r\n        };\r\n        Layout.prototype.distanceMatrix = function (d) {\r\n            if (!arguments.length)\r\n                return this._distanceMatrix;\r\n            this._distanceMatrix = d;\r\n            return this;\r\n        };\r\n        Layout.prototype.size = function (x) {\r\n            if (!x)\r\n                return this._canvasSize;\r\n            this._canvasSize = x;\r\n            return this;\r\n        };\r\n        Layout.prototype.defaultNodeSize = function (x) {\r\n            if (!x)\r\n                return this._defaultNodeSize;\r\n            this._defaultNodeSize = x;\r\n            return this;\r\n        };\r\n        Layout.prototype.groupCompactness = function (x) {\r\n            if (!x)\r\n                return this._groupCompactness;\r\n            this._groupCompactness = x;\r\n            return this;\r\n        };\r\n        Layout.prototype.linkDistance = function (x) {\r\n            if (!x) {\r\n                return this._linkDistance;\r\n            }\r\n            this._linkDistance = typeof x === \"function\" ? x : +x;\r\n            this._linkLengthCalculator = null;\r\n            return this;\r\n        };\r\n        Layout.prototype.linkType = function (f) {\r\n            this._linkType = f;\r\n            return this;\r\n        };\r\n        Layout.prototype.convergenceThreshold = function (x) {\r\n            if (!x)\r\n                return this._threshold;\r\n            this._threshold = typeof x === \"function\" ? x : +x;\r\n            return this;\r\n        };\r\n        Layout.prototype.alpha = function (x) {\r\n            if (!arguments.length)\r\n                return this._alpha;\r\n            else {\r\n                x = +x;\r\n                if (this._alpha) {\r\n                    if (x > 0)\r\n                        this._alpha = x; // we might keep it hot\r\n                    else\r\n                        this._alpha = 0; // or, next tick will dispatch \"end\"\r\n                }\r\n                else if (x > 0) {\r\n                    if (!this._running) {\r\n                        this._running = true;\r\n                        this.trigger({ type: EventType.start, alpha: this._alpha = x });\r\n                        this.kick();\r\n                    }\r\n                }\r\n                return this;\r\n            }\r\n        };\r\n        Layout.prototype.getLinkLength = function (link) {\r\n            return typeof this._linkDistance === \"function\" ? +(this._linkDistance(link)) : this._linkDistance;\r\n        };\r\n        Layout.setLinkLength = function (link, length) {\r\n            link.length = length;\r\n        };\r\n        Layout.prototype.getLinkType = function (link) {\r\n            return typeof this._linkType === \"function\" ? this._linkType(link) : 0;\r\n        };\r\n        /**\r\n         * compute an ideal length for each link based on the graph structure around that link.\r\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\r\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\r\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: sqrt(|a union b| - |a intersection b|)\r\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\r\n         * don't have to have been assigned before invoking this function.\r\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\r\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\r\n         */\r\n        Layout.prototype.symmetricDiffLinkLengths = function (idealLength, w) {\r\n            var _this = this;\r\n            if (w === void 0) { w = 1; }\r\n            this.linkDistance(function (l) { return idealLength * l.length; });\r\n            this._linkLengthCalculator = function () { return cola.symmetricDiffLinkLengths(_this._links, _this.linkAccessor, w); };\r\n            return this;\r\n        };\r\n        /**\r\n         * compute an ideal length for each link based on the graph structure around that link.\r\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\r\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\r\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: |a intersection b|/|a union b|\r\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\r\n         * don't have to have been assigned before invoking this function.\r\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\r\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\r\n         */\r\n        Layout.prototype.jaccardLinkLengths = function (idealLength, w) {\r\n            var _this = this;\r\n            if (w === void 0) { w = 1; }\r\n            this.linkDistance(function (l) { return idealLength * l.length; });\r\n            this._linkLengthCalculator = function () { return cola.jaccardLinkLengths(_this._links, _this.linkAccessor, w); };\r\n            return this;\r\n        };\r\n        /**\r\n         * start the layout process\r\n         * @method start\r\n         * @param {number} [initialUnconstrainedIterations=0] unconstrained initial layout iterations\r\n         * @param {number} [initialUserConstraintIterations=0] initial layout iterations with user-specified constraints\r\n         * @param {number} [initialAllConstraintsIterations=0] initial layout iterations with all constraints including non-overlap\r\n         * @param {number} [gridSnapIterations=0] iterations of \"grid snap\", which pulls nodes towards grid cell centers - grid of size node[0].width - only really makes sense if all nodes have the same width and height\r\n         * @param [keepRunning=true] keep iterating asynchronously via the tick method\r\n         */\r\n        Layout.prototype.start = function (initialUnconstrainedIterations, initialUserConstraintIterations, initialAllConstraintsIterations, gridSnapIterations, keepRunning) {\r\n            var _this = this;\r\n            if (initialUnconstrainedIterations === void 0) { initialUnconstrainedIterations = 0; }\r\n            if (initialUserConstraintIterations === void 0) { initialUserConstraintIterations = 0; }\r\n            if (initialAllConstraintsIterations === void 0) { initialAllConstraintsIterations = 0; }\r\n            if (gridSnapIterations === void 0) { gridSnapIterations = 0; }\r\n            if (keepRunning === void 0) { keepRunning = true; }\r\n            var i, j, n = this.nodes().length, N = n + 2 * this._groups.length, m = this._links.length, w = this._canvasSize[0], h = this._canvasSize[1];\r\n            if (this._linkLengthCalculator)\r\n                this._linkLengthCalculator();\r\n            var x = new Array(N), y = new Array(N);\r\n            var G = null;\r\n            var ao = this._avoidOverlaps;\r\n            this._nodes.forEach(function (v, i) {\r\n                v.index = i;\r\n                if (typeof v.x === 'undefined') {\r\n                    v.x = w / 2, v.y = h / 2;\r\n                }\r\n                x[i] = v.x, y[i] = v.y;\r\n            });\r\n            //should we do this to clearly label groups?\r\n            //this._groups.forEach((g, i) => g.groupIndex = i);\r\n            var distances;\r\n            if (this._distanceMatrix) {\r\n                // use the user specified distanceMatrix\r\n                distances = this._distanceMatrix;\r\n            }\r\n            else {\r\n                // construct an n X n distance matrix based on shortest paths through graph (with respect to edge.length).\r\n                distances = (new cola.shortestpaths.Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, function (l) { return _this.getLinkLength(l); })).DistanceMatrix();\r\n                // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\r\n                // otherwise 2. (\r\n                G = cola.Descent.createSquareMatrix(N, function () { return 2; });\r\n                this._links.forEach(function (l) {\r\n                    if (typeof l.source == \"number\")\r\n                        l.source = _this._nodes[l.source];\r\n                    if (typeof l.target == \"number\")\r\n                        l.target = _this._nodes[l.target];\r\n                });\r\n                this._links.forEach(function (e) {\r\n                    var u = Layout.getSourceIndex(e), v = Layout.getTargetIndex(e);\r\n                    G[u][v] = G[v][u] = e.weight || 1;\r\n                });\r\n            }\r\n            var D = cola.Descent.createSquareMatrix(N, function (i, j) {\r\n                return distances[i][j];\r\n            });\r\n            if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {\r\n                var i = n;\r\n                var addAttraction = function (i, j, strength, idealDistance) {\r\n                    G[i][j] = G[j][i] = strength;\r\n                    D[i][j] = D[j][i] = idealDistance;\r\n                };\r\n                this._groups.forEach(function (g) {\r\n                    addAttraction(i, i + 1, _this._groupCompactness, 0.1);\r\n                    // todo: add terms here attracting children of the group to the group dummy nodes\r\n                    //if (typeof g.leaves !== 'undefined')\r\n                    //    g.leaves.forEach(l => {\r\n                    //        addAttraction(l.index, i, 1e-4, 0.1);\r\n                    //        addAttraction(l.index, i + 1, 1e-4, 0.1);\r\n                    //    });\r\n                    //if (typeof g.groups !== 'undefined')\r\n                    //    g.groups.forEach(g => {\r\n                    //        var gid = n + g.groupIndex * 2;\r\n                    //        addAttraction(gid, i, 0.1, 0.1);\r\n                    //        addAttraction(gid + 1, i, 0.1, 0.1);\r\n                    //        addAttraction(gid, i + 1, 0.1, 0.1);\r\n                    //        addAttraction(gid + 1, i + 1, 0.1, 0.1);\r\n                    //    });\r\n                    x[i] = 0, y[i++] = 0;\r\n                    x[i] = 0, y[i++] = 0;\r\n                });\r\n            }\r\n            else\r\n                this._rootGroup = { leaves: this._nodes, groups: [] };\r\n            var curConstraints = this._constraints || [];\r\n            if (this._directedLinkConstraints) {\r\n                this.linkAccessor.getMinSeparation = this._directedLinkConstraints.getMinSeparation;\r\n                curConstraints = curConstraints.concat(cola.generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, (this.linkAccessor)));\r\n            }\r\n            this.avoidOverlaps(false);\r\n            this._descent = new cola.Descent([x, y], D);\r\n            this._descent.locks.clear();\r\n            for (var i = 0; i < n; ++i) {\r\n                var o = this._nodes[i];\r\n                if (o.fixed) {\r\n                    o.px = o.x;\r\n                    o.py = o.y;\r\n                    var p = [o.x, o.y];\r\n                    this._descent.locks.add(i, p);\r\n                }\r\n            }\r\n            this._descent.threshold = this._threshold;\r\n            // apply initialIterations without user constraints or nonoverlap constraints\r\n            // if groups are specified, dummy nodes and edges will be added to untangle\r\n            // with respect to group connectivity\r\n            this.initialLayout(initialUnconstrainedIterations, x, y);\r\n            // apply initialIterations with user constraints but no nonoverlap constraints\r\n            if (curConstraints.length > 0)\r\n                this._descent.project = new cola.vpsc.Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();\r\n            this._descent.run(initialUserConstraintIterations);\r\n            this.separateOverlappingComponents(w, h);\r\n            // subsequent iterations will apply all constraints\r\n            this.avoidOverlaps(ao);\r\n            if (ao) {\r\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\r\n                this._descent.project = new cola.vpsc.Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();\r\n                this._nodes.forEach(function (v, i) { x[i] = v.x, y[i] = v.y; });\r\n            }\r\n            // allow not immediately connected nodes to relax apart (p-stress)\r\n            this._descent.G = G;\r\n            this._descent.run(initialAllConstraintsIterations);\r\n            if (gridSnapIterations) {\r\n                this._descent.snapStrength = 1000;\r\n                this._descent.snapGridSize = this._nodes[0].width;\r\n                this._descent.numGridSnapNodes = n;\r\n                this._descent.scaleSnapByMaxH = n != N; // if we have groups then need to scale hessian so grid forces still apply\r\n                var G0 = cola.Descent.createSquareMatrix(N, function (i, j) {\r\n                    if (i >= n || j >= n)\r\n                        return G[i][j];\r\n                    return 0;\r\n                });\r\n                this._descent.G = G0;\r\n                this._descent.run(gridSnapIterations);\r\n            }\r\n            this.updateNodePositions();\r\n            this.separateOverlappingComponents(w, h);\r\n            return keepRunning ? this.resume() : this;\r\n        };\r\n        Layout.prototype.initialLayout = function (iterations, x, y) {\r\n            if (this._groups.length > 0 && iterations > 0) {\r\n                // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children\r\n                // todo: edges attached to groups are replaced with edges connected to the corresponding group dummy node\r\n                var n = this._nodes.length;\r\n                var edges = this._links.map(function (e) { return { source: e.source.index, target: e.target.index }; });\r\n                var vs = this._nodes.map(function (v) { return { index: v.index }; });\r\n                this._groups.forEach(function (g, i) {\r\n                    vs.push({ index: g.index = n + i });\r\n                });\r\n                this._groups.forEach(function (g, i) {\r\n                    if (typeof g.leaves !== 'undefined')\r\n                        g.leaves.forEach(function (v) { return edges.push({ source: g.index, target: v.index }); });\r\n                    if (typeof g.groups !== 'undefined')\r\n                        g.groups.forEach(function (gg) { return edges.push({ source: g.index, target: gg.index }); });\r\n                });\r\n                // layout the flat graph with dummy nodes and edges\r\n                new cola.Layout()\r\n                    .size(this.size())\r\n                    .nodes(vs)\r\n                    .links(edges)\r\n                    .avoidOverlaps(false)\r\n                    .linkDistance(this.linkDistance())\r\n                    .symmetricDiffLinkLengths(5)\r\n                    .convergenceThreshold(1e-4)\r\n                    .start(iterations, 0, 0, 0, false);\r\n                this._nodes.forEach(function (v) {\r\n                    x[v.index] = vs[v.index].x;\r\n                    y[v.index] = vs[v.index].y;\r\n                });\r\n            }\r\n            else {\r\n                this._descent.run(iterations);\r\n            }\r\n        };\r\n        // recalculate nodes position for disconnected graphs\r\n        Layout.prototype.separateOverlappingComponents = function (width, height) {\r\n            var _this = this;\r\n            // recalculate nodes position for disconnected graphs\r\n            if (!this._distanceMatrix && this._handleDisconnected) {\r\n                var x = this._descent.x[0], y = this._descent.x[1];\r\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\r\n                var graphs = cola.separateGraphs(this._nodes, this._links);\r\n                cola.applyPacking(graphs, width, height, this._defaultNodeSize);\r\n                this._nodes.forEach(function (v, i) {\r\n                    _this._descent.x[0][i] = v.x, _this._descent.x[1][i] = v.y;\r\n                    if (v.bounds) {\r\n                        v.bounds.setXCentre(v.x);\r\n                        v.bounds.setYCentre(v.y);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        Layout.prototype.resume = function () {\r\n            return this.alpha(0.1);\r\n        };\r\n        Layout.prototype.stop = function () {\r\n            return this.alpha(0);\r\n        };\r\n        /// find a visibility graph over the set of nodes.  assumes all nodes have a\r\n        /// bounds property (a rectangle) and that no pair of bounds overlaps.\r\n        Layout.prototype.prepareEdgeRouting = function (nodeMargin) {\r\n            if (nodeMargin === void 0) { nodeMargin = 0; }\r\n            this._visibilityGraph = new cola.geom.TangentVisibilityGraph(this._nodes.map(function (v) {\r\n                return v.bounds.inflate(-nodeMargin).vertices();\r\n            }));\r\n        };\r\n        /// find a route avoiding node bounds for the given edge.\r\n        /// assumes the visibility graph has been created (by prepareEdgeRouting method)\r\n        /// and also assumes that nodes have an index property giving their position in the\r\n        /// node array.  This index property is created by the start() method.\r\n        Layout.prototype.routeEdge = function (edge, draw) {\r\n            var lineData = [];\r\n            //if (d.source.id === 10 && d.target.id === 11) {\r\n            //    debugger;\r\n            //}\r\n            var vg2 = new cola.geom.TangentVisibilityGraph(this._visibilityGraph.P, { V: this._visibilityGraph.V, E: this._visibilityGraph.E }), port1 = { x: edge.source.x, y: edge.source.y }, port2 = { x: edge.target.x, y: edge.target.y }, start = vg2.addPoint(port1, edge.source.index), end = vg2.addPoint(port2, edge.target.index);\r\n            vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);\r\n            if (typeof draw !== 'undefined') {\r\n                draw(vg2);\r\n            }\r\n            var sourceInd = function (e) { return e.source.id; }, targetInd = function (e) { return e.target.id; }, length = function (e) { return e.length(); }, spCalc = new cola.shortestpaths.Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length), shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);\r\n            if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {\r\n                var route = cola.vpsc.makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, 5);\r\n                lineData = [route.sourceIntersection, route.arrowStart];\r\n            }\r\n            else {\r\n                var n = shortestPath.length - 2, p = vg2.V[shortestPath[n]].p, q = vg2.V[shortestPath[0]].p, lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];\r\n                for (var i = n; i >= 0; --i)\r\n                    lineData.push(vg2.V[shortestPath[i]].p);\r\n                lineData.push(cola.vpsc.makeEdgeTo(q, edge.target.innerBounds, 5));\r\n            }\r\n            //lineData.forEach((v, i) => {\r\n            //    if (i > 0) {\r\n            //        var u = lineData[i - 1];\r\n            //        this._nodes.forEach(function (node) {\r\n            //            if (node.id === getSourceIndex(d) || node.id === getTargetIndex(d)) return;\r\n            //            var ints = node.innerBounds.lineIntersections(u.x, u.y, v.x, v.y);\r\n            //            if (ints.length > 0) {\r\n            //                debugger;\r\n            //            }\r\n            //        })\r\n            //    }\r\n            //})\r\n            return lineData;\r\n        };\r\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\r\n        Layout.getSourceIndex = function (e) {\r\n            return typeof e.source === 'number' ? e.source : e.source.index;\r\n        };\r\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\r\n        Layout.getTargetIndex = function (e) {\r\n            return typeof e.target === 'number' ? e.target : e.target.index;\r\n        };\r\n        // Get a string ID for a given link.\r\n        Layout.linkId = function (e) {\r\n            return Layout.getSourceIndex(e) + \"-\" + Layout.getTargetIndex(e);\r\n        };\r\n        // The fixed property has three bits:\r\n        // Bit 1 can be set externally (e.g., d.fixed = true) and show persist.\r\n        // Bit 2 stores the dragging state, from mousedown to mouseup.\r\n        // Bit 3 stores the hover state, from mouseover to mouseout.\r\n        Layout.dragStart = function (d) {\r\n            if (isGroup(d)) {\r\n                Layout.storeOffset(d, Layout.dragOrigin(d));\r\n            }\r\n            else {\r\n                Layout.stopNode(d);\r\n                d.fixed |= 2; // set bit 2\r\n            }\r\n        };\r\n        // we clobber any existing desired positions for nodes\r\n        // in case another tick event occurs before the drag\r\n        Layout.stopNode = function (v) {\r\n            v.px = v.x;\r\n            v.py = v.y;\r\n        };\r\n        // we store offsets for each node relative to the centre of the ancestor group \r\n        // being dragged in a pair of properties on the node\r\n        Layout.storeOffset = function (d, origin) {\r\n            if (typeof d.leaves !== 'undefined') {\r\n                d.leaves.forEach(function (v) {\r\n                    v.fixed |= 2;\r\n                    Layout.stopNode(v);\r\n                    v._dragGroupOffsetX = v.x - origin.x;\r\n                    v._dragGroupOffsetY = v.y - origin.y;\r\n                });\r\n            }\r\n            if (typeof d.groups !== 'undefined') {\r\n                d.groups.forEach(function (g) { return Layout.storeOffset(g, origin); });\r\n            }\r\n        };\r\n        // the drag origin is taken as the centre of the node or group\r\n        Layout.dragOrigin = function (d) {\r\n            if (isGroup(d)) {\r\n                return {\r\n                    x: d.bounds.cx(),\r\n                    y: d.bounds.cy()\r\n                };\r\n            }\r\n            else {\r\n                return d;\r\n            }\r\n        };\r\n        // for groups, the drag translation is propagated down to all of the children of\r\n        // the group.\r\n        Layout.drag = function (d, position) {\r\n            if (isGroup(d)) {\r\n                if (typeof d.leaves !== 'undefined') {\r\n                    d.leaves.forEach(function (v) {\r\n                        d.bounds.setXCentre(position.x);\r\n                        d.bounds.setYCentre(position.y);\r\n                        v.px = v._dragGroupOffsetX + position.x;\r\n                        v.py = v._dragGroupOffsetY + position.y;\r\n                    });\r\n                }\r\n                if (typeof d.groups !== 'undefined') {\r\n                    d.groups.forEach(function (g) { return Layout.drag(g, position); });\r\n                }\r\n            }\r\n            else {\r\n                d.px = position.x;\r\n                d.py = position.y;\r\n            }\r\n        };\r\n        // we unset only bits 2 and 3 so that the user can fix nodes with another a different\r\n        // bit such that the lock persists between drags \r\n        Layout.dragEnd = function (d) {\r\n            if (isGroup(d)) {\r\n                if (typeof d.leaves !== 'undefined') {\r\n                    d.leaves.forEach(function (v) {\r\n                        Layout.dragEnd(v);\r\n                        delete v._dragGroupOffsetX;\r\n                        delete v._dragGroupOffsetY;\r\n                    });\r\n                }\r\n                if (typeof d.groups !== 'undefined') {\r\n                    d.groups.forEach(Layout.dragEnd);\r\n                }\r\n            }\r\n            else {\r\n                d.fixed &= ~6; // unset bits 2 and 3\r\n            }\r\n        };\r\n        // in d3 hover temporarily locks nodes, currently not used in cola\r\n        Layout.mouseOver = function (d) {\r\n            d.fixed |= 4; // set bit 3\r\n            d.px = d.x, d.py = d.y; // set velocity to zero\r\n        };\r\n        // in d3 hover temporarily locks nodes, currently not used in cola\r\n        Layout.mouseOut = function (d) {\r\n            d.fixed &= ~4; // unset bit 3\r\n        };\r\n        return Layout;\r\n    })();\r\n    cola.Layout = Layout;\r\n})(cola || (cola = {}));\r\n///<reference path=\"../extern/d3.d.ts\"/>\r\n///<reference path=\"layout.ts\"/>\r\nvar cola;\r\n(function (cola) {\r\n    var D3StyleLayoutAdaptor = (function (_super) {\r\n        __extends(D3StyleLayoutAdaptor, _super);\r\n        function D3StyleLayoutAdaptor() {\r\n            _super.call(this);\r\n            this.event = d3.dispatch(cola.EventType[cola.EventType.start], cola.EventType[cola.EventType.tick], cola.EventType[cola.EventType.end]);\r\n            // bit of trickyness remapping 'this' so we can reference it in the function body.\r\n            var d3layout = this;\r\n            var drag;\r\n            this.drag = function () {\r\n                if (!drag) {\r\n                    var drag = d3.behavior.drag()\r\n                        .origin(cola.Layout.dragOrigin)\r\n                        .on(\"dragstart.d3adaptor\", cola.Layout.dragStart)\r\n                        .on(\"drag.d3adaptor\", function (d) {\r\n                        cola.Layout.drag(d, d3.event);\r\n                        d3layout.resume(); // restart annealing\r\n                    })\r\n                        .on(\"dragend.d3adaptor\", cola.Layout.dragEnd);\r\n                }\r\n                if (!arguments.length)\r\n                    return drag;\r\n                // this is the context of the function, i.e. the d3 selection\r\n                this //.on(\"mouseover.adaptor\", colaMouseover)\r\n                    .call(drag);\r\n            };\r\n        }\r\n        D3StyleLayoutAdaptor.prototype.trigger = function (e) {\r\n            var d3event = { type: cola.EventType[e.type], alpha: e.alpha, stress: e.stress };\r\n            this.event[d3event.type](d3event); // via d3 dispatcher, e.g. event.start(e);\r\n        };\r\n        // iterate layout using a d3.timer, which queues calls to tick repeatedly until tick returns true\r\n        D3StyleLayoutAdaptor.prototype.kick = function () {\r\n            var _this = this;\r\n            d3.timer(function () { return _super.prototype.tick.call(_this); });\r\n        };\r\n        // a function for binding to events on the adapter\r\n        D3StyleLayoutAdaptor.prototype.on = function (eventType, listener) {\r\n            if (typeof eventType === 'string') {\r\n                this.event.on(eventType, listener);\r\n            }\r\n            else {\r\n                this.event.on(cola.EventType[eventType], listener);\r\n            }\r\n            return this;\r\n        };\r\n        return D3StyleLayoutAdaptor;\r\n    })(cola.Layout);\r\n    cola.D3StyleLayoutAdaptor = D3StyleLayoutAdaptor;\r\n    /**\r\n     * provides an interface for use with d3:\r\n     * - uses the d3 event system to dispatch layout events such as:\r\n     *   o \"start\" (start layout process)\r\n     *   o \"tick\" (after each layout iteration)\r\n     *   o \"end\" (layout converged and complete).\r\n     * - uses the d3 timer to queue layout iterations.\r\n     * - sets up d3.behavior.drag to drag nodes\r\n     *   o use `node.call(<the returned instance of Layout>.drag)` to make nodes draggable\r\n     * returns an instance of the cola.Layout itself with which the user\r\n     * can interact directly.\r\n     */\r\n    function d3adaptor() {\r\n        return new D3StyleLayoutAdaptor();\r\n    }\r\n    cola.d3adaptor = d3adaptor;\r\n})(cola || (cola = {}));\r\n/// <reference path=\"rectangle.ts\"/>\r\n/// <reference path=\"shortestpaths.ts\"/>\r\n/// <reference path=\"geom.ts\"/>\r\n/// <reference path=\"vpsc.ts\"/>\r\nvar cola;\r\n(function (cola) {\r\n    var NodeWrapper = (function () {\r\n        function NodeWrapper(id, rect, children) {\r\n            this.id = id;\r\n            this.rect = rect;\r\n            this.children = children;\r\n            this.leaf = typeof children === 'undefined' || children.length === 0;\r\n        }\r\n        return NodeWrapper;\r\n    })();\r\n    cola.NodeWrapper = NodeWrapper;\r\n    var Vert = (function () {\r\n        function Vert(id, x, y, node, line) {\r\n            if (node === void 0) { node = null; }\r\n            if (line === void 0) { line = null; }\r\n            this.id = id;\r\n            this.x = x;\r\n            this.y = y;\r\n            this.node = node;\r\n            this.line = line;\r\n        }\r\n        return Vert;\r\n    })();\r\n    cola.Vert = Vert;\r\n    var LongestCommonSubsequence = (function () {\r\n        function LongestCommonSubsequence(s, t) {\r\n            this.s = s;\r\n            this.t = t;\r\n            var mf = LongestCommonSubsequence.findMatch(s, t);\r\n            var tr = t.slice(0).reverse();\r\n            var mr = LongestCommonSubsequence.findMatch(s, tr);\r\n            if (mf.length >= mr.length) {\r\n                this.length = mf.length;\r\n                this.si = mf.si;\r\n                this.ti = mf.ti;\r\n                this.reversed = false;\r\n            }\r\n            else {\r\n                this.length = mr.length;\r\n                this.si = mr.si;\r\n                this.ti = t.length - mr.ti - mr.length;\r\n                this.reversed = true;\r\n            }\r\n        }\r\n        LongestCommonSubsequence.findMatch = function (s, t) {\r\n            var m = s.length;\r\n            var n = t.length;\r\n            var match = { length: 0, si: -1, ti: -1 };\r\n            var l = new Array(m);\r\n            for (var i = 0; i < m; i++) {\r\n                l[i] = new Array(n);\r\n                for (var j = 0; j < n; j++)\r\n                    if (s[i] === t[j]) {\r\n                        var v = l[i][j] = (i === 0 || j === 0) ? 1 : l[i - 1][j - 1] + 1;\r\n                        if (v > match.length) {\r\n                            match.length = v;\r\n                            match.si = i - v + 1;\r\n                            match.ti = j - v + 1;\r\n                        }\r\n                        ;\r\n                    }\r\n                    else\r\n                        l[i][j] = 0;\r\n            }\r\n            return match;\r\n        };\r\n        LongestCommonSubsequence.prototype.getSequence = function () {\r\n            return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];\r\n        };\r\n        return LongestCommonSubsequence;\r\n    })();\r\n    cola.LongestCommonSubsequence = LongestCommonSubsequence;\r\n    var GridRouter = (function () {\r\n        function GridRouter(originalnodes, accessor, groupPadding) {\r\n            var _this = this;\r\n            if (groupPadding === void 0) { groupPadding = 12; }\r\n            this.originalnodes = originalnodes;\r\n            this.groupPadding = groupPadding;\r\n            this.leaves = null;\r\n            this.nodes = originalnodes.map(function (v, i) { return new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v)); });\r\n            this.leaves = this.nodes.filter(function (v) { return v.leaf; });\r\n            this.groups = this.nodes.filter(function (g) { return !g.leaf; });\r\n            this.cols = this.getGridLines('x');\r\n            this.rows = this.getGridLines('y');\r\n            // create parents for each node or group that is a member of another's children \r\n            this.groups.forEach(function (v) {\r\n                return v.children.forEach(function (c) { return _this.nodes[c].parent = v; });\r\n            });\r\n            // root claims the remaining orphans\r\n            this.root = { children: [] };\r\n            this.nodes.forEach(function (v) {\r\n                if (typeof v.parent === 'undefined') {\r\n                    v.parent = _this.root;\r\n                    _this.root.children.push(v.id);\r\n                }\r\n                // each node will have grid vertices associated with it,\r\n                // some inside the node and some on the boundary\r\n                // leaf nodes will have exactly one internal node at the center\r\n                // and four boundary nodes\r\n                // groups will have potentially many of each\r\n                v.ports = [];\r\n            });\r\n            // nodes ordered by their position in the group hierarchy\r\n            this.backToFront = this.nodes.slice(0);\r\n            this.backToFront.sort(function (x, y) { return _this.getDepth(x) - _this.getDepth(y); });\r\n            // compute boundary rectangles for each group\r\n            // has to be done from front to back, i.e. inside groups to outside groups\r\n            // such that each can be made large enough to enclose its interior\r\n            var frontToBackGroups = this.backToFront.slice(0).reverse().filter(function (g) { return !g.leaf; });\r\n            frontToBackGroups.forEach(function (v) {\r\n                var r = cola.vpsc.Rectangle.empty();\r\n                v.children.forEach(function (c) { return r = r.union(_this.nodes[c].rect); });\r\n                v.rect = r.inflate(_this.groupPadding);\r\n            });\r\n            var colMids = this.midPoints(this.cols.map(function (r) { return r.pos; }));\r\n            var rowMids = this.midPoints(this.rows.map(function (r) { return r.pos; }));\r\n            // setup extents of lines\r\n            var rowx = colMids[0], rowX = colMids[colMids.length - 1];\r\n            var coly = rowMids[0], colY = rowMids[rowMids.length - 1];\r\n            // horizontal lines\r\n            var hlines = this.rows.map(function (r) { return { x1: rowx, x2: rowX, y1: r.pos, y2: r.pos }; })\r\n                .concat(rowMids.map(function (m) { return { x1: rowx, x2: rowX, y1: m, y2: m }; }));\r\n            // vertical lines\r\n            var vlines = this.cols.map(function (c) { return { x1: c.pos, x2: c.pos, y1: coly, y2: colY }; })\r\n                .concat(colMids.map(function (m) { return { x1: m, x2: m, y1: coly, y2: colY }; }));\r\n            // the full set of lines\r\n            var lines = hlines.concat(vlines);\r\n            // we record the vertices associated with each line\r\n            lines.forEach(function (l) { return l.verts = []; });\r\n            // the routing graph\r\n            this.verts = [];\r\n            this.edges = [];\r\n            // create vertices at the crossings of horizontal and vertical grid-lines\r\n            hlines.forEach(function (h) {\r\n                return vlines.forEach(function (v) {\r\n                    var p = new Vert(_this.verts.length, v.x1, h.y1);\r\n                    h.verts.push(p);\r\n                    v.verts.push(p);\r\n                    _this.verts.push(p);\r\n                    // assign vertices to the nodes immediately under them\r\n                    var i = _this.backToFront.length;\r\n                    while (i-- > 0) {\r\n                        var node = _this.backToFront[i], r = node.rect;\r\n                        var dx = Math.abs(p.x - r.cx()), dy = Math.abs(p.y - r.cy());\r\n                        if (dx < r.width() / 2 && dy < r.height() / 2) {\r\n                            p.node = node;\r\n                            break;\r\n                        }\r\n                    }\r\n                });\r\n            });\r\n            lines.forEach(function (l, li) {\r\n                // create vertices at the intersections of nodes and lines\r\n                _this.nodes.forEach(function (v, i) {\r\n                    v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach(function (intersect, j) {\r\n                        //console.log(li+','+i+','+j+':'+intersect.x + ',' + intersect.y);\r\n                        var p = new Vert(_this.verts.length, intersect.x, intersect.y, v, l);\r\n                        _this.verts.push(p);\r\n                        l.verts.push(p);\r\n                        v.ports.push(p);\r\n                    });\r\n                });\r\n                // split lines into edges joining vertices\r\n                var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;\r\n                var delta = function (a, b) { return isHoriz ? b.x - a.x : b.y - a.y; };\r\n                l.verts.sort(delta);\r\n                for (var i = 1; i < l.verts.length; i++) {\r\n                    var u = l.verts[i - 1], v = l.verts[i];\r\n                    if (u.node && u.node === v.node && u.node.leaf)\r\n                        continue;\r\n                    _this.edges.push({ source: u.id, target: v.id, length: Math.abs(delta(u, v)) });\r\n                }\r\n            });\r\n        }\r\n        GridRouter.prototype.avg = function (a) { return a.reduce(function (x, y) { return x + y; }) / a.length; };\r\n        // in the given axis, find sets of leaves overlapping in that axis\r\n        // center of each GridLine is average of all nodes in column\r\n        GridRouter.prototype.getGridLines = function (axis) {\r\n            var columns = [];\r\n            var ls = this.leaves.slice(0, this.leaves.length);\r\n            while (ls.length > 0) {\r\n                // find a column of all leaves overlapping in axis with the first leaf\r\n                var overlapping = ls.filter(function (v) { return v.rect['overlap' + axis.toUpperCase()](ls[0].rect); });\r\n                var col = {\r\n                    nodes: overlapping,\r\n                    pos: this.avg(overlapping.map(function (v) { return v.rect['c' + axis](); }))\r\n                };\r\n                columns.push(col);\r\n                col.nodes.forEach(function (v) { return ls.splice(ls.indexOf(v), 1); });\r\n            }\r\n            columns.sort(function (a, b) { return a.pos - b.pos; });\r\n            return columns;\r\n        };\r\n        // get the depth of the given node in the group hierarchy\r\n        GridRouter.prototype.getDepth = function (v) {\r\n            var depth = 0;\r\n            while (v.parent !== this.root) {\r\n                depth++;\r\n                v = v.parent;\r\n            }\r\n            return depth;\r\n        };\r\n        // medial axes between node centres and also boundary lines for the grid\r\n        GridRouter.prototype.midPoints = function (a) {\r\n            var gap = a[1] - a[0];\r\n            var mids = [a[0] - gap / 2];\r\n            for (var i = 1; i < a.length; i++) {\r\n                mids.push((a[i] + a[i - 1]) / 2);\r\n            }\r\n            mids.push(a[a.length - 1] + gap / 2);\r\n            return mids;\r\n        };\r\n        // find path from v to root including both v and root\r\n        GridRouter.prototype.findLineage = function (v) {\r\n            var lineage = [v];\r\n            do {\r\n                v = v.parent;\r\n                lineage.push(v);\r\n            } while (v !== this.root);\r\n            return lineage.reverse();\r\n        };\r\n        // find path connecting a and b through their lowest common ancestor\r\n        GridRouter.prototype.findAncestorPathBetween = function (a, b) {\r\n            var aa = this.findLineage(a), ba = this.findLineage(b), i = 0;\r\n            while (aa[i] === ba[i])\r\n                i++;\r\n            // i-1 to include common ancestor only once (as first element)\r\n            return { commonAncestor: aa[i - 1], lineages: aa.slice(i).concat(ba.slice(i)) };\r\n        };\r\n        // when finding a path between two nodes a and b, siblings of a and b on the\r\n        // paths from a and b to their least common ancestor are obstacles\r\n        GridRouter.prototype.siblingObstacles = function (a, b) {\r\n            var _this = this;\r\n            var path = this.findAncestorPathBetween(a, b);\r\n            var lineageLookup = {};\r\n            path.lineages.forEach(function (v) { return lineageLookup[v.id] = {}; });\r\n            var obstacles = path.commonAncestor.children.filter(function (v) { return !(v in lineageLookup); });\r\n            path.lineages\r\n                .filter(function (v) { return v.parent !== path.commonAncestor; })\r\n                .forEach(function (v) { return obstacles = obstacles.concat(v.parent.children.filter(function (c) { return c !== v.id; })); });\r\n            return obstacles.map(function (v) { return _this.nodes[v]; });\r\n        };\r\n        // for the given routes, extract all the segments orthogonal to the axis x\r\n        // and return all them grouped by x position\r\n        GridRouter.getSegmentSets = function (routes, x, y) {\r\n            // vsegments is a list of vertical segments sorted by x position\r\n            var vsegments = [];\r\n            for (var ei = 0; ei < routes.length; ei++) {\r\n                var route = routes[ei];\r\n                for (var si = 0; si < route.length; si++) {\r\n                    var s = route[si];\r\n                    s.edgeid = ei;\r\n                    s.i = si;\r\n                    var sdx = s[1][x] - s[0][x];\r\n                    if (Math.abs(sdx) < 0.1) {\r\n                        vsegments.push(s);\r\n                    }\r\n                }\r\n            }\r\n            vsegments.sort(function (a, b) { return a[0][x] - b[0][x]; });\r\n            // vsegmentsets is a set of sets of segments grouped by x position\r\n            var vsegmentsets = [];\r\n            var segmentset = null;\r\n            for (var i = 0; i < vsegments.length; i++) {\r\n                var s = vsegments[i];\r\n                if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {\r\n                    segmentset = { pos: s[0][x], segments: [] };\r\n                    vsegmentsets.push(segmentset);\r\n                }\r\n                segmentset.segments.push(s);\r\n            }\r\n            return vsegmentsets;\r\n        };\r\n        // for all segments in this bundle create a vpsc problem such that\r\n        // each segment's x position is a variable and separation constraints \r\n        // are given by the partial order over the edges to which the segments belong\r\n        // for each pair s1,s2 of segments in the open set:\r\n        //   e1 = edge of s1, e2 = edge of s2\r\n        //   if leftOf(e1,e2) create constraint s1.x + gap <= s2.x\r\n        //   else if leftOf(e2,e1) create cons. s2.x + gap <= s1.x\r\n        GridRouter.nudgeSegs = function (x, y, routes, segments, leftOf, gap) {\r\n            var n = segments.length;\r\n            if (n <= 1)\r\n                return;\r\n            var vs = segments.map(function (s) { return new cola.vpsc.Variable(s[0][x]); });\r\n            var cs = [];\r\n            for (var i = 0; i < n; i++) {\r\n                for (var j = 0; j < n; j++) {\r\n                    if (i === j)\r\n                        continue;\r\n                    var s1 = segments[i], s2 = segments[j], e1 = s1.edgeid, e2 = s2.edgeid, lind = -1, rind = -1;\r\n                    // in page coordinates (not cartesian) the notion of 'leftof' is flipped in the horizontal axis from the vertical axis\r\n                    // that is, when nudging vertical segments, if they increase in the y(conj) direction the segment belonging to the\r\n                    // 'left' edge actually needs to be nudged to the right\r\n                    // when nudging horizontal segments, if the segments increase in the x direction\r\n                    // then the 'left' segment needs to go higher, i.e. to have y pos less than that of the right\r\n                    if (x == 'x') {\r\n                        if (leftOf(e1, e2)) {\r\n                            //console.log('s1: ' + s1[0][x] + ',' + s1[0][y] + '-' + s1[1][x] + ',' + s1[1][y]);\r\n                            if (s1[0][y] < s1[1][y]) {\r\n                                lind = j, rind = i;\r\n                            }\r\n                            else {\r\n                                lind = i, rind = j;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (leftOf(e1, e2)) {\r\n                            if (s1[0][y] < s1[1][y]) {\r\n                                lind = i, rind = j;\r\n                            }\r\n                            else {\r\n                                lind = j, rind = i;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (lind >= 0) {\r\n                        //console.log(x+' constraint: ' + lind + '<' + rind);\r\n                        cs.push(new cola.vpsc.Constraint(vs[lind], vs[rind], gap));\r\n                    }\r\n                }\r\n            }\r\n            var solver = new cola.vpsc.Solver(vs, cs);\r\n            solver.solve();\r\n            vs.forEach(function (v, i) {\r\n                var s = segments[i];\r\n                var pos = v.position();\r\n                s[0][x] = s[1][x] = pos;\r\n                var route = routes[s.edgeid];\r\n                if (s.i > 0)\r\n                    route[s.i - 1][1][x] = pos;\r\n                if (s.i < route.length - 1)\r\n                    route[s.i + 1][0][x] = pos;\r\n            });\r\n        };\r\n        GridRouter.nudgeSegments = function (routes, x, y, leftOf, gap) {\r\n            var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);\r\n            // scan the grouped (by x) segment sets to find co-linear bundles\r\n            for (var i = 0; i < vsegmentsets.length; i++) {\r\n                var ss = vsegmentsets[i];\r\n                var events = [];\r\n                for (var j = 0; j < ss.segments.length; j++) {\r\n                    var s = ss.segments[j];\r\n                    events.push({ type: 0, s: s, pos: Math.min(s[0][y], s[1][y]) });\r\n                    events.push({ type: 1, s: s, pos: Math.max(s[0][y], s[1][y]) });\r\n                }\r\n                events.sort(function (a, b) { return a.pos - b.pos + a.type - b.type; });\r\n                var open = [];\r\n                var openCount = 0;\r\n                events.forEach(function (e) {\r\n                    if (e.type === 0) {\r\n                        open.push(e.s);\r\n                        openCount++;\r\n                    }\r\n                    else {\r\n                        openCount--;\r\n                    }\r\n                    if (openCount == 0) {\r\n                        GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);\r\n                        open = [];\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        // obtain routes for the specified edges, nicely nudged apart\r\n        // warning: edge paths may be reversed such that common paths are ordered consistently within bundles!\r\n        // @param edges list of edges\r\n        // @param nudgeGap how much to space parallel edge segements\r\n        // @param source function to retrieve the index of the source node for a given edge\r\n        // @param target function to retrieve the index of the target node for a given edge\r\n        // @returns an array giving, for each edge, an array of segments, each segment a pair of points in an array\r\n        GridRouter.prototype.routeEdges = function (edges, nudgeGap, source, target) {\r\n            var _this = this;\r\n            var routePaths = edges.map(function (e) { return _this.route(source(e), target(e)); });\r\n            var order = cola.GridRouter.orderEdges(routePaths);\r\n            var routes = routePaths.map(function (e) { return cola.GridRouter.makeSegments(e); });\r\n            cola.GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);\r\n            cola.GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);\r\n            cola.GridRouter.unreverseEdges(routes, routePaths);\r\n            return routes;\r\n        };\r\n        // path may have been reversed by the subsequence processing in orderEdges\r\n        // so now we need to restore the original order\r\n        GridRouter.unreverseEdges = function (routes, routePaths) {\r\n            routes.forEach(function (segments, i) {\r\n                var path = routePaths[i];\r\n                if (path.reversed) {\r\n                    segments.reverse(); // reverse order of segments\r\n                    segments.forEach(function (segment) {\r\n                        segment.reverse(); // reverse each segment\r\n                    });\r\n                }\r\n            });\r\n        };\r\n        GridRouter.angleBetween2Lines = function (line1, line2) {\r\n            var angle1 = Math.atan2(line1[0].y - line1[1].y, line1[0].x - line1[1].x);\r\n            var angle2 = Math.atan2(line2[0].y - line2[1].y, line2[0].x - line2[1].x);\r\n            var diff = angle1 - angle2;\r\n            if (diff > Math.PI || diff < -Math.PI) {\r\n                diff = angle2 - angle1;\r\n            }\r\n            return diff;\r\n        };\r\n        // does the path a-b-c describe a left turn?\r\n        GridRouter.isLeft = function (a, b, c) {\r\n            return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) <= 0;\r\n        };\r\n        // for the given list of ordered pairs, returns a function that (efficiently) looks-up a specific pair to\r\n        // see if it exists in the list\r\n        GridRouter.getOrder = function (pairs) {\r\n            var outgoing = {};\r\n            for (var i = 0; i < pairs.length; i++) {\r\n                var p = pairs[i];\r\n                if (typeof outgoing[p.l] === 'undefined')\r\n                    outgoing[p.l] = {};\r\n                outgoing[p.l][p.r] = true;\r\n            }\r\n            return function (l, r) { return typeof outgoing[l] !== 'undefined' && outgoing[l][r]; };\r\n        };\r\n        // returns an ordering (a lookup function) that determines the correct order to nudge the\r\n        // edge paths apart to minimize crossings\r\n        GridRouter.orderEdges = function (edges) {\r\n            var edgeOrder = [];\r\n            for (var i = 0; i < edges.length - 1; i++) {\r\n                for (var j = i + 1; j < edges.length; j++) {\r\n                    var e = edges[i], f = edges[j], lcs = new cola.LongestCommonSubsequence(e, f);\r\n                    var u, vi, vj;\r\n                    if (lcs.length === 0)\r\n                        continue; // no common subpath\r\n                    if (lcs.reversed) {\r\n                        // if we found a common subpath but one of the edges runs the wrong way, \r\n                        // then reverse f.\r\n                        f.reverse();\r\n                        f.reversed = true;\r\n                        lcs = new cola.LongestCommonSubsequence(e, f);\r\n                    }\r\n                    if ((lcs.si <= 0 || lcs.ti <= 0) &&\r\n                        (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {\r\n                        // the paths do not diverge, so make an arbitrary ordering decision\r\n                        edgeOrder.push({ l: i, r: j });\r\n                        continue;\r\n                    }\r\n                    if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {\r\n                        // if the common subsequence of the\r\n                        // two edges being considered goes all the way to the\r\n                        // end of one (or both) of the lines then we have to \r\n                        // base our ordering decision on the other end of the\r\n                        // common subsequence\r\n                        u = e[lcs.si + 1];\r\n                        vj = e[lcs.si - 1];\r\n                        vi = f[lcs.ti - 1];\r\n                    }\r\n                    else {\r\n                        u = e[lcs.si + lcs.length - 2];\r\n                        vi = e[lcs.si + lcs.length];\r\n                        vj = f[lcs.ti + lcs.length];\r\n                    }\r\n                    if (GridRouter.isLeft(u, vi, vj)) {\r\n                        edgeOrder.push({ l: j, r: i });\r\n                    }\r\n                    else {\r\n                        edgeOrder.push({ l: i, r: j });\r\n                    }\r\n                }\r\n            }\r\n            //edgeOrder.forEach(function (e) { console.log('l:' + e.l + ',r:' + e.r) });\r\n            return cola.GridRouter.getOrder(edgeOrder);\r\n        };\r\n        // for an orthogonal path described by a sequence of points, create a list of segments\r\n        // if consecutive segments would make a straight line they are merged into a single segment\r\n        // segments are over cloned points, not the original vertices\r\n        GridRouter.makeSegments = function (path) {\r\n            function copyPoint(p) {\r\n                return { x: p.x, y: p.y };\r\n            }\r\n            var isStraight = function (a, b, c) { return Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001; };\r\n            var segments = [];\r\n            var a = copyPoint(path[0]);\r\n            for (var i = 1; i < path.length; i++) {\r\n                var b = copyPoint(path[i]), c = i < path.length - 1 ? path[i + 1] : null;\r\n                if (!c || !isStraight(a, b, c)) {\r\n                    segments.push([a, b]);\r\n                    a = b;\r\n                }\r\n            }\r\n            return segments;\r\n        };\r\n        // find a route between node s and node t\r\n        // returns an array of indices to verts\r\n        GridRouter.prototype.route = function (s, t) {\r\n            var _this = this;\r\n            var source = this.nodes[s], target = this.nodes[t];\r\n            this.obstacles = this.siblingObstacles(source, target);\r\n            var obstacleLookup = {};\r\n            this.obstacles.forEach(function (o) { return obstacleLookup[o.id] = o; });\r\n            this.passableEdges = this.edges.filter(function (e) {\r\n                var u = _this.verts[e.source], v = _this.verts[e.target];\r\n                return !(u.node && u.node.id in obstacleLookup\r\n                    || v.node && v.node.id in obstacleLookup);\r\n            });\r\n            // add dummy segments linking ports inside source and target\r\n            for (var i = 1; i < source.ports.length; i++) {\r\n                var u = source.ports[0].id;\r\n                var v = source.ports[i].id;\r\n                this.passableEdges.push({\r\n                    source: u,\r\n                    target: v,\r\n                    length: 0\r\n                });\r\n            }\r\n            for (var i = 1; i < target.ports.length; i++) {\r\n                var u = target.ports[0].id;\r\n                var v = target.ports[i].id;\r\n                this.passableEdges.push({\r\n                    source: u,\r\n                    target: v,\r\n                    length: 0\r\n                });\r\n            }\r\n            var getSource = function (e) { return e.source; }, getTarget = function (e) { return e.target; }, getLength = function (e) { return e.length; };\r\n            var shortestPathCalculator = new cola.shortestpaths.Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);\r\n            var bendPenalty = function (u, v, w) {\r\n                var a = _this.verts[u], b = _this.verts[v], c = _this.verts[w];\r\n                var dx = Math.abs(c.x - a.x), dy = Math.abs(c.y - a.y);\r\n                // don't count bends from internal node edges\r\n                if (a.node === source && a.node === b.node || b.node === target && b.node === c.node)\r\n                    return 0;\r\n                return dx > 1 && dy > 1 ? 1000 : 0;\r\n            };\r\n            // get shortest path\r\n            var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(source.ports[0].id, target.ports[0].id, bendPenalty);\r\n            // shortest path is reversed and does not include the target port\r\n            var pathPoints = shortestPath.reverse().map(function (vi) { return _this.verts[vi]; });\r\n            pathPoints.push(this.nodes[target.id].ports[0]);\r\n            // filter out any extra end points that are inside the source or target (i.e. the dummy segments above)\r\n            return pathPoints.filter(function (v, i) {\r\n                return !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source\r\n                    || i > 0 && v.node === target && pathPoints[i - 1].node === target);\r\n            });\r\n        };\r\n        GridRouter.getRoutePath = function (route, cornerradius, arrowwidth, arrowheight) {\r\n            var result = {\r\n                routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',\r\n                arrowpath: ''\r\n            };\r\n            if (route.length > 1) {\r\n                for (var i = 0; i < route.length; i++) {\r\n                    var li = route[i];\r\n                    var x = li[1].x, y = li[1].y;\r\n                    var dx = x - li[0].x;\r\n                    var dy = y - li[0].y;\r\n                    if (i < route.length - 1) {\r\n                        if (Math.abs(dx) > 0) {\r\n                            x -= dx / Math.abs(dx) * cornerradius;\r\n                        }\r\n                        else {\r\n                            y -= dy / Math.abs(dy) * cornerradius;\r\n                        }\r\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\r\n                        var l = route[i + 1];\r\n                        var x0 = l[0].x, y0 = l[0].y;\r\n                        var x1 = l[1].x;\r\n                        var y1 = l[1].y;\r\n                        dx = x1 - x0;\r\n                        dy = y1 - y0;\r\n                        var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;\r\n                        //console.log(cola.GridRouter.angleBetween2Lines(li, l))\r\n                        var x2, y2;\r\n                        if (Math.abs(dx) > 0) {\r\n                            x2 = x0 + dx / Math.abs(dx) * cornerradius;\r\n                            y2 = y0;\r\n                        }\r\n                        else {\r\n                            x2 = x0;\r\n                            y2 = y0 + dy / Math.abs(dy) * cornerradius;\r\n                        }\r\n                        var cx = Math.abs(x2 - x);\r\n                        var cy = Math.abs(y2 - y);\r\n                        result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';\r\n                    }\r\n                    else {\r\n                        var arrowtip = [x, y];\r\n                        var arrowcorner1, arrowcorner2;\r\n                        if (Math.abs(dx) > 0) {\r\n                            x -= dx / Math.abs(dx) * arrowheight;\r\n                            arrowcorner1 = [x, y + arrowwidth];\r\n                            arrowcorner2 = [x, y - arrowwidth];\r\n                        }\r\n                        else {\r\n                            y -= dy / Math.abs(dy) * arrowheight;\r\n                            arrowcorner1 = [x + arrowwidth, y];\r\n                            arrowcorner2 = [x - arrowwidth, y];\r\n                        }\r\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\r\n                        if (arrowheight > 0) {\r\n                            result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\r\n                                + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                var li = route[0];\r\n                var x = li[1].x, y = li[1].y;\r\n                var dx = x - li[0].x;\r\n                var dy = y - li[0].y;\r\n                var arrowtip = [x, y];\r\n                var arrowcorner1, arrowcorner2;\r\n                if (Math.abs(dx) > 0) {\r\n                    x -= dx / Math.abs(dx) * arrowheight;\r\n                    arrowcorner1 = [x, y + arrowwidth];\r\n                    arrowcorner2 = [x, y - arrowwidth];\r\n                }\r\n                else {\r\n                    y -= dy / Math.abs(dy) * arrowheight;\r\n                    arrowcorner1 = [x + arrowwidth, y];\r\n                    arrowcorner2 = [x - arrowwidth, y];\r\n                }\r\n                result.routepath += 'L ' + x + ' ' + y + ' ';\r\n                if (arrowheight > 0) {\r\n                    result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\r\n                        + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        return GridRouter;\r\n    })();\r\n    cola.GridRouter = GridRouter;\r\n})(cola || (cola = {}));\r\n/**\r\n * Use cola to do a layout in 3D!! Yay.\r\n * Pretty simple for the moment.\r\n */\r\nvar cola;\r\n(function (cola) {\r\n    var Link3D = (function () {\r\n        function Link3D(source, target) {\r\n            this.source = source;\r\n            this.target = target;\r\n        }\r\n        Link3D.prototype.actualLength = function (x) {\r\n            var _this = this;\r\n            return Math.sqrt(x.reduce(function (c, v) {\r\n                var dx = v[_this.target] - v[_this.source];\r\n                return c + dx * dx;\r\n            }, 0));\r\n        };\r\n        return Link3D;\r\n    })();\r\n    cola.Link3D = Link3D;\r\n    var Node3D = (function () {\r\n        function Node3D(x, y, z) {\r\n            if (x === void 0) { x = 0; }\r\n            if (y === void 0) { y = 0; }\r\n            if (z === void 0) { z = 0; }\r\n            this.x = x;\r\n            this.y = y;\r\n            this.z = z;\r\n        }\r\n        return Node3D;\r\n    })();\r\n    cola.Node3D = Node3D;\r\n    var Layout3D = (function () {\r\n        function Layout3D(nodes, links, idealLinkLength) {\r\n            var _this = this;\r\n            if (idealLinkLength === void 0) { idealLinkLength = 1; }\r\n            this.nodes = nodes;\r\n            this.links = links;\r\n            this.idealLinkLength = idealLinkLength;\r\n            this.constraints = null;\r\n            this.useJaccardLinkLengths = true;\r\n            this.result = new Array(Layout3D.k);\r\n            for (var i = 0; i < Layout3D.k; ++i) {\r\n                this.result[i] = new Array(nodes.length);\r\n            }\r\n            nodes.forEach(function (v, i) {\r\n                for (var _i = 0, _a = Layout3D.dims; _i < _a.length; _i++) {\r\n                    var dim = _a[_i];\r\n                    if (typeof v[dim] == 'undefined')\r\n                        v[dim] = Math.random();\r\n                }\r\n                _this.result[0][i] = v.x;\r\n                _this.result[1][i] = v.y;\r\n                _this.result[2][i] = v.z;\r\n            });\r\n        }\r\n        ;\r\n        Layout3D.prototype.linkLength = function (l) {\r\n            return l.actualLength(this.result);\r\n        };\r\n        Layout3D.prototype.start = function (iterations) {\r\n            var _this = this;\r\n            if (iterations === void 0) { iterations = 100; }\r\n            var n = this.nodes.length;\r\n            var linkAccessor = new LinkAccessor();\r\n            if (this.useJaccardLinkLengths)\r\n                cola.jaccardLinkLengths(this.links, linkAccessor, 1.5);\r\n            this.links.forEach(function (e) { return e.length *= _this.idealLinkLength; });\r\n            // Create the distance matrix that Cola needs\r\n            var distanceMatrix = (new cola.shortestpaths.Calculator(n, this.links, function (e) { return e.source; }, function (e) { return e.target; }, function (e) { return e.length; })).DistanceMatrix();\r\n            var D = cola.Descent.createSquareMatrix(n, function (i, j) { return distanceMatrix[i][j]; });\r\n            // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\r\n            // otherwise 2.\r\n            var G = cola.Descent.createSquareMatrix(n, function () { return 2; });\r\n            this.links.forEach(function (_a) {\r\n                var source = _a.source, target = _a.target;\r\n                return G[source][target] = G[target][source] = 1;\r\n            });\r\n            this.descent = new cola.Descent(this.result, D);\r\n            this.descent.threshold = 1e-3;\r\n            this.descent.G = G;\r\n            //let constraints = this.links.map(e=> <any>{\r\n            //    axis: 'y', left: e.source, right: e.target, gap: e.length*1.5\r\n            //});\r\n            if (this.constraints)\r\n                this.descent.project = new cola.vpsc.Projection(this.nodes, null, null, this.constraints).projectFunctions();\r\n            for (var i = 0; i < this.nodes.length; i++) {\r\n                var v = this.nodes[i];\r\n                if (v.fixed) {\r\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);\r\n                }\r\n            }\r\n            this.descent.run(iterations);\r\n            return this;\r\n        };\r\n        Layout3D.prototype.tick = function () {\r\n            this.descent.locks.clear();\r\n            for (var i = 0; i < this.nodes.length; i++) {\r\n                var v = this.nodes[i];\r\n                if (v.fixed) {\r\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);\r\n                }\r\n            }\r\n            return this.descent.rungeKutta();\r\n        };\r\n        Layout3D.dims = ['x', 'y', 'z'];\r\n        Layout3D.k = Layout3D.dims.length;\r\n        return Layout3D;\r\n    })();\r\n    cola.Layout3D = Layout3D;\r\n    var LinkAccessor = (function () {\r\n        function LinkAccessor() {\r\n        }\r\n        LinkAccessor.prototype.getSourceIndex = function (e) { return e.source; };\r\n        LinkAccessor.prototype.getTargetIndex = function (e) { return e.target; };\r\n        LinkAccessor.prototype.getLength = function (e) { return e.length; };\r\n        LinkAccessor.prototype.setLength = function (e, l) { e.length = l; };\r\n        return LinkAccessor;\r\n    })();\r\n})(cola || (cola = {}));\r\n/**\r\n * When compiled, this file will build a CommonJS module for WebCola.\r\n *\r\n * Unfortunately, internal and external TypeScript modules do not get\r\n * along well. This method of converting internal modules to external\r\n * modules is a bit of a hack, but is minimally invasive (i.e., no modules\r\n * need to be rewritten as external modules and modules can still span\r\n * multiple files)\r\n *\r\n * When starting a new project from scratch where CommonJS compatibility\r\n * is desired, consider instead preferring external modules to internal\r\n * modules.\r\n */\r\n///<reference path=\"./src/d3adaptor.ts\"/>\r\n///<reference path=\"./src/descent.ts\"/>\r\n///<reference path=\"./src/geom.ts\"/>\r\n///<reference path=\"./src/gridrouter.ts\"/>\r\n///<reference path=\"./src/handledisconnected.ts\"/>\r\n///<reference path=\"./src/layout.ts\"/>\r\n///<reference path=\"./src/layout3d.ts\"/>\r\n///<reference path=\"./src/linklengths.ts\"/>\r\n///<reference path=\"./src/powergraph.ts\"/>\r\n///<reference path=\"./src/pqueue.ts\"/>\r\n///<reference path=\"./src/rectangle.ts\"/>\r\n///<reference path=\"./src/shortestpaths.ts\"/>\r\n///<reference path=\"./src/vpsc.ts\"/>\r\n///<reference path=\"./src/rbtree.ts\"/>\r\n// Export cola as a CommonJS module. Note that we're bypassing TypeScript's external\r\n// module system here. Because internal modules were written with the browser in mind,\r\n// TypeScript's model is that the current context is the global context (i.e., window.cola\r\n// === cola), so `export = cola` is transpiled as a no-op.\r\nmodule.exports = cola;\r\n","exports.name = \"meteor-node-stubs\";\nexports.version = \"0.2.1\";\nexports.main = \"index.js\";\n","var map = require(\"./map.json\");\nvar meteorAliases = {};\n\nObject.keys(map).forEach(function (id) {\n  if (typeof map[id] === \"string\") {\n    try {\n      exports[id] = meteorAliases[id + \".js\"] =\n        require.resolve(map[id]);\n    } catch (e) {\n      // Resolution can fail at runtime if the stub was not included in the\n      // bundle because nothing depended on it.\n    }\n  } else {\n    exports[id] = map[id];\n    meteorAliases[id + \".js\"] = function(){};\n  }\n});\n\nif (typeof meteorInstall === \"function\") {\n  meteorInstall({\n    // Install the aliases into a node_modules directory one level up from\n    // the root directory, so that they do not clutter the namespace\n    // available to apps and packages.\n    \"..\": {\n      node_modules: meteorAliases\n    }\n  });\n}\n","module.exports = {\n  \"assert\": \"assert/\",\n  \"buffer\": \"buffer/\",\n  \"child_process\": null,\n  \"cluster\": null,\n  \"console\": \"console-browserify\",\n  \"constants\": \"constants-browserify\",\n  \"crypto\": \"crypto-browserify\",\n  \"dgram\": null,\n  \"dns\": null,\n  \"domain\": \"domain-browser\",\n  \"events\": \"events/\",\n  \"fs\": null,\n  \"http\": \"http-browserify\",\n  \"https\": \"https-browserify\",\n  \"module\": null,\n  \"net\": null,\n  \"os\": \"os-browserify/browser.js\",\n  \"path\": \"path-browserify\",\n  \"process\": \"process/browser.js\",\n  \"punycode\": \"punycode/\",\n  \"querystring\": \"querystring-es3/\",\n  \"readline\": null,\n  \"repl\": null,\n  \"stream\": \"stream-browserify\",\n  \"_stream_duplex\": \"readable-stream/duplex.js\",\n  \"_stream_passthrough\": \"readable-stream/passthrough.js\",\n  \"_stream_readable\": \"readable-stream/readable.js\",\n  \"_stream_transform\": \"readable-stream/transform.js\",\n  \"_stream_writable\": \"readable-stream/writable.js\",\n  \"string_decoder\": \"string_decoder/\",\n  \"sys\": \"util/util.js\",\n  \"timers\": \"timers-browserify\",\n  \"tls\": null,\n  \"tty\": \"tty-browserify\",\n  \"url\": \"url/\",\n  \"util\": \"util/util.js\",\n  \"vm\": \"vm-browserify\",\n  \"zlib\": \"browserify-zlib\"\n};\n","require(\"buffer/\");\n","require(\"process/browser.js\");\n","require(\"domain-browser\");\n","exports.name = \"buffer\";\nexports.version = \"4.5.0\";\nexports.main = \"index.js\";\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    this.length = 0\n    this.parent = undefined\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(array)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n} else {\n  // pre-set for values that may exist in the future\n  Buffer.prototype.length = undefined\n  Buffer.prototype.parent = undefined\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n","exports.name = \"base64-js\";\nexports.version = \"1.0.4\";\nexports.main = \"lib/b64.js\";\n",";(function (exports) {\n  'use strict'\n\n  var i\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n  var lookup = []\n  for (i = 0; i < code.length; i++) {\n    lookup[i] = code[i]\n  }\n  var revLookup = []\n\n  for (i = 0; i < code.length; ++i) {\n    revLookup[code.charCodeAt(i)] = i\n  }\n  revLookup['-'.charCodeAt(0)] = 62\n  revLookup['_'.charCodeAt(0)] = 63\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n  function decode (elt) {\n    var v = revLookup[elt.charCodeAt(0)]\n    return v !== undefined ? v : -1\n  }\n\n  function b64ToByteArray (b64) {\n    var i, j, l, tmp, placeHolders, arr\n\n    if (b64.length % 4 > 0) {\n      throw new Error('Invalid string. Length must be a multiple of 4')\n    }\n\n    // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n    var len = b64.length\n    placeHolders = b64.charAt(len - 2) === '=' ? 2 : b64.charAt(len - 1) === '=' ? 1 : 0\n\n    // base64 is 4/3 + up to two characters of the original data\n    arr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n    // if there are placeholders, only get up to the last complete 4 chars\n    l = placeHolders > 0 ? b64.length - 4 : b64.length\n\n    var L = 0\n\n    function push (v) {\n      arr[L++] = v\n    }\n\n    for (i = 0, j = 0; i < l; i += 4, j += 3) {\n      tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n      push((tmp & 0xFF0000) >> 16)\n      push((tmp & 0xFF00) >> 8)\n      push(tmp & 0xFF)\n    }\n\n    if (placeHolders === 2) {\n      tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n      push(tmp & 0xFF)\n    } else if (placeHolders === 1) {\n      tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n      push((tmp >> 8) & 0xFF)\n      push(tmp & 0xFF)\n    }\n\n    return arr\n  }\n\n  function encode (num) {\n    return lookup[num]\n  }\n\n  function tripletToBase64 (num) {\n    return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n  }\n\n  function encodeChunk (uint8, start, end) {\n    var temp\n    var output = []\n    for (var i = start; i < end; i += 3) {\n      temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n      output.push(tripletToBase64(temp))\n    }\n    return output.join('')\n  }\n\n  function uint8ToBase64 (uint8) {\n    var i\n    var extraBytes = uint8.length % 3 // if we have 1 byte left, pad 2 bytes\n    var output = ''\n    var parts = []\n    var temp, length\n    var maxChunkLength = 16383 // must be multiple of 3\n\n    // go through the array every three bytes, we'll deal with trailing stuff later\n\n    for (i = 0, length = uint8.length - extraBytes; i < length; i += maxChunkLength) {\n      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > length ? length : (i + maxChunkLength)))\n    }\n\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    switch (extraBytes) {\n      case 1:\n        temp = uint8[uint8.length - 1]\n        output += encode(temp >> 2)\n        output += encode((temp << 4) & 0x3F)\n        output += '=='\n        break\n      case 2:\n        temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n        output += encode(temp >> 10)\n        output += encode((temp >> 4) & 0x3F)\n        output += encode((temp << 2) & 0x3F)\n        output += '='\n        break\n      default:\n        break\n    }\n\n    parts.push(output)\n\n    return parts.join('')\n  }\n\n  exports.toByteArray = b64ToByteArray\n  exports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n","exports.name = \"ieee754\";\nexports.version = \"1.1.6\";\nexports.main = \"index.js\";\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","exports.name = \"isarray\";\nexports.version = \"1.0.0\";\nexports.main = \"index.js\";\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","exports.name = \"domain-browser\";\nexports.version = \"1.1.7\";\nexports.main = \"./index.js\";\n","// This file should be ES5 compatible\n/* eslint prefer-spread:0, no-var:0, prefer-reflect:0, no-magic-numbers:0 */\n'use strict'\nmodule.exports = (function () {\n\t// Import Events\n\tvar events = require('events')\n\n\t// Export Domain\n\tvar domain = {}\n\tdomain.createDomain = domain.create = function () {\n\t\tvar d = new events.EventEmitter()\n\n\t\tfunction emitError (e) {\n\t\t\td.emit('error', e)\n\t\t}\n\n\t\td.add = function (emitter) {\n\t\t\temitter.on('error', emitError)\n\t\t}\n\t\td.remove = function (emitter) {\n\t\t\temitter.removeListener('error', emitError)\n\t\t}\n\t\td.bind = function (fn) {\n\t\t\treturn function () {\n\t\t\t\tvar args = Array.prototype.slice.call(arguments)\n\t\t\t\ttry {\n\t\t\t\t\tfn.apply(null, args)\n\t\t\t\t}\n\t\t\t\tcatch (err) {\n\t\t\t\t\temitError(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td.intercept = function (fn) {\n\t\t\treturn function (err) {\n\t\t\t\tif ( err ) {\n\t\t\t\t\temitError(err)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments, 1)\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfn.apply(null, args)\n\t\t\t\t\t}\n\t\t\t\t\tcatch (err) {\n\t\t\t\t\t\temitError(err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td.run = function (fn) {\n\t\t\ttry {\n\t\t\t\tfn()\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\temitError(err)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\t\td.dispose = function () {\n\t\t\tthis.removeAllListeners()\n\t\t\treturn this\n\t\t}\n\t\td.enter = d.exit = function () {\n\t\t\treturn this\n\t\t}\n\t\treturn d\n\t}\n\treturn domain\n}).call(this)\n","exports.name = \"events\";\nexports.version = \"1.1.0\";\nexports.main = \"./events.js\";\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n"]}